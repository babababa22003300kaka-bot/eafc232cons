Selected Files Directory Structure:

â””â”€â”€ ./
    â””â”€â”€ FC26_sale_coins_Bot
        â”œâ”€â”€ core
        â”‚   â””â”€â”€ bot_app.py
        â”œâ”€â”€ database
        â”‚   â”œâ”€â”€ __init__.py
        â”‚   â”œâ”€â”€ admin_operations.py
        â”‚   â”œâ”€â”€ connection.py
        â”‚   â”œâ”€â”€ models.py
        â”‚   â””â”€â”€ operations.py
        â”œâ”€â”€ handlers
        â”‚   â”œâ”€â”€ commands
        â”‚   â”‚   â””â”€â”€ basic_commands.py
        â”‚   â”œâ”€â”€ recovery
        â”‚   â”‚   â””â”€â”€ global_router.py
        â”‚   â”œâ”€â”€ registration
        â”‚   â”‚   â”œâ”€â”€ conversation.py
        â”‚   â”‚   â”œâ”€â”€ handlers.py
        â”‚   â”‚   â”œâ”€â”€ helpers.py
        â”‚   â”‚   â””â”€â”€ states.py
        â”‚   â”œâ”€â”€ __init__.py
        â”‚   â”œâ”€â”€ continue_handler.py
        â”‚   â”œâ”€â”€ profile_delete_handler.py
        â”‚   â””â”€â”€ start_handler.py
        â”œâ”€â”€ keyboards
        â”‚   â”œâ”€â”€ __init__.py
        â”‚   â”œâ”€â”€ payment_keyboard.py
        â”‚   â””â”€â”€ platform_keyboard.py
        â”œâ”€â”€ messages
        â”‚   â”œâ”€â”€ __init__.py
        â”‚   â”œâ”€â”€ confirmation_msgs.py
        â”‚   â”œâ”€â”€ error_messages.py
        â”‚   â”œâ”€â”€ summary_messages.py
        â”‚   â””â”€â”€ welcome_messages.py
        â”œâ”€â”€ services
        â”‚   â”œâ”€â”€ admin
        â”‚   â”‚   â”œâ”€â”€ __init__.py
        â”‚   â”‚   â”œâ”€â”€ admin_conversation_handler.py
        â”‚   â”‚   â”œâ”€â”€ admin_handler.py
        â”‚   â”‚   â”œâ”€â”€ admin_keyboards.py
        â”‚   â”‚   â”œâ”€â”€ admin_messages.py
        â”‚   â”‚   â””â”€â”€ price_management.py
        â”‚   â”œâ”€â”€ sell_coins
        â”‚   â”‚   â”œâ”€â”€ __init__.py
        â”‚   â”‚   â”œâ”€â”€ sell_callbacks.py
        â”‚   â”‚   â”œâ”€â”€ sell_conversation_functions.py
        â”‚   â”‚   â”œâ”€â”€ sell_conversation_handler.py
        â”‚   â”‚   â”œâ”€â”€ sell_handler.py
        â”‚   â”‚   â”œâ”€â”€ sell_keyboards.py
        â”‚   â”‚   â”œâ”€â”€ sell_messages.py
        â”‚   â”‚   â””â”€â”€ sell_pricing.py
        â”‚   â”œâ”€â”€ __init__.py
        â”‚   â””â”€â”€ service_template.py
        â”œâ”€â”€ states
        â”‚   â”œâ”€â”€ __init__.py
        â”‚   â””â”€â”€ sell_states.py
        â”œâ”€â”€ utils
        â”‚   â”œâ”€â”€ __init__.py
        â”‚   â”œâ”€â”€ backup_job.py
        â”‚   â”œâ”€â”€ handler_filters.py
        â”‚   â”œâ”€â”€ locks.py
        â”‚   â”œâ”€â”€ logger.py
        â”‚   â”œâ”€â”€ message_tagger.py
        â”‚   â”œâ”€â”€ session_bucket.py
        â”‚   â””â”€â”€ session_monitor.py
        â”œâ”€â”€ validators
        â”‚   â”œâ”€â”€ __init__.py
        â”‚   â”œâ”€â”€ payment_validator.py
        â”‚   â”œâ”€â”€ phone_validator.py
        â”‚   â””â”€â”€ url_validator.py
        â”œâ”€â”€ config.py
        â””â”€â”€ main.py



--- FC26_sale_coins_Bot/config.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘                ğŸ® FC26 GAMING BOT - CONFIGURATION                        â•‘
# â•‘                     Ø¨ÙˆØª FC26 Ù„Ù„Ø£Ù„Ø¹Ø§Ø¨ - Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª                       â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import os
from typing import Dict

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘ ğŸ”§ [ BOT CONFIGURATION ]                                                â•‘
# â•‘ ğŸ” Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ÙˆØ§Ù„ØªÙˆÙƒÙ†                                            â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Bot Token - ÙŠÙØ¶Ù„ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…ØªØºÙŠØ± Ø§Ù„Ø¨ÙŠØ¦Ø©
BOT_TOKEN = os.getenv('BOT_TOKEN', '7607085569:AAHKE8SNOTYycRRzOCCddmm8QPDTOnEx144')

# Database Configuration
DATABASE_CONFIG = {
    'name': 'fc26_bot.db',
    'path': './database/',
    'backup_path': './database/backups/'
}

# â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
# â”‚ ğŸ® GAMING PLATFORMS - Ù…Ù†ØµØ§Øª Ø§Ù„Ø£Ù„Ø¹Ø§Ø¨                                 â”‚
# â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

GAMING_PLATFORMS = {
    "playstation": {"name": "ğŸ® PlayStation (PS4/PS5)", "emoji": "ğŸ®"},
    "xbox": {"name": "â Xbox (One/Series)", "emoji": "â"},
    "pc": {"name": "ğŸ’» PC (Origin/Steam)", "emoji": "ğŸ’»"},
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ’³ PAYMENT METHODS - Ø·Ø±Ù‚ Ø§Ù„Ø¯ÙØ¹ Ø§Ù„ÙƒØ§Ù…Ù„Ø©
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

PAYMENT_METHODS = {
    "vodafone_cash": "â­•ï¸ ÙÙˆØ¯Ø§ÙÙˆÙ† ÙƒØ§Ø´",
    "etisalat_cash": "ğŸŸ¢ Ø§ØªØµØ§Ù„Ø§Øª ÙƒØ§Ø´",
    "orange_cash": "ğŸŠ Ø£ÙˆØ±Ø§Ù†Ø¬ ÙƒØ§Ø´",
    "we_cash": "ğŸŸ£ ÙˆÙŠ ÙƒØ§Ø´",
    "bank_wallet": "ğŸ¦ Ù…Ø­ÙØ¸Ø© Ø¨Ù†ÙƒÙŠØ©",
    "telda": "ğŸ’³ ØªÙŠÙ„Ø¯Ø§",
    "instapay": "ğŸ”— Ø¥Ù†Ø³ØªØ§ Ø¨Ø§ÙŠ",
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ“ LOGGING CONFIGURATION - Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø³Ø¬Ù„Ø§Øª
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

LOGGING_CONFIG = {
    'level': 'INFO',
    'format': '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    'file': './logs/fc26_bot.log',
    'max_bytes': 5 * 1024 * 1024,  # 5MB
    'backup_count': 5,
    'encoding': 'utf-8'
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ›¡ï¸ SECURITY SETTINGS - Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø£Ù…Ø§Ù†
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

SECURITY_CONFIG = {
    'max_input_length': 500,
    'allowed_phone_patterns': [r'^01[0125][0-9]{8}$'],
    'blocked_chars': ['<', '>', '"', "'", '&', 'script', 'javascript'],
    'rate_limit': {
        'messages_per_minute': 10,
        'registration_attempts': 3
    }
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ¨ UI CONFIGURATION - Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

UI_CONFIG = {
    'messages': {
        'timeout': 300,  # 5 minutes
        'auto_delete': True,
        'max_buttons_per_row': 2
    },
    'emojis': {
        'success': 'âœ…',
        'error': 'âŒ',
        'warning': 'âš ï¸',
        'info': 'â„¹ï¸',
        'loading': 'â³'
    }
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ“Š STATISTICS CONFIGURATION - Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

STATS_CONFIG = {
    'enabled': True,
    'daily_reports': True,
    'metrics': ['users', 'registrations', 'errors', 'response_times']
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ”„ BACKUP CONFIGURATION - Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

BACKUP_CONFIG = {
    'enabled': True,
    'interval_hours': 6,
    'max_backups': 10,
    'compress': True
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸŒ ENVIRONMENT SETTINGS - Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø©
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ENVIRONMENT = os.getenv('ENVIRONMENT', 'development')
DEBUG = os.getenv('DEBUG', 'False').lower() == 'true'

# Development/Production specific settings
if ENVIRONMENT == 'production':
    LOGGING_CONFIG['level'] = 'WARNING'
    DEBUG = False
    SECURITY_CONFIG['rate_limit']['messages_per_minute'] = 5
else:
    LOGGING_CONFIG['level'] = 'DEBUG'
    DEBUG = True

# â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
# â”‚                           ğŸ‰ END OF CONFIGURATION ğŸ‰                      â”‚
# â”‚                      âœ¨ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø´Ø§Ù…Ù„Ø© ÙˆÙ…Ù†Ø¸Ù…Ø© âœ¨                            â”‚
# â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

--- FC26_sale_coins_Bot/core/bot_app.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ¤– BOT APPLICATION FACTORY                                  â•‘
# â•‘              Ù…ØµÙ†Ø¹ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¨ÙˆØª - Ù…Ø¹ Persistence                          â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Ù…ØµÙ†Ø¹ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¨ÙˆØª
- ØªÙØ¹ÙŠÙ„ PicklePersistence
- Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ø§Ù„Ø¯Ø§Ø¦Ù…Ø©
"""

from pathlib import Path

from telegram.ext import Application, PicklePersistence

from config import BOT_TOKEN


class FC26BotApp:
    """Ù…ØµÙ†Ø¹ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¨ÙˆØª"""

    def create_application(self):
        """
        Ø¥Ù†Ø´Ø§Ø¡ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¨ÙˆØª Ù…Ø¹ ØªÙØ¹ÙŠÙ„ Persistence

        Returns:
            Application: ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¨ÙˆØª Ø¬Ø§Ù‡Ø²
        """
        print("\nğŸ¤– [BOT-APP] Creating application with persistence...")

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # 1ï¸âƒ£ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù„Ø¯ data/ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        data_dir = Path("data")
        data_dir.mkdir(parents=True, exist_ok=True)
        print(f"   ğŸ“ Data directory ready: {data_dir}")

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # 2ï¸âƒ£ Ø¥Ù†Ø´Ø§Ø¡ ÙƒØ§Ø¦Ù† PicklePersistence
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        session_file = data_dir / "sessions.pkl"

        persistence = PicklePersistence(
            filepath=str(session_file),
            update_interval=60,  # Ø­ÙØ¸ ÙƒÙ„ 60 Ø«Ø§Ù†ÙŠØ©
        )
        print(f"   ğŸ’¾ Persistence configured: {session_file}")
        print(f"   â±ï¸ Update interval: 60 seconds")

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # 3ï¸âƒ£ Ø¨Ù†Ø§Ø¡ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ù…Ø¹ Persistence
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        app = (
            Application.builder()
            .token(BOT_TOKEN)
            .persistence(persistence)  # ğŸ”¥ ØªÙØ¹ÙŠÙ„ Persistence
            .build()
        )

        print(f"   âœ… Application created successfully")
        print(f"   ğŸ”¥ Persistence ENABLED")
        print()

        return app


--- FC26_sale_coins_Bot/database/__init__.py ---



--- FC26_sale_coins_Bot/database/admin_operations.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ¯ FC26 ADMIN DATABASE OPERATIONS - Ø¹Ù…Ù„ÙŠØ§Øª Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø§Ø¯Ù…Ù†  â•‘
# â•‘                     Admin Database Management                            â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import sqlite3
import logging
from typing import Dict, List, Optional, Tuple
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
import asyncio

logger = logging.getLogger(__name__)

class AdminOperations:
    """Ø¹Ù…Ù„ÙŠØ§Øª Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„Ø§Ø¯Ù…Ù†"""
    
    DB_NAME = "fc26_admin.db"
    
    # ğŸ”¥ Thread-safe database executor - ONLY ONE worker to prevent locks
    # This ensures all database operations are serialized (one at a time)
    _db_executor = ThreadPoolExecutor(max_workers=1, thread_name_prefix="AdminDB")
    
    @classmethod
    def init_admin_db(cls):
        """ØªÙ‡ÙŠØ¦Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø§Ø¯Ù…Ù†"""
        conn = sqlite3.connect(cls.DB_NAME)
        cursor = conn.cursor()
        
        # Ø¬Ø¯ÙˆÙ„ Ø£Ø³Ø¹Ø§Ø± Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS coin_prices (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                platform TEXT NOT NULL,
                transfer_type TEXT NOT NULL,
                amount INTEGER NOT NULL,
                price INTEGER NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(platform, transfer_type, amount)
            )
        ''')
        
        # Ø¬Ø¯ÙˆÙ„ Ø³Ø¬Ù„ ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø§Ù„Ø§Ø¯Ù…Ù†
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS admin_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                admin_id INTEGER NOT NULL,
                action TEXT NOT NULL,
                details TEXT,
                timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Ø¥Ø¯Ø±Ø§Ø¬ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
        cls._insert_default_prices(cursor)
        
        conn.commit()
        conn.close()
        
        logger.info("âœ… Admin database initialized successfully")
    
    @classmethod
    def _insert_default_prices(cls, cursor):
        """Ø¥Ø¯Ø±Ø§Ø¬ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©"""
        default_prices = [
            # PlayStation - Normal
            ('playstation', 'normal', 1000000, 5600),
            # PlayStation - Instant  
            ('playstation', 'instant', 1000000, 5300),
            # Xbox - Normal
            ('xbox', 'normal', 1000000, 5600),
            # Xbox - Instant
            ('xbox', 'instant', 1000000, 5300),
            # PC - Normal
            ('pc', 'normal', 1000000, 6100),
            # PC - Instant
            ('pc', 'instant', 1000000, 5800),
        ]
        
        for platform, transfer_type, amount, price in default_prices:
            cursor.execute('''
                INSERT OR IGNORE INTO coin_prices 
                (platform, transfer_type, amount, price) 
                VALUES (?, ?, ?, ?)
            ''', (platform, transfer_type, amount, price))
    
    @classmethod
    def get_price(cls, platform: str, transfer_type: str, amount: int) -> Optional[int]:
        """Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¹Ø± Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
        conn = sqlite3.connect(cls.DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT price FROM coin_prices 
            WHERE platform = ? AND transfer_type = ? AND amount = ?
        ''', (platform, transfer_type, amount))
        
        result = cursor.fetchone()
        conn.close()
        
        return result[0] if result else None
    
    @classmethod
    def _update_price_sync(cls, platform: str, transfer_type: str, amount: int, new_price: int, admin_id: int) -> bool:
        """ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ø¹Ø± ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª - Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù…ØªØ²Ø§Ù…Ù†Ø© Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ©"""
        conn = None
        try:
            # Enable WAL mode for better concurrency
            conn = sqlite3.connect(cls.DB_NAME, timeout=30.0)
            conn.execute('PRAGMA journal_mode=WAL')
            cursor = conn.cursor()
            
            print(f"ğŸ”„ [DB] Starting price update: {platform} {transfer_type} -> {new_price}")
            
            # Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ù‚Ø¯ÙŠÙ…
            cursor.execute('''
                SELECT price FROM coin_prices 
                WHERE platform = ? AND transfer_type = ? AND amount = ?
            ''', (platform, transfer_type, amount))
            result = cursor.fetchone()
            old_price = result[0] if result else None
            
            print(f"ğŸ’° [DB] Old price: {old_price}, New price: {new_price}")
            
            # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ø¹Ø±
            cursor.execute('''
                INSERT OR REPLACE INTO coin_prices 
                (platform, transfer_type, amount, price, updated_at) 
                VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)
            ''', (platform, transfer_type, amount, new_price))
            
            # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© ÙÙŠ Ø§Ù„Ø³Ø¬Ù„
            details = f"Platform: {platform}, Type: {transfer_type}, Amount: {amount}, Old: {old_price}, New: {new_price}"
            cursor.execute('''
                INSERT INTO admin_logs (admin_id, action, details) 
                VALUES (?, ?, ?)
            ''', (admin_id, "UPDATE_PRICE", details))
            
            conn.commit()
            print(f"âœ… [DB] Price updated successfully: {platform} {transfer_type} {amount} -> {new_price}")
            logger.info(f"âœ… Price updated: {platform} {transfer_type} {amount} -> {new_price}")
            return True
            
        except Exception as e:
            print(f"âŒ [DB] Failed to update price: {e}")
            logger.error(f"âŒ Failed to update price: {e}")
            if conn:
                conn.rollback()
            return False
        finally:
            if conn:
                conn.close()
                print(f"ğŸ”’ [DB] Connection closed")
    
    @classmethod
    async def update_price(cls, platform: str, transfer_type: str, amount: int, new_price: int, admin_id: int) -> bool:
        """ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ø¹Ø± ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª - Thread-safe version"""
        print(f"ğŸ“ [DB-EXECUTOR] Submitting price update task to database executor")
        loop = asyncio.get_event_loop()
        
        # Run database operation in dedicated thread pool
        result = await loop.run_in_executor(
            cls._db_executor,
            cls._update_price_sync,
            platform, transfer_type, amount, new_price, admin_id
        )
        
        print(f"âœ… [DB-EXECUTOR] Price update task completed: {result}")
        return result
    
    @classmethod
    def get_all_prices(cls) -> List[Dict]:
        """Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±"""
        conn = sqlite3.connect(cls.DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT platform, transfer_type, amount, price, updated_at 
            FROM coin_prices 
            ORDER BY platform, transfer_type, amount
        ''')
        
        results = cursor.fetchall()
        conn.close()
        
        prices = []
        for row in results:
            prices.append({
                'platform': row[0],
                'transfer_type': row[1], 
                'amount': row[2],
                'price': row[3],
                'updated_at': row[4]
            })
        
        return prices
    
    @classmethod
    def log_admin_action(cls, admin_id: int, action: str, details: str = ""):
        """ØªØ³Ø¬ÙŠÙ„ Ø¹Ù…Ù„ Ø§Ù„Ø§Ø¯Ù…Ù†"""
        conn = sqlite3.connect(cls.DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO admin_logs (admin_id, action, details) 
            VALUES (?, ?, ?)
        ''', (admin_id, action, details))
        
        conn.commit()
        conn.close()
    
    @classmethod
    def get_admin_logs(cls, limit: int = 50) -> List[Dict]:
        """Ø¬Ù„Ø¨ Ø³Ø¬Ù„ Ø£Ø¹Ù…Ø§Ù„ Ø§Ù„Ø§Ø¯Ù…Ù†"""
        conn = sqlite3.connect(cls.DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT admin_id, action, details, timestamp 
            FROM admin_logs 
            ORDER BY timestamp DESC 
            LIMIT ?
        ''', (limit,))
        
        results = cursor.fetchall()
        conn.close()
        
        logs = []
        for row in results:
            logs.append({
                'admin_id': row[0],
                'action': row[1],
                'details': row[2],
                'timestamp': row[3]
            })
        
        return logs
    
    @classmethod
    def get_current_timestamp(cls) -> str:
        """Ø¬Ù„Ø¨ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø­Ø§Ù„ÙŠ"""
        return datetime.now().strftime('%Y-%m-%d %H:%M:%S')

--- FC26_sale_coins_Bot/database/connection.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ’¾ FC26 DATABASE CONNECTION - Ø§ØªØµØ§Ù„ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª          â•‘
# â•‘                     Database Connection Management                       â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import sqlite3
import logging
import os
from typing import Optional
from contextlib import contextmanager
from config import DATABASE_CONFIG

logger = logging.getLogger(__name__)

class DatabaseConnection:
    """Database connection manager with proper error handling"""
    
    def __init__(self):
        self.db_path = os.path.join(DATABASE_CONFIG['path'], DATABASE_CONFIG['name'])
        self._ensure_database_directory()
    
    def _ensure_database_directory(self):
        """Ensure database directory exists"""
        os.makedirs(DATABASE_CONFIG['path'], exist_ok=True)
        if DATABASE_CONFIG.get('backup_path'):
            os.makedirs(DATABASE_CONFIG['backup_path'], exist_ok=True)
    
    @contextmanager
    def get_connection(self):
        """Context manager for database connections"""
        conn = None
        try:
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row  # Enable dict-like access
            yield conn
        except Exception as e:
            if conn:
                conn.rollback()
            logger.error(f"Database error: {e}")
            raise
        finally:
            if conn:
                conn.close()
    
    def execute_query(self, query: str, params: tuple = ()) -> Optional[list]:
        """Execute a SELECT query and return results"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(query, params)
            return cursor.fetchall()
    
    def execute_update(self, query: str, params: tuple = ()) -> int:
        """Execute an INSERT/UPDATE/DELETE query and return affected rows"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(query, params)
            conn.commit()
            return cursor.rowcount
    
    def execute_script(self, script: str):
        """Execute multiple SQL statements"""
        with self.get_connection() as conn:
            conn.executescript(script)
            conn.commit()

# Global database instance
db = DatabaseConnection()

--- FC26_sale_coins_Bot/database/models.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ“‹ FC26 DATABASE MODELS - Ù†Ù…Ø§Ø°Ø¬ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª             â•‘
# â•‘                        Database Table Schemas                           â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from database.connection import db
import logging

logger = logging.getLogger(__name__)

class DatabaseModels:
    """Database table creation and schema management"""
    
    @staticmethod
    def create_all_tables():
        """Create all required database tables"""
        try:
            # Create users table
            db.execute_update("""
                CREATE TABLE IF NOT EXISTS users (
                    telegram_id INTEGER PRIMARY KEY,
                    platform TEXT,
                    whatsapp TEXT,
                    payment_method TEXT,
                    payment_details TEXT,
                    registration_step TEXT DEFAULT 'start',
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            # Create registration_log table for tracking
            db.execute_update("""
                CREATE TABLE IF NOT EXISTS registration_log (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    telegram_id INTEGER,
                    step TEXT,
                    data TEXT,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (telegram_id) REFERENCES users (telegram_id)
                )
            """)
            
            # Create error_log table
            db.execute_update("""
                CREATE TABLE IF NOT EXISTS error_log (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    telegram_id INTEGER,
                    error_type TEXT,
                    error_message TEXT,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            # Create statistics table
            db.execute_update("""
                CREATE TABLE IF NOT EXISTS statistics (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    date DATE DEFAULT CURRENT_DATE,
                    metric_name TEXT,
                    metric_value INTEGER DEFAULT 0,
                    UNIQUE(date, metric_name)
                )
            """)
            
            logger.info("âœ… All database tables created successfully")
            return True
            
        except Exception as e:
            logger.error(f"âŒ Error creating database tables: {e}")
            return False
    
    @staticmethod
    def drop_all_tables():
        """Drop all tables (use with caution!)"""
        tables = ['users', 'registration_log', 'error_log', 'statistics']
        try:
            for table in tables:
                db.execute_update(f"DROP TABLE IF EXISTS {table}")
            logger.info("âš ï¸ All database tables dropped")
            return True
        except Exception as e:
            logger.error(f"âŒ Error dropping tables: {e}")
            return False
    
    @staticmethod
    def get_table_info():
        """Get information about all tables"""
        try:
            tables_info = {}
            
            # Get all tables
            tables = db.execute_query("""
                SELECT name FROM sqlite_master 
                WHERE type='table' AND name NOT LIKE 'sqlite_%'
            """)
            
            for table in tables:
                table_name = table[0]
                
                # Get table schema
                schema = db.execute_query(f"PRAGMA table_info({table_name})")
                
                # Get row count
                count = db.execute_query(f"SELECT COUNT(*) FROM {table_name}")[0][0]
                
                tables_info[table_name] = {
                    'columns': [col[1] for col in schema],
                    'row_count': count
                }
            
            return tables_info
            
        except Exception as e:
            logger.error(f"âŒ Error getting table info: {e}")
            return {}

# Initialize database on import
if __name__ != "__main__":
    DatabaseModels.create_all_tables()

--- FC26_sale_coins_Bot/database/operations.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ”§ FC26 DATABASE OPERATIONS - Ø¹Ù…Ù„ÙŠØ§Øª Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª        â•‘
# â•‘                     Database CRUD Operations                             â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import logging
from typing import Dict, Optional, List
from datetime import datetime
from database.connection import db

logger = logging.getLogger(__name__)

class UserOperations:
    """User-related database operations"""
    
    @staticmethod
    def save_user_step(user_id: int, step: str, data: Dict = None) -> bool:
        """Save user registration step and data"""
        try:
            # Check if user exists
            existing = db.execute_query(
                "SELECT telegram_id FROM users WHERE telegram_id = ?", (user_id,)
            )
            
            if existing:
                # Update existing user
                query = "UPDATE users SET registration_step = ?, updated_at = CURRENT_TIMESTAMP"
                params = [step, user_id]
                
                if data:
                    for key, value in data.items():
                        if key in ['platform', 'whatsapp', 'payment_method', 'payment_details']:
                            query += f", {key} = ?"
                            params.insert(-1, value)
                
                query += " WHERE telegram_id = ?"
                db.execute_update(query, tuple(params))
                
            else:
                # Insert new user
                platform = data.get('platform') if data else None
                whatsapp = data.get('whatsapp') if data else None
                payment_method = data.get('payment_method') if data else None
                payment_details = data.get('payment_details') if data else None
                
                db.execute_update("""
                    INSERT INTO users (telegram_id, platform, whatsapp, payment_method, payment_details, registration_step)
                    VALUES (?, ?, ?, ?, ?, ?)
                """, (user_id, platform, whatsapp, payment_method, payment_details, step))
            
            # Log the step
            RegistrationOperations.log_step(user_id, step, str(data) if data else None)
            
            logger.info(f"âœ… Step saved for user {user_id}: {step}")
            return True
            
        except Exception as e:
            logger.error(f"âŒ Error saving user step: {e}")
            return False
    
    @staticmethod
    def get_user_data(user_id: int) -> Optional[Dict]:
        """Get user data from database"""
        try:
            result = db.execute_query("""
                SELECT telegram_id, platform, whatsapp, payment_method, 
                       payment_details, registration_step, created_at, updated_at
                FROM users WHERE telegram_id = ?
            """, (user_id,))
            
            if result:
                row = result[0]
                return {
                    "telegram_id": row[0],
                    "platform": row[1],
                    "whatsapp": row[2],
                    "payment_method": row[3],
                    "payment_details": row[4],
                    "registration_step": row[5],
                    "created_at": row[6],
                    "updated_at": row[7]
                }
            return None
            
        except Exception as e:
            logger.error(f"âŒ Error getting user data: {e}")
            return None
    
    @staticmethod
    def user_exists(user_id: int) -> bool:
        """Check if user exists in database"""
        try:
            result = db.execute_query(
                "SELECT telegram_id FROM users WHERE telegram_id = ?", (user_id,)
            )
            return len(result) > 0
        except Exception as e:
            logger.error(f"âŒ Error checking user existence: {e}")
            return False
    
    @staticmethod
    def delete_user(user_id: int) -> bool:
        """Delete user and related data"""
        try:
            # Delete user data
            affected = db.execute_update("DELETE FROM users WHERE telegram_id = ?", (user_id,))
            
            # Delete registration logs
            db.execute_update("DELETE FROM registration_log WHERE telegram_id = ?", (user_id,))
            
            if affected > 0:
                logger.info(f"âœ… User {user_id} deleted successfully")
                return True
            else:
                logger.warning(f"âš ï¸ User {user_id} not found for deletion")
                return False
                
        except Exception as e:
            logger.error(f"âŒ Error deleting user: {e}")
            return False
    
    @staticmethod
    def update_user_field(user_id: int, field: str, value: str) -> bool:
        """Update specific field for user"""
        allowed_fields = {'platform', 'whatsapp', 'payment_method', 'payment_details', 'registration_step'}
        
        if field not in allowed_fields:
            logger.error(f"âŒ Invalid field name: {field}")
            return False
        
        try:
            affected = db.execute_update(
                f"UPDATE users SET {field} = ?, updated_at = CURRENT_TIMESTAMP WHERE telegram_id = ?",
                (value, user_id)
            )
            
            if affected > 0:
                logger.info(f"âœ… Field {field} updated for user {user_id}")
                return True
            else:
                logger.warning(f"âš ï¸ User {user_id} not found for field update")
                return False
                
        except Exception as e:
            logger.error(f"âŒ Error updating user field: {e}")
            return False

class RegistrationOperations:
    """Registration tracking operations"""
    
    @staticmethod
    def log_step(user_id: int, step: str, data: str = None) -> bool:
        """Log registration step"""
        try:
            db.execute_update("""
                INSERT INTO registration_log (telegram_id, step, data)
                VALUES (?, ?, ?)
            """, (user_id, step, data))
            return True
        except Exception as e:
            logger.error(f"âŒ Error logging registration step: {e}")
            return False
    
    @staticmethod
    def get_user_registration_history(user_id: int) -> List[Dict]:
        """Get user's registration history"""
        try:
            result = db.execute_query("""
                SELECT step, data, timestamp 
                FROM registration_log 
                WHERE telegram_id = ? 
                ORDER BY timestamp DESC
            """, (user_id,))
            
            return [{"step": row[0], "data": row[1], "timestamp": row[2]} for row in result]
        except Exception as e:
            logger.error(f"âŒ Error getting registration history: {e}")
            return []

class StatisticsOperations:
    """Statistics and analytics operations"""
    
    @staticmethod
    def get_users_count() -> int:
        """Get total number of users"""
        try:
            result = db.execute_query("SELECT COUNT(*) FROM users")
            return result[0][0] if result else 0
        except Exception as e:
            logger.error(f"âŒ Error getting users count: {e}")
            return 0
    
    @staticmethod
    def get_completed_registrations() -> int:
        """Get number of completed registrations"""
        try:
            result = db.execute_query(
                "SELECT COUNT(*) FROM users WHERE registration_step = 'completed'"
            )
            return result[0][0] if result else 0
        except Exception as e:
            logger.error(f"âŒ Error getting completed registrations: {e}")
            return 0
    
    @staticmethod
    def update_daily_metric(metric_name: str, value: int = 1) -> bool:
        """Update daily metric"""
        try:
            # Try to update existing record
            affected = db.execute_update("""
                UPDATE statistics 
                SET metric_value = metric_value + ? 
                WHERE date = CURRENT_DATE AND metric_name = ?
            """, (value, metric_name))
            
            # If no record exists, create new one
            if affected == 0:
                db.execute_update("""
                    INSERT INTO statistics (metric_name, metric_value)
                    VALUES (?, ?)
                """, (metric_name, value))
            
            return True
        except Exception as e:
            logger.error(f"âŒ Error updating daily metric: {e}")
            return False

class ErrorOperations:
    """Error logging operations"""
    
    @staticmethod
    def log_error(user_id: int, error_type: str, error_message: str) -> bool:
        """Log error to database"""
        try:
            db.execute_update("""
                INSERT INTO error_log (telegram_id, error_type, error_message)
                VALUES (?, ?, ?)
            """, (user_id, error_type, error_message))
            return True
        except Exception as e:
            logger.error(f"âŒ Error logging error: {e}")
            return False

--- FC26_sale_coins_Bot/handlers/__init__.py ---



--- FC26_sale_coins_Bot/handlers/commands/basic_commands.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ”§ BASIC COMMANDS                                           â•‘
# â•‘              Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©                                           â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
- /help
- /profile
- /delete
"""

from telegram.ext import CommandHandler

from database.operations import UserOperations
from handlers.profile_delete_handler import ProfileDeleteHandler
from messages.error_messages import ErrorMessages
from messages.summary_messages import SummaryMessages
from messages.welcome_messages import WelcomeMessages
from utils.logger import log_user_action


async def handle_help(update, context):
    """Ø£Ù…Ø± /help"""
    user_id = update.effective_user.id
    log_user_action(user_id, "Help")

    await update.message.reply_text(
        WelcomeMessages.get_help_message(), parse_mode="HTML"
    )


async def handle_profile(update, context):
    """Ø£Ù…Ø± /profile"""
    user_id = update.effective_user.id
    log_user_action(user_id, "Profile")

    user_data = UserOperations.get_user_data(user_id)

    if not user_data:
        await update.message.reply_text(ErrorMessages.get_start_required_error())
        return

    profile_text = SummaryMessages.create_user_profile_summary(user_data)
    keyboard = ProfileDeleteHandler.create_profile_management_keyboard()

    await update.message.reply_text(
        profile_text, reply_markup=keyboard, parse_mode="HTML"
    )


async def handle_delete(update, context):
    """Ø£Ù…Ø± /delete"""
    user_id = update.effective_user.id
    log_user_action(user_id, "Delete request")

    user_data = UserOperations.get_user_data(user_id)

    if not user_data:
        await update.message.reply_text(
            "âŒ <b>Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ù„Ù Ø´Ø®ØµÙŠ!</b>\n\nğŸš€ /start Ù„Ù„ØªØ³Ø¬ÙŠÙ„",
            parse_mode="HTML",
        )
        return

    username = update.effective_user.username or "ØºÙŠØ± Ù…Ø­Ø¯Ø¯"

    confirmation_text = f"""âš ï¸ <b>ØªØ­Ø°ÙŠØ±!</b>

ğŸ—‘ï¸ <b>Ù…Ø³Ø­ Ù†Ù‡Ø§Ø¦ÙŠ Ù„Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ</b>

<b>ğŸ“‹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª:</b>
â€¢ ğŸ® {user_data.get('platform', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}
â€¢ ğŸ“± {user_data.get('whatsapp', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}

<b>ğŸ‘¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:</b> @{username}

<b>â“ Ù…ØªØ£ÙƒØ¯ØŸ</b>"""

    keyboard = ProfileDeleteHandler.create_delete_confirmation_keyboard()

    await update.message.reply_text(
        confirmation_text, reply_markup=keyboard, parse_mode="HTML"
    )


def get_command_handlers():
    """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ handlers Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©"""
    handlers = [
        CommandHandler("help", handle_help),
        CommandHandler("profile", handle_profile),
        CommandHandler("delete", handle_delete),
    ]

    # Ø¥Ø¶Ø§ÙØ© handlers Ù…Ù† ProfileDeleteHandler
    handlers.extend(ProfileDeleteHandler.get_handlers())

    return handlers


--- FC26_sale_coins_Bot/handlers/continue_handler.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ”„ FC26 CONTINUE HANDLER - Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø§Ø³ØªÙƒÙ…Ø§Ù„                 â•‘
# â•‘                    Continue Registration Handler                         â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from telegram import Update
from telegram.ext import ContextTypes
from messages.welcome_messages import WelcomeMessages
from keyboards.platform_keyboard import PlatformKeyboard
from keyboards.payment_keyboard import PaymentKeyboard
from utils.logger import log_user_action

async def handle_continue_registration(update: Update, context: ContextTypes.DEFAULT_TYPE, user_data: dict):
    """Handle continuing registration from where user left off"""
    user_id = update.effective_user.id
    step = user_data.get("registration_step", "start")
    
    log_user_action(user_id, f"Continue registration from step: {step}")
    
    try:
        # Get continuation message
        continue_text = WelcomeMessages.get_continue_registration_message(step, user_data)
        
        if step == "choosing_platform":
            # Show platform selection keyboard
            keyboard = PlatformKeyboard.create_platform_selection_keyboard()
            await update.message.reply_text(
                continue_text, 
                reply_markup=keyboard, 
                parse_mode="HTML"
            )
            
        elif step == "choosing_payment":
            # Show payment selection keyboard
            keyboard = PaymentKeyboard.create_payment_selection_keyboard()
            await update.message.reply_text(
                continue_text, 
                reply_markup=keyboard, 
                parse_mode="HTML"
            )
            
        elif step == "entering_whatsapp":
            # Just show the message for WhatsApp input
            await update.message.reply_text(continue_text, parse_mode="Markdown")
            
        elif step == "entering_payment_details":
            # Just show the message for payment details input
            await update.message.reply_text(continue_text, parse_mode="Markdown")
            
        else:
            # Default case - show basic continue message
            await update.message.reply_text(continue_text, parse_mode="Markdown")
            
    except Exception as e:
        from utils.logger import fc26_logger
        logger = fc26_logger.get_logger()
        logger.error(f"âŒ Error in continue registration for user {user_id}: {e}")
        
        from messages.error_messages import ErrorMessages
        await update.message.reply_text(ErrorMessages.get_general_error(), parse_mode="HTML")

--- FC26_sale_coins_Bot/handlers/profile_delete_handler.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ—‘ï¸ FC26 PROFILE DELETE HANDLER - Ù…Ø¹Ø§Ù„Ø¬ Ù…Ø³Ø­ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ      â•‘
# â•‘                     Profile Management & Deletion                        â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, CallbackQueryHandler
from typing import List

# Import database operations
from database.operations import UserOperations

# Import logging utilities
from utils.logger import log_user_action, fc26_logger

# Import messages
from messages.error_messages import ErrorMessages

class ProfileDeleteHandler:
    """Handle profile management and deletion functionality"""
    
    @staticmethod
    def create_profile_management_keyboard():
        """Create keyboard for profile management with delete option"""
        keyboard = [
            [InlineKeyboardButton("ğŸ—‘ï¸ Ù…Ø³Ø­ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ", callback_data="delete_profile_confirm")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def create_delete_confirmation_keyboard():
        """Create confirmation keyboard for profile deletion"""
        keyboard = [
            [
                InlineKeyboardButton("âŒ Ù†Ø¹Ù…ØŒ Ø§Ù…Ø³Ø­ ÙƒÙ„ Ø´ÙŠØ¡", callback_data="delete_profile_execute"),
                InlineKeyboardButton("âœ… Ù„Ø§ØŒ Ø±Ø§Ø¬Ø¹ ØªØ§Ù†ÙŠ", callback_data="delete_profile_cancel")
            ]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    async def handle_delete_confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle delete profile confirmation dialog"""
        query = update.callback_query
        user_id = query.from_user.id
        username = query.from_user.username or "ØºÙŠØ± Ù…Ø­Ø¯Ø¯"
        
        logger = fc26_logger.get_logger()
        logger.info(f"ğŸ—‘ï¸ User {user_id} requested profile deletion confirmation")
        
        try:
            await query.answer()
            
            # Check if user exists
            user_data = UserOperations.get_user_data(user_id)
            if not user_data:
                await query.edit_message_text(
                    "âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ù„Ù Ø´Ø®ØµÙŠ Ù„Ø­Ø°ÙÙ‡!\n\nğŸš€ Ø§ÙƒØªØ¨ /start Ù„Ø¨Ø¯Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„",
                    parse_mode="HTML"
                )
                return
            
            # Create confirmation message
            confirmation_text = f"""âš ï¸ <b>ØªØ­Ø°ÙŠØ± Ù‡Ø§Ù…!</b>

ğŸ—‘ï¸ <b>Ø£Ù†Øª Ø¹Ù„Ù‰ ÙˆØ´Ùƒ Ù…Ø³Ø­ Ù…Ù„ÙÙƒ Ø§Ù„Ø´Ø®ØµÙŠ Ù†Ù‡Ø§Ø¦ÙŠØ§Ù‹</b>

<b>ğŸ“‹ Ø³ÙŠØªÙ… Ù…Ø³Ø­ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©:</b>
â€¢ ğŸ® Ø§Ù„Ù…Ù†ØµØ©: {user_data.get('platform', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}
â€¢ ğŸ“± Ø±Ù‚Ù… Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨: {user_data.get('whatsapp', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}  
â€¢ ğŸ’³ Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹: {user_data.get('payment_method', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}
â€¢ ğŸ“Š Ø³Ø¬Ù„ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ ÙˆØ§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
â€¢ ğŸ—‚ï¸ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø© Ø¨Ø­Ø³Ø§Ø¨Ùƒ

<b>âš ï¸ Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù†Ù‡!</b>

<b>ğŸ”„ Ø¨Ø¹Ø¯ Ø§Ù„Ù…Ø³Ø­:</b>
â€¢ Ø³ØªØ­ØªØ§Ø¬ Ù„Ù„ØªØ³Ø¬ÙŠÙ„ Ù…Ù† Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
â€¢ Ø³ØªÙÙ‚Ø¯ Ø¬Ù…ÙŠØ¹ Ø¨ÙŠØ§Ù†Ø§ØªÙƒ Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©
â€¢ Ù„Ù† Ù†ØªÙ…ÙƒÙ† Ù…Ù† Ø§Ø³ØªØ±Ø¯Ø§Ø¯ Ø£ÙŠ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª

<b>ğŸ‘¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:</b> @{username}
<b>ğŸ†” Ù…Ø¹Ø±Ù Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…:</b> {user_id}

<b>â“ Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø±ØºØ¨ØªÙƒ ÙÙŠ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©ØŸ</b>"""
            
            keyboard = ProfileDeleteHandler.create_delete_confirmation_keyboard()
            
            await query.edit_message_text(
                confirmation_text,
                reply_markup=keyboard,
                parse_mode="HTML"
            )
            
            log_user_action(user_id, f"Profile deletion confirmation shown", f"@{username}")
            
        except Exception as e:
            logger.error(f"âŒ Error showing deletion confirmation for user {user_id}: {e}")
            await query.edit_message_text(
                ErrorMessages.get_general_error(),
                parse_mode="HTML"
            )
    
    @staticmethod
    async def handle_delete_execution(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Execute profile deletion"""
        query = update.callback_query
        user_id = query.from_user.id
        username = query.from_user.username or "ØºÙŠØ± Ù…Ø­Ø¯Ø¯"
        
        logger = fc26_logger.get_logger()
        logger.info(f"ğŸ—‘ï¸ User {user_id} confirmed profile deletion - executing...")
        
        try:
            await query.answer()
            
            # Check if user exists before deletion
            user_data = UserOperations.get_user_data(user_id)
            if not user_data:
                await query.edit_message_text(
                    "âŒ <b>Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯!</b>\n\nğŸš€ Ø§ÙƒØªØ¨ /start Ù„Ø¨Ø¯Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ù…Ù† Ø¬Ø¯ÙŠØ¯",
                    parse_mode="HTML"
                )
                return
            
            # Execute deletion
            deletion_success = UserOperations.delete_user(user_id)
            
            if deletion_success:
                # Success message
                success_message = f"""âœ… <b>ØªÙ… Ù…Ø³Ø­ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ Ø¨Ù†Ø¬Ø§Ø­!</b>

ğŸ—‘ï¸ <b>Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ù…Ø³ÙˆØ­Ø©:</b>
â€¢ Ø¬Ù…ÙŠØ¹ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªØ³Ø¬ÙŠÙ„
â€¢ Ø³Ø¬Ù„ Ø§Ù„Ø£Ù†Ø´Ø·Ø© ÙˆØ§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª  
â€¢ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø´Ø®ØµÙŠØ© ÙˆØ§Ù„Ø¯ÙØ¹
â€¢ Ø³Ø¬Ù„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…Ø±ØªØ¨Ø· Ø¨Ø§Ù„Ø­Ø³Ø§Ø¨

<b>ğŸ® Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ Ù…Ù† Ø¬Ø¯ÙŠØ¯ ÙÙŠ FC26!</b>

ğŸš€ <b>Ù„Ù„ØªØ³Ø¬ÙŠÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰:</b>
Ø§ÙƒØªØ¨ /start ÙˆØ§Ø¨Ø¯Ø£ Ø±Ø­Ù„ØªÙƒ Ù…Ù† Ø¬Ø¯ÙŠØ¯

<b>ğŸ‘‹ Ø´ÙƒØ±Ø§Ù‹ Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…Ùƒ Ø¨ÙˆØª FC26</b>"""
                
                await query.edit_message_text(success_message, parse_mode="HTML")
                
                log_user_action(user_id, f"Profile deletion completed successfully", f"@{username}")
                logger.info(f"âœ… User {user_id} profile deleted successfully")
                
            else:
                # Failure message
                await query.edit_message_text(
                    "âŒ <b>Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø³Ø­ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ!</b>\n\nğŸ”„ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø£Ùˆ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ",
                    parse_mode="HTML"
                )
                logger.error(f"âŒ Failed to delete user {user_id} profile")
        
        except Exception as e:
            logger.error(f"âŒ Error executing profile deletion for user {user_id}: {e}")
            await query.edit_message_text(
                ErrorMessages.get_general_error(),
                parse_mode="HTML"
            )
    
    @staticmethod
    async def handle_delete_cancellation(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle profile deletion cancellation"""
        query = update.callback_query
        user_id = query.from_user.id
        username = query.from_user.username or "ØºÙŠØ± Ù…Ø­Ø¯Ø¯"
        
        logger = fc26_logger.get_logger()
        logger.info(f"ğŸš« User {user_id} cancelled profile deletion")
        
        try:
            await query.answer("ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡ - Ù„Ù… ÙŠØ­Ø¯Ø« Ø£ÙŠ ØªØºÙŠÙŠØ±")
            
            cancellation_message = """âœ… <b>ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­!</b>

ğŸ›¡ï¸ <b>Ù„Ù… ÙŠØªÙ… Ù…Ø³Ø­ Ø£ÙŠ Ø¨ÙŠØ§Ù†Ø§Øª</b>
ğŸ“Š Ù…Ù„ÙÙƒ Ø§Ù„Ø´Ø®ØµÙŠ Ø¢Ù…Ù† ÙˆÙ„Ù… ÙŠØªØ£Ø«Ø±

<b>ğŸ® ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù†:</b>
â€¢ ğŸ‘¤ Ø§ÙƒØªØ¨ /profile Ù„Ø¹Ø±Ø¶ Ù…Ù„ÙÙƒ Ø§Ù„Ø´Ø®ØµÙŠ
â€¢ ğŸ“ Ø§ÙƒØªØ¨ /help Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© ÙˆØ§Ù„Ø¯Ø¹Ù…  
â€¢ ğŸ  Ø§ÙƒØªØ¨ /start Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©

<b>ğŸ’š Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø°Ø±!</b>"""

            await query.edit_message_text(cancellation_message, parse_mode="HTML")
            
            log_user_action(user_id, f"Profile deletion cancelled", f"@{username}")
            
        except Exception as e:
            logger = fc26_logger.get_logger()
            logger.error(f"âŒ Error handling deletion cancellation for user {user_id}: {e}")
            await query.edit_message_text(
                ErrorMessages.get_general_error(),
                parse_mode="HTML"
            )
    
    @staticmethod
    def get_handlers() -> List[CallbackQueryHandler]:
        """Get all callback handlers for profile deletion"""
        return [
            CallbackQueryHandler(ProfileDeleteHandler.handle_delete_confirmation, pattern="^delete_profile_confirm$"),
            CallbackQueryHandler(ProfileDeleteHandler.handle_delete_execution, pattern="^delete_profile_execute$"),
            CallbackQueryHandler(ProfileDeleteHandler.handle_delete_cancellation, pattern="^delete_profile_cancel$")
        ]

--- FC26_sale_coins_Bot/handlers/recovery/global_router.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ›¡ï¸ GLOBAL RECOVERY ROUTER                                  â•‘
# â•‘              Ø§Ù„Ù…ÙˆØ¬Ù‡ Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠ Ù„Ù„Ø§Ø³ØªØ±Ø¯Ø§Ø¯                                   â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Ø§Ù„Ù…ÙˆØ¬Ù‡ Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠ Ù„Ù„Ø§Ø³ØªØ±Ø¯Ø§Ø¯
- ÙŠÙ„ØªÙ‚Ø· Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ØªÙŠ Ù„Ù… ØªÙØ¹Ø§Ù„Ø¬
- ÙŠØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙˆØ³Ù… Ø£ÙˆÙ„Ø§Ù‹
- ÙŠØ³Ø§Ø¹Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø¶Ø§Ø¦Ø¹ÙŠÙ†
"""

from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import MessageHandler, filters

from database.operations import UserOperations
from utils.message_tagger import MessageTagger


async def global_recovery_router(update, context):
    """
    Ø§Ù„Ù…ÙˆØ¬Ù‡ Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠ Ù„Ù„Ø§Ø³ØªØ±Ø¯Ø§Ø¯ - Ù…Ø¹ ÙØ­Øµ Ø§Ù„ÙˆØ³Ù…
    """
    user_id = update.effective_user.id

    print(f"\n{'='*80}")
    print(f"ğŸ›¡ï¸ [GLOBAL-RECOVERY] Triggered by user {user_id}")
    print(f"{'='*80}")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ”¥ STEP 1: CHECK FOR HANDLED TAG (CRITICAL!)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if MessageTagger.check_and_clear(context):
        print(f"   ğŸ·ï¸ Message already handled by ConversationHandler")
        print(f"{'='*80}\n")
        return

    print(f"   âœ… [TAG-CHECK] No tag found - checking status...")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # STEP 2: NORMAL RECOVERY LOGIC
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    text = update.message.text

    if text.startswith("/"):
        print(f"   â­ï¸ Skipping: Is a command")
        print(f"{'='*80}\n")
        return

    if context.user_data.get("_buckets"):
        print(f"   â­ï¸ Skipping: Active conversation exists")
        print(f"   ğŸ“ Buckets: {list(context.user_data['_buckets'].keys())}")
        print(f"{'='*80}\n")
        return

    print(f"   ğŸ” No active conversation - checking database...")

    user_data = UserOperations.get_user_data(user_id)

    if not user_data:
        print(f"   ğŸ†• New user detected")

        await update.message.reply_text(
            "ğŸ‘‹ <b>Ù…Ø±Ø­Ø¨Ø§Ù‹!</b>\n\n"
            "ÙŠØ¨Ø¯Ùˆ Ø£Ù†Ùƒ Ø¬Ø¯ÙŠØ¯ Ù‡Ù†Ø§.\n\n"
            "ğŸš€ Ø§ÙƒØªØ¨ <code>/start</code> Ù„Ø¨Ø¯Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„\n"
            "â“ Ø§ÙƒØªØ¨ <code>/help</code> Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©",
            parse_mode="HTML",
        )

        print(f"   âœ… New user message sent")
        print(f"{'='*80}\n")
        return

    current_step = user_data.get("registration_step", "unknown")

    if current_step == "completed":
        print(f"   âœ… Completed registration detected")

        await update.message.reply_text(
            "âœ… <b>Ø£Ù†Øª Ù…Ø³Ø¬Ù„ Ø¨Ø§Ù„ÙØ¹Ù„!</b>\n\n"
            "ğŸ“‹ <b>Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ØªØ§Ø­Ø©:</b>\n"
            "ğŸ”¹ <code>/profile</code> - Ù…Ù„ÙÙƒ Ø§Ù„Ø´Ø®ØµÙŠ\n"
            "ğŸ”¹ <code>/sell</code> - Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²\n"
            "ğŸ”¹ <code>/help</code> - Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©\n"
            "ğŸ”¹ <code>/start</code> - Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",
            parse_mode="HTML",
        )

        print(f"   âœ… Completed user message sent")
        print(f"{'='*80}\n")
        return

    else:
        print(f"   âš ï¸ Interrupted registration detected: {current_step}")

        platform = user_data.get("platform", "ØºÙŠØ± Ù…Ø­Ø¯Ø¯")
        whatsapp = user_data.get("whatsapp", "Ù„Ù… ÙŠÙØ¯Ø®Ù„ Ø¨Ø¹Ø¯")

        question_text = f"""ğŸ”„ <b>Ù„Ø§Ø­Ø¸Øª Ø£Ù† ØªØ³Ø¬ÙŠÙ„Ùƒ Ù„Ù… ÙŠÙƒØªÙ…Ù„!</b>

ğŸ“‹ <b>Ø¨ÙŠØ§Ù†Ø§ØªÙƒ:</b>
â€¢ ğŸ® Ø§Ù„Ù…Ù†ØµØ©: {platform}
â€¢ ğŸ“± Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨: {whatsapp}

<b>â“ ØªØ­Ø¨ ØªÙƒÙ…Ù„ ÙˆÙ„Ø§ ØªØ¨Ø¯Ø£ Ù…Ù† Ø¬Ø¯ÙŠØ¯ØŸ</b>"""

        keyboard = [
            [InlineKeyboardButton("âœ… Ù…ØªØ§Ø¨Ø¹Ø©", callback_data="reg_continue")],
            [InlineKeyboardButton("ğŸ”„ Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯", callback_data="reg_restart")],
        ]

        await update.message.reply_text(
            question_text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="HTML",
        )

        print(f"   âœ… Recovery question sent")
        print(f"{'='*80}\n")
        return


def get_recovery_handler():
    """Ø¥Ù†Ø´Ø§Ø¡ handler Ø§Ù„Ø§Ø³ØªØ±Ø¯Ø§Ø¯ Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠ"""
    return MessageHandler(filters.TEXT & ~filters.COMMAND, global_recovery_router)


--- FC26_sale_coins_Bot/handlers/registration/conversation.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ“ REGISTRATION CONVERSATION                                â•‘
# â•‘                  Ù…Ø­Ø§Ø¯Ø«Ø© Ø§Ù„ØªØ³Ø¬ÙŠÙ„ - ConversationHandler                  â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Ù…Ø­Ø§Ø¯Ø«Ø© Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ÙƒØ§Ù…Ù„Ø©
- Ù…Ø¹ Persistence
- Ù…Ø¹ Message Tagging
- Ù…Ø¹ Session Buckets
"""

from telegram.ext import (
    CallbackQueryHandler,
    CommandHandler,
    ConversationHandler,
    MessageHandler,
    filters,
)

from .handlers import RegistrationHandlers
from .states import REG_INTERRUPTED, REG_PAYMENT, REG_PLATFORM, REG_WHATSAPP


def get_registration_handler():
    """Ø¥Ù†Ø´Ø§Ø¡ ConversationHandler Ù„Ù„ØªØ³Ø¬ÙŠÙ„"""

    return ConversationHandler(
        entry_points=[
            CommandHandler("start", RegistrationHandlers.start_registration),
            CallbackQueryHandler(
                RegistrationHandlers.handle_interrupted_choice,
                pattern="^reg_(continue|restart)$",
            ),
        ],
        states={
            REG_PLATFORM: [
                CallbackQueryHandler(
                    RegistrationHandlers.handle_platform_callback,
                    pattern="^platform_",
                ),
                MessageHandler(
                    filters.TEXT & ~filters.COMMAND,
                    RegistrationHandlers.nudge_platform,
                ),
            ],
            REG_WHATSAPP: [
                MessageHandler(
                    filters.TEXT & ~filters.COMMAND,
                    RegistrationHandlers.handle_whatsapp,
                ),
            ],
            REG_PAYMENT: [
                CallbackQueryHandler(
                    RegistrationHandlers.handle_payment_callback,
                    pattern="^payment_",
                ),
                MessageHandler(
                    filters.TEXT & ~filters.COMMAND,
                    RegistrationHandlers.handle_payment_details,
                ),
            ],
            REG_INTERRUPTED: [
                CallbackQueryHandler(
                    RegistrationHandlers.handle_interrupted_choice,
                    pattern="^reg_(continue|restart)$",
                ),
                MessageHandler(
                    filters.TEXT & ~filters.COMMAND,
                    RegistrationHandlers.nudge_interrupted,
                ),
            ],
        },
        fallbacks=[CommandHandler("cancel", RegistrationHandlers.cancel_registration)],
        name="registration",
        persistent=True,  # ğŸ”¥ ØªÙØ¹ÙŠÙ„ Persistence
        per_user=True,
        allow_reentry=True,
        block=True,
    )


--- FC26_sale_coins_Bot/handlers/registration/handlers.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ“ REGISTRATION HANDLERS                                    â•‘
# â•‘                  Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„ØªØ³Ø¬ÙŠÙ„ - Ù…Ø¹ Ù†Ø¸Ø§Ù… Ø§Ù„ÙˆØ³Ù… ÙˆØ§Ù„Ø¹Ø²Ù„                â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø®Ø¯Ù…Ø© Ø§Ù„ØªØ³Ø¬ÙŠÙ„
- Ù…Ø¹ Ù†Ø¸Ø§Ù… ÙˆØ³Ù… Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ (MessageTagger)
- Ù…Ø¹ Ù†Ø¸Ø§Ù… Ø¹Ø²Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (Session Buckets)
"""

from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ConversationHandler

from database.operations import StatisticsOperations, UserOperations
from keyboards.payment_keyboard import PaymentKeyboard
from keyboards.platform_keyboard import PlatformKeyboard
from messages.confirmation_msgs import ConfirmationMessages
from messages.error_messages import ErrorMessages
from messages.welcome_messages import WelcomeMessages
from utils.locks import is_rate_limited
from utils.logger import log_user_action
from utils.message_tagger import MessageTagger
from utils.session_bucket import bucket, clear_bucket
from validators.payment_validator import PaymentValidator
from validators.phone_validator import PhoneValidator


class RegistrationHandlers:
    """Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ù…Ø¹ Ù†Ø¸Ø§Ù… Ø§Ù„ÙˆØ³Ù… ÙˆØ§Ù„Ø¹Ø²Ù„"""

    @staticmethod
    async def start_registration(update, context):
        """Ø§Ù„Ù…ÙˆØ¬Ù‡ Ø§Ù„Ø°ÙƒÙŠ - Smart Router"""
        MessageTagger.mark_as_handled(context)

        user_id = update.effective_user.id
        username = update.effective_user.username or "Unknown"

        print(f"\n{'='*80}")
        print(f"ğŸ§  [SMART-ROUTER] /start from user {user_id} (@{username})")
        print(f"{'='*80}")

        if is_rate_limited(user_id):
            print(f"ğŸš« [SMART-ROUTER] Rate limited")
            await update.message.reply_text(ErrorMessages.get_rate_limit_error())
            return ConversationHandler.END

        log_user_action(user_id, "Started bot", f"@{username}")

        print(f"ğŸ” [SMART-ROUTER] Checking for interrupted registration...")

        reg_bucket = bucket(context, "reg")
        has_memory_data = bool(reg_bucket.get("platform")) or bool(
            reg_bucket.get("interrupted_platform")
        )
        print(f"   ğŸ“ Memory check: {has_memory_data}")

        user_data = UserOperations.get_user_data(user_id)
        current_step = (
            user_data.get("registration_step", "unknown") if user_data else "unknown"
        )
        print(f"   ğŸ’¾ Database step: {current_step}")

        is_interrupted = False
        interrupted_data = None

        if current_step == "completed":
            print(f"âœ… [SMART-ROUTER] User completed - showing menu")
            await RegistrationHandlers._show_main_menu(update, user_data)
            return ConversationHandler.END

        elif current_step in [
            "entering_whatsapp",
            "choosing_payment",
            "entering_payment_details",
        ]:
            print(f"âš ï¸ [SMART-ROUTER] Interrupted in DATABASE at: {current_step}")
            is_interrupted = True
            interrupted_data = user_data

        elif has_memory_data:
            print(f"âš ï¸ [SMART-ROUTER] Interrupted in MEMORY")
            is_interrupted = True
            interrupted_data = reg_bucket

        if is_interrupted:
            print(f"ğŸ¤” [SMART-ROUTER] Asking user for decision...")

            reg_bucket["interrupted_platform"] = interrupted_data.get(
                "platform", "ØºÙŠØ± Ù…Ø­Ø¯Ø¯"
            )
            reg_bucket["interrupted_whatsapp"] = interrupted_data.get("whatsapp")
            reg_bucket["interrupted_payment"] = interrupted_data.get("payment_method")
            reg_bucket["interrupted_step"] = current_step

            platform = reg_bucket["interrupted_platform"]
            whatsapp = reg_bucket["interrupted_whatsapp"] or "Ù„Ù… ÙŠÙØ¯Ø®Ù„ Ø¨Ø¹Ø¯"

            question_text = f"""ğŸ¤” <b>Ù„Ø§Ø­Ø¸Øª Ø£Ù†Ùƒ Ù„Ù… ØªÙƒÙ…Ù„ ØªØ³Ø¬ÙŠÙ„Ùƒ!</b>

ğŸ“‹ <b>Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©:</b>
â€¢ ğŸ® Ø§Ù„Ù…Ù†ØµØ©: {platform}
â€¢ ğŸ“± Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨: {whatsapp}

<b>â“ Ù…Ø§Ø°Ø§ ØªØ±ÙŠØ¯ Ø£Ù† ØªÙØ¹Ù„ØŸ</b>"""

            keyboard = [
                [
                    InlineKeyboardButton(
                        "âœ… Ù…ØªØ§Ø¨Ø¹Ø© Ù…Ù† Ø­ÙŠØ« ØªÙˆÙ‚ÙØª", callback_data="reg_continue"
                    )
                ],
                [InlineKeyboardButton("ğŸ”„ Ø§Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯", callback_data="reg_restart")],
            ]

            await update.message.reply_text(
                question_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="HTML",
            )

            print(f"â¡ï¸ [SMART-ROUTER] â†’ REG_INTERRUPTED state")
            print(f"{'='*80}\n")
            from .states import REG_INTERRUPTED

            return REG_INTERRUPTED

        print(f"ğŸ†• [SMART-ROUTER] Fresh start")
        clear_bucket(context, "reg")

        keyboard = PlatformKeyboard.create_platform_selection_keyboard()
        await update.message.reply_text(
            WelcomeMessages.get_start_message(),
            reply_markup=keyboard,
            parse_mode="HTML",
        )

        print(f"â¡ï¸ [SMART-ROUTER] â†’ REG_PLATFORM state")
        print(f"{'='*80}\n")
        from .states import REG_PLATFORM

        return REG_PLATFORM

    @staticmethod
    async def handle_interrupted_choice(update, context):
        """Ù…Ø¹Ø§Ù„Ø¬ Ù‚Ø±Ø§Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…"""
        MessageTagger.mark_as_handled(context)

        query = update.callback_query
        await query.answer()

        user_id = query.from_user.id
        choice = query.data

        print(f"\n{'='*80}")
        print(f"ğŸ¯ [INTERRUPTED-CHOICE] User {user_id}: {choice}")
        print(f"{'='*80}")

        reg_bucket = bucket(context, "reg")

        if choice == "reg_restart":
            print(f"ğŸ”„ [INTERRUPTED-CHOICE] RESTART chosen")

            clear_bucket(context, "reg")

            keyboard = PlatformKeyboard.create_platform_selection_keyboard()
            await query.edit_message_text(
                "ğŸ”„ <b>Ø­Ø³Ù†Ø§Ù‹ØŒ Ù„Ù†Ø¨Ø¯Ø£ Ù…Ù† Ø¬Ø¯ÙŠØ¯!</b>\n\n"
                + WelcomeMessages.get_start_message(),
                reply_markup=keyboard,
                parse_mode="HTML",
            )

            print(f"â¡ï¸ [INTERRUPTED-CHOICE] â†’ REG_PLATFORM")
            print(f"{'='*80}\n")
            from .states import REG_PLATFORM

            return REG_PLATFORM

        elif choice == "reg_continue":
            print(f"âœ… [INTERRUPTED-CHOICE] CONTINUE chosen")

            interrupted_step = reg_bucket.get("interrupted_step")
            platform = reg_bucket.get("interrupted_platform")
            whatsapp = reg_bucket.get("interrupted_whatsapp")

            print(f"   ğŸ“ Step: {interrupted_step}")
            print(f"   ğŸ“ Data: platform={platform}, whatsapp={whatsapp}")

            if not platform:
                print(f"   âš ï¸ [EDGE-CASE] Data lost - auto restart")

                await query.edit_message_text(
                    "ğŸ˜” <b>Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø¨ÙŠØ§Ù†Ø§ØªÙƒ.</b>\n\nğŸ”„ Ù„Ù†Ø¨Ø¯Ø£ Ù…Ù† Ø¬Ø¯ÙŠØ¯...",
                    parse_mode="HTML",
                )

                clear_bucket(context, "reg")

                keyboard = PlatformKeyboard.create_platform_selection_keyboard()
                await query.message.reply_text(
                    WelcomeMessages.get_start_message(),
                    reply_markup=keyboard,
                    parse_mode="HTML",
                )

                print(f"â¡ï¸ [INTERRUPTED-CHOICE] â†’ REG_PLATFORM (data loss)")
                print(f"{'='*80}\n")
                from .states import REG_PLATFORM

                return REG_PLATFORM

            if interrupted_step == "entering_whatsapp" or not whatsapp:
                print(f"   â¡ï¸ Continuing at: WHATSAPP")

                platform_name = PlatformKeyboard.get_platform_name(platform)
                await query.edit_message_text(
                    f"âœ… <b>Ø±Ø§Ø¦Ø¹! Ù„Ù†ÙƒÙ…Ù„ Ù…Ù† Ø­ÙŠØ« ØªÙˆÙ‚ÙÙ†Ø§</b>\n\n"
                    f"ğŸ® Ø§Ù„Ù…Ù†ØµØ©: {platform_name}\n\n"
                    f"ğŸ“± Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨:\n"
                    f"ğŸ“ Ù…Ø«Ø§Ù„: 01012345678",
                    parse_mode="HTML",
                )

                print(f"â¡ï¸ [INTERRUPTED-CHOICE] â†’ REG_WHATSAPP")
                print(f"{'='*80}\n")
                from .states import REG_WHATSAPP

                return REG_WHATSAPP

            elif interrupted_step in ["choosing_payment", "entering_payment_details"]:
                print(f"   â¡ï¸ Continuing at: PAYMENT")

                keyboard = PaymentKeyboard.create_payment_selection_keyboard()
                await query.edit_message_text(
                    f"âœ… <b>Ø±Ø§Ø¦Ø¹! Ù„Ù†ÙƒÙ…Ù„ Ù…Ù† Ø­ÙŠØ« ØªÙˆÙ‚ÙÙ†Ø§</b>\n\n"
                    f"ğŸ“± Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨: {whatsapp}\n\n"
                    f"ğŸ’³ Ø§Ø®ØªØ± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹:",
                    reply_markup=keyboard,
                    parse_mode="HTML",
                )

                print(f"â¡ï¸ [INTERRUPTED-CHOICE] â†’ REG_PAYMENT")
                print(f"{'='*80}\n")
                from .states import REG_PAYMENT

                return REG_PAYMENT

            else:
                print(f"   âš ï¸ [EDGE-CASE] Unexpected step - auto restart")

                clear_bucket(context, "reg")

                keyboard = PlatformKeyboard.create_platform_selection_keyboard()
                await query.edit_message_text(
                    "ğŸ”„ <b>Ù„Ù†Ø¨Ø¯Ø£ Ù…Ù† Ø¬Ø¯ÙŠØ¯ Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</b>",
                    reply_markup=keyboard,
                    parse_mode="HTML",
                )

                print(f"â¡ï¸ [INTERRUPTED-CHOICE] â†’ REG_PLATFORM (unexpected)")
                print(f"{'='*80}\n")
                from .states import REG_PLATFORM

                return REG_PLATFORM

    @staticmethod
    async def nudge_platform(update, context):
        """Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡ - Ø­Ø§Ù„Ø© Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù†ØµØ©"""
        MessageTagger.mark_as_handled(context)

        user_id = update.effective_user.id
        text = update.message.text

        print(f"\n{'='*80}")
        print(f"ğŸ”” [NUDGE-PLATFORM] User {user_id} typed: '{text}'")
        print(f"{'='*80}")

        keyboard = PlatformKeyboard.create_platform_selection_keyboard()

        await update.message.reply_text(
            "ğŸ® <b>Ù…Ù† ÙØ¶Ù„Ùƒ Ø§Ø®ØªØ± Ù…Ù†ØµØªÙƒ Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø£Ø¯Ù†Ø§Ù‡</b>\n\n"
            "â¬‡ï¸ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø£Ø­Ø¯ Ø§Ù„Ø£Ø²Ø±Ø§Ø±:",
            reply_markup=keyboard,
            parse_mode="HTML",
        )

        print(f"   âœ… Nudge sent - staying in REG_PLATFORM")
        print(f"{'='*80}\n")

        from .states import REG_PLATFORM

        return REG_PLATFORM

    @staticmethod
    async def nudge_interrupted(update, context):
        """Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡ - Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ù‚Ø§Ø·Ø¹Ø©"""
        MessageTagger.mark_as_handled(context)

        user_id = update.effective_user.id
        text = update.message.text

        print(f"\n{'='*80}")
        print(f"ğŸ”” [NUDGE-INTERRUPTED] User {user_id} typed: '{text}'")
        print(f"{'='*80}")

        reg_bucket = bucket(context, "reg")
        platform = reg_bucket.get("interrupted_platform", "ØºÙŠØ± Ù…Ø­Ø¯Ø¯")
        whatsapp = reg_bucket.get("interrupted_whatsapp", "Ù„Ù… ÙŠÙØ¯Ø®Ù„ Ø¨Ø¹Ø¯")

        question_text = f"""ğŸ¤” <b>Ù…Ù† ÙØ¶Ù„Ùƒ Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø£Ø¯Ù†Ø§Ù‡:</b>

ğŸ“‹ <b>Ø¨ÙŠØ§Ù†Ø§ØªÙƒ Ø§Ù„Ø­Ø§Ù„ÙŠØ©:</b>
â€¢ ğŸ® Ø§Ù„Ù…Ù†ØµØ©: {platform}
â€¢ ğŸ“± Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨: {whatsapp}

<b>â“ ØªØ±ÙŠØ¯ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø£Ù… Ø§Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯ØŸ</b>
â¬‡ï¸ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø£Ø­Ø¯ Ø§Ù„Ø£Ø²Ø±Ø§Ø±:"""

        keyboard = [
            [
                InlineKeyboardButton(
                    "âœ… Ù…ØªØ§Ø¨Ø¹Ø© Ù…Ù† Ø­ÙŠØ« ØªÙˆÙ‚ÙØª", callback_data="reg_continue"
                )
            ],
            [InlineKeyboardButton("ğŸ”„ Ø§Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯", callback_data="reg_restart")],
        ]

        await update.message.reply_text(
            question_text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="HTML",
        )

        print(f"   âœ… Nudge sent - staying in REG_INTERRUPTED")
        print(f"{'='*80}\n")

        from .states import REG_INTERRUPTED

        return REG_INTERRUPTED

    @staticmethod
    async def handle_platform_callback(update, context):
        """Ù…Ø¹Ø§Ù„Ø¬ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù†ØµØ©"""
        MessageTagger.mark_as_handled(context)

        query = update.callback_query
        await query.answer()

        user_id = query.from_user.id
        platform = query.data.replace("platform_", "")

        print(f"\n{'='*80}")
        print(f"ğŸ® [PLATFORM] User {user_id}: {platform}")
        print(f"{'='*80}")

        bucket(context, "reg")["platform"] = platform

        UserOperations.save_user_step(
            user_id, "entering_whatsapp", {"platform": platform}
        )

        platform_name = PlatformKeyboard.get_platform_name(platform)
        await query.edit_message_text(
            WelcomeMessages.get_platform_selected_message(platform_name),
            parse_mode="HTML",
        )

        log_user_action(user_id, f"Selected platform: {platform}")

        print(f"â¡ï¸ [PLATFORM] â†’ REG_WHATSAPP")
        print(f"{'='*80}\n")
        from .states import REG_WHATSAPP

        return REG_WHATSAPP

    @staticmethod
    async def handle_whatsapp(update, context):
        """Ù…Ø¹Ø§Ù„Ø¬ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨"""
        MessageTagger.mark_as_handled(context)

        user_id = update.effective_user.id
        phone = update.message.text.strip()

        print(f"\n{'='*80}")
        print(f"ğŸ“± [WHATSAPP] User {user_id} entered number")
        print(f"{'='*80}")

        validation = PhoneValidator.validate_whatsapp(phone)

        if not validation["valid"]:
            print(f"   âŒ Validation failed: {validation['error']}")
            await update.message.reply_text(
                ErrorMessages.get_phone_validation_error(validation["error"]),
                parse_mode="HTML",
            )
            print(f"   â¸ï¸ Staying in REG_WHATSAPP")
            print(f"{'='*80}\n")
            from .states import REG_WHATSAPP

            return REG_WHATSAPP

        print(f"   âœ… Validation OK")

        bucket(context, "reg")["whatsapp"] = validation["cleaned"]

        platform = bucket(context, "reg").get(
            "platform"
        ) or UserOperations.get_user_data(user_id).get("platform")
        UserOperations.save_user_step(
            user_id,
            "choosing_payment",
            {"platform": platform, "whatsapp": validation["cleaned"]},
        )

        keyboard = PaymentKeyboard.create_payment_selection_keyboard()
        await update.message.reply_text(
            WelcomeMessages.get_whatsapp_confirmed_message(validation["display"]),
            reply_markup=keyboard,
            parse_mode="HTML",
        )

        log_user_action(user_id, f"WhatsApp: {validation['display']}")

        print(f"â¡ï¸ [WHATSAPP] â†’ REG_PAYMENT")
        print(f"{'='*80}\n")
        from .states import REG_PAYMENT

        return REG_PAYMENT

    @staticmethod
    async def handle_payment_callback(update, context):
        """Ù…Ø¹Ø§Ù„Ø¬ Ø§Ø®ØªÙŠØ§Ø± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹"""
        MessageTagger.mark_as_handled(context)

        query = update.callback_query
        await query.answer()

        user_id = query.from_user.id
        payment_key = query.data.replace("payment_", "")
        payment_name = PaymentKeyboard.get_payment_display_name(payment_key)

        print(f"\n{'='*80}")
        print(f"ğŸ’³ [PAYMENT-CB] User {user_id}: {payment_name}")
        print(f"{'='*80}")

        bucket(context, "reg")["payment_method"] = payment_key

        user_data = UserOperations.get_user_data(user_id)
        UserOperations.save_user_step(
            user_id,
            "entering_payment_details",
            {
                "platform": user_data["platform"],
                "whatsapp": user_data["whatsapp"],
                "payment_method": payment_key,
            },
        )

        instruction = PaymentValidator.get_payment_instructions(payment_key)
        await query.edit_message_text(
            WelcomeMessages.get_payment_method_selected_message(
                payment_name, instruction
            ),
            parse_mode="HTML",
        )

        log_user_action(user_id, f"Payment: {payment_key}")

        print(f"   â¸ï¸ Staying in REG_PAYMENT (waiting for details)")
        print(f"{'='*80}\n")
        from .states import REG_PAYMENT

        return REG_PAYMENT

    @staticmethod
    async def handle_payment_details(update, context):
        """Ù…Ø¹Ø§Ù„Ø¬ Ø¥Ø¯Ø®Ø§Ù„ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¯ÙØ¹"""
        MessageTagger.mark_as_handled(context)

        user_id = update.effective_user.id
        details = update.message.text.strip()

        print(f"\n{'='*80}")
        print(f"ğŸ’° [PAYMENT-TXT] User {user_id} entered details")
        print(f"{'='*80}")

        payment_method = bucket(context, "reg").get("payment_method")
        if not payment_method:
            print(f"   âš ï¸ [PROTECTION] No payment method selected yet!")

            keyboard = PaymentKeyboard.create_payment_selection_keyboard()
            await update.message.reply_text(
                "âš ï¸ <b>ÙŠØ¬Ø¨ Ø§Ø®ØªÙŠØ§Ø± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹ Ø£ÙˆÙ„Ø§Ù‹!</b>\n\n"
                "ğŸ’³ Ø§Ø®ØªØ± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹ Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø±:",
                reply_markup=keyboard,
                parse_mode="HTML",
            )

            print(f"   â¸ï¸ Staying in REG_PAYMENT")
            print(f"{'='*80}\n")
            from .states import REG_PAYMENT

            return REG_PAYMENT

        user_data = UserOperations.get_user_data(user_id)
        validation = PaymentValidator.validate_payment_details(
            user_data["payment_method"], details
        )

        if not validation["valid"]:
            print(f"   âŒ Validation failed: {validation['error']}")
            await update.message.reply_text(
                ErrorMessages.get_payment_validation_error(
                    user_data["payment_method"], validation["error"]
                ),
                parse_mode="HTML",
            )
            print(f"   â¸ï¸ Staying in REG_PAYMENT")
            print(f"{'='*80}\n")
            from .states import REG_PAYMENT

            return REG_PAYMENT

        print(f"   âœ… Validation OK - completing registration")

        UserOperations.save_user_step(
            user_id,
            "completed",
            {
                "platform": user_data["platform"],
                "whatsapp": user_data["whatsapp"],
                "payment_method": user_data["payment_method"],
                "payment_details": validation["cleaned"],
            },
        )

        clear_bucket(context, "reg")

        payment_name = PaymentKeyboard.get_payment_display_name(
            user_data["payment_method"]
        )

        confirmation = ConfirmationMessages.create_payment_confirmation(
            user_data["payment_method"], validation, payment_name
        )
        await update.message.reply_text(confirmation)

        user_info = {
            "id": user_id,
            "username": update.effective_user.username or "ØºÙŠØ± Ù…ØªÙˆÙØ±",
        }

        final_summary = ConfirmationMessages.create_final_summary(
            user_data, payment_name, validation, user_info
        )
        await update.message.reply_text(final_summary, parse_mode="HTML")

        StatisticsOperations.update_daily_metric("completed_registrations")
        log_user_action(user_id, "Registration completed")

        print(f"ğŸ‰ [PAYMENT-TXT] Registration completed!")
        print(f"â¡ï¸ [PAYMENT-TXT] Ending conversation")
        print(f"{'='*80}\n")
        return ConversationHandler.END

    @staticmethod
    async def cancel_registration(update, context):
        """Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„"""
        MessageTagger.mark_as_handled(context)

        user_id = update.effective_user.id

        print(f"\n{'='*80}")
        print(f"âŒ [CANCEL] User {user_id}")
        print(f"{'='*80}\n")

        clear_bucket(context, "reg")

        await update.message.reply_text(
            "âŒ ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„\n\nğŸ”¹ /start Ù„Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯"
        )
        return ConversationHandler.END

    @staticmethod
    async def _show_main_menu(update, user_data):
        """Ø¹Ø±Ø¶ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"""
        user_id = update.effective_user.id
        username = update.effective_user.username or "Unknown"
        platform = user_data.get("platform", "ØºÙŠØ± Ù…Ø­Ø¯Ø¯")
        whatsapp = user_data.get("whatsapp", "ØºÙŠØ± Ù…Ø­Ø¯Ø¯")

        main_menu_text = f"""âœ… <b>Ø£Ù‡Ù„Ø§Ù‹ ÙˆØ³Ù‡Ù„Ø§Ù‹ Ø¨Ø¹ÙˆØ¯ØªÙƒ!</b>

ğŸ‘¤ <b>Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:</b> @{username}
ğŸ® <b>Ø§Ù„Ù…Ù†ØµØ©:</b> {platform}
ğŸ“± <b>Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨:</b> <code>{whatsapp}</code>

<b>ğŸ  Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:</b>

ğŸ”¹ <code>/sell</code> - Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²
ğŸ”¹ <code>/profile</code> - Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ
ğŸ”¹ <code>/help</code> - Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© ÙˆØ§Ù„Ø¯Ø¹Ù…

<b>ğŸ¯ Ø®Ø¯Ù…Ø§ØªÙ†Ø§:</b>
â€¢ Ø´Ø±Ø§Ø¡ ÙˆØ¨ÙŠØ¹ Ø§Ù„Ø¹Ù…Ù„Ø§Øª
â€¢ ØªØ¬Ø§Ø±Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†
â€¢ Ø®Ø¯Ù…Ø§Øª Ø§Ù„ØªØ·ÙˆÙŠØ±
â€¢ Ø¯Ø¹Ù… ÙÙ†ÙŠ Ù…ØªØ®ØµØµ

ğŸ’¬ <b>Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø¯Ù…Ø§Øª ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©</b>"""

        await update.message.reply_text(main_menu_text, parse_mode="HTML")
        log_user_action(user_id, "Main menu", f"Platform: {platform}")


--- FC26_sale_coins_Bot/handlers/registration/helpers.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘           ğŸ› ï¸ REGISTRATION HELPERS - Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„ØªØ³Ø¬ÙŠÙ„                â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ø®Ø¯Ù…Ø© Ø§Ù„ØªØ³Ø¬ÙŠÙ„"""

from utils.logger import log_user_action


async def show_main_menu(update, user_data):
    """Ø¹Ø±Ø¶ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"""
    user_id = update.effective_user.id
    username = update.effective_user.username or "Unknown"
    platform = user_data.get("platform", "ØºÙŠØ± Ù…Ø­Ø¯Ø¯")
    whatsapp = user_data.get("whatsapp", "ØºÙŠØ± Ù…Ø­Ø¯Ø¯")

    main_menu_text = f"""âœ… <b>Ø£Ù‡Ù„Ø§Ù‹ ÙˆØ³Ù‡Ù„Ø§Ù‹ Ø¨Ø¹ÙˆØ¯ØªÙƒ!</b>

ğŸ‘¤ <b>Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:</b> @{username}
ğŸ® <b>Ø§Ù„Ù…Ù†ØµØ©:</b> {platform}
ğŸ“± <b>Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨:</b> <code>{whatsapp}</code>

<b>ğŸ  Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:</b>

ğŸ”¹ <code>/sell</code> - Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²
ğŸ”¹ <code>/profile</code> - Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ
ğŸ”¹ <code>/help</code> - Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© ÙˆØ§Ù„Ø¯Ø¹Ù…

<b>ğŸ¯ Ø®Ø¯Ù…Ø§ØªÙ†Ø§:</b>
â€¢ Ø´Ø±Ø§Ø¡ ÙˆØ¨ÙŠØ¹ Ø§Ù„Ø¹Ù…Ù„Ø§Øª
â€¢ ØªØ¬Ø§Ø±Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†
â€¢ Ø®Ø¯Ù…Ø§Øª Ø§Ù„ØªØ·ÙˆÙŠØ±
â€¢ Ø¯Ø¹Ù… ÙÙ†ÙŠ Ù…ØªØ®ØµØµ

ğŸ’¬ <b>Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø¯Ù…Ø§Øª ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©</b>"""

    await update.message.reply_text(main_menu_text, parse_mode="HTML")
    log_user_action(user_id, "Main menu", f"Platform: {platform}")


--- FC26_sale_coins_Bot/handlers/registration/states.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘                    ğŸ“Š REGISTRATION STATES                                â•‘
# â•‘                       Ø­Ø§Ù„Ø§Øª Ø§Ù„ØªØ³Ø¬ÙŠÙ„                                     â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""Ø­Ø§Ù„Ø§Øª Ù…Ø­Ø§Ø¯Ø«Ø© Ø§Ù„ØªØ³Ø¬ÙŠÙ„"""

REG_PLATFORM = 0
REG_WHATSAPP = 1
REG_PAYMENT = 2
REG_INTERRUPTED = 3


--- FC26_sale_coins_Bot/handlers/start_handler.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸš€ FC26 START HANDLER - Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø¨Ø¯Ø¡                        â•‘
# â•‘                        Start Command Handler                             â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from telegram import Update
from telegram.ext import ContextTypes
from utils.logger import log_user_action, log_registration_step, logger
from utils.locks import user_lock_manager, is_rate_limited
from database.operations import UserOperations
from messages.welcome_messages import WelcomeMessages
from messages.error_messages import ErrorMessages
from keyboards.platform_keyboard import PlatformKeyboard
from handlers.continue_handler import handle_continue_registration

class StartHandler:
    """Handle /start command and user registration initialization"""
    
    @staticmethod
    async def handle_start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /start command"""
        user_id = update.effective_user.id
        username = update.effective_user.username or "Unknown"
        
        # Rate limiting check
        if is_rate_limited(user_id):
            await update.message.reply_text(ErrorMessages.get_rate_limit_error(), parse_mode="HTML")
            return
        
        log_user_action(user_id, "Started bot interaction", f"Username: @{username}")
        
        try:
            async with user_lock_manager.acquire_user_lock(user_id, "start_command"):
                await StartHandler._process_start_command(update, context)
                
        except Exception as e:
            logger.error(f"âŒ Error in start handler for user {user_id}: {e}")
            await update.message.reply_text(ErrorMessages.get_general_error(), parse_mode="HTML")
    
    @staticmethod
    async def _process_start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Process start command with user checks"""
        user_id = update.effective_user.id
        
        # Check if user exists and their current step
        user_data = UserOperations.get_user_data(user_id)
        
        if user_data and user_data["registration_step"] != "start":
            # User exists and has started registration - continue from where they left
            log_registration_step(user_id, f"Continue from {user_data['registration_step']}")
            await handle_continue_registration(update, context, user_data)
            return
        
        # New user or user at start - show welcome and platform selection
        await StartHandler._show_welcome_and_platforms(update, context)
    
    @staticmethod
    async def _show_welcome_and_platforms(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Show welcome message and platform selection"""
        user_id = update.effective_user.id
        
        try:
            # Create platform selection keyboard
            keyboard = PlatformKeyboard.create_platform_selection_keyboard()
            
            # Get welcome message
            welcome_text = WelcomeMessages.get_start_message()
            
            # Send message
            message = await update.message.reply_text(
                welcome_text,
                reply_markup=keyboard,
                parse_mode="HTML"
            )
            
            # Save user step
            UserOperations.save_user_step(user_id, "choosing_platform")
            
            log_registration_step(user_id, "choosing_platform", True)
            log_user_action(user_id, "Shown platform selection", f"Message ID: {message.message_id}")
            
        except Exception as e:
            logger.error(f"âŒ Error showing welcome to user {user_id}: {e}")
            await update.message.reply_text(ErrorMessages.get_general_error(), parse_mode="HTML")
    
    @staticmethod
    async def handle_help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /help command"""
        user_id = update.effective_user.id
        
        if is_rate_limited(user_id):
            await update.message.reply_text(ErrorMessages.get_rate_limit_error(), parse_mode="HTML")
            return
        
        log_user_action(user_id, "Requested help")
        
        try:
            help_text = WelcomeMessages.get_help_message()
            await update.message.reply_text(help_text, parse_mode="HTML")
            
        except Exception as e:
            logger.error(f"âŒ Error in help handler for user {user_id}: {e}")
            await update.message.reply_text(ErrorMessages.get_general_error(), parse_mode="HTML")
    
    @staticmethod
    async def handle_about_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /about command"""
        user_id = update.effective_user.id
        
        if is_rate_limited(user_id):
            await update.message.reply_text(ErrorMessages.get_rate_limit_error(), parse_mode="HTML")
            return
        
        log_user_action(user_id, "Requested about info")
        
        try:
            about_text = WelcomeMessages.get_about_message()
            await update.message.reply_text(about_text, parse_mode="HTML")
            
        except Exception as e:
            logger.error(f"âŒ Error in about handler for user {user_id}: {e}")
            await update.message.reply_text(ErrorMessages.get_general_error(), parse_mode="HTML")

--- FC26_sale_coins_Bot/keyboards/__init__.py ---



--- FC26_sale_coins_Bot/keyboards/payment_keyboard.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ’³ FC26 PAYMENT KEYBOARDS - Ù„ÙˆØ­Ø§Øª Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø¯ÙØ¹             â•‘
# â•‘                       Payment Keyboards                                 â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from typing import List, Dict
from config import PAYMENT_METHODS

class PaymentKeyboard:
    """Payment method selection keyboards"""
    
    @staticmethod
    def create_payment_selection_keyboard() -> InlineKeyboardMarkup:
        """Create payment method selection keyboard"""
        keyboard = []
        
        for payment_key, payment_name in PAYMENT_METHODS.items():
            keyboard.append([
                InlineKeyboardButton(
                    payment_name,
                    callback_data=f"payment_{payment_key}"
                )
            ])
        
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def create_payment_confirmation_keyboard(payment_key: str) -> InlineKeyboardMarkup:
        """Create payment method confirmation keyboard"""
        keyboard = [
            [
                InlineKeyboardButton("âœ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø·Ø±ÙŠÙ‚Ø©", callback_data=f"confirm_payment_{payment_key}"),
                InlineKeyboardButton("ğŸ”„ ØªØºÙŠÙŠØ±", callback_data="change_payment")
            ],
            [
                InlineKeyboardButton("â„¹ï¸ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø·Ø±ÙŠÙ‚Ø©", callback_data=f"payment_info_{payment_key}")
            ],
            [
                InlineKeyboardButton("ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù…Ù†ØµØ§Øª", callback_data="back_to_platforms")
            ]
        ]
        
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def create_payment_help_keyboard() -> InlineKeyboardMarkup:
        """Create payment help keyboard"""
        keyboard = [
            [
                InlineKeyboardButton("ğŸ“± Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ù‡Ø§ØªÙ", callback_data="phone_help"),
                InlineKeyboardButton("ğŸ’³ Ø§Ù„ÙƒØ±ÙˆØª", callback_data="card_help")
            ],
            [
                InlineKeyboardButton("ğŸ”— Ø¥Ù†Ø³ØªØ§Ø¨Ø§ÙŠ", callback_data="instapay_help"),
                InlineKeyboardButton("ğŸ¦ Ø§Ù„Ù…Ø­Ø§ÙØ¸", callback_data="wallet_help")
            ],
            [
                InlineKeyboardButton("ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø©", callback_data="payment_selection")
            ]
        ]
        
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def create_mobile_networks_keyboard() -> InlineKeyboardMarkup:
        """Create mobile networks information keyboard"""
        keyboard = [
            [
                InlineKeyboardButton("â­•ï¸ ÙÙˆØ¯Ø§ÙÙˆÙ† (010)", callback_data="network_vodafone"),
                InlineKeyboardButton("ğŸŸ¢ Ø§ØªØµØ§Ù„Ø§Øª (011)", callback_data="network_etisalat")
            ],
            [
                InlineKeyboardButton("ğŸŠ Ø£ÙˆØ±Ø§Ù†Ø¬ (012)", callback_data="network_orange"),
                InlineKeyboardButton("ğŸŸ£ ÙˆÙŠ (015)", callback_data="network_we")
            ],
            [
                InlineKeyboardButton("ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø©", callback_data="payment_help")
            ]
        ]
        
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def create_payment_examples_keyboard(payment_key: str) -> InlineKeyboardMarkup:
        """Create keyboard with payment examples"""
        keyboard = [
            [
                InlineKeyboardButton("ğŸ“ Ø£Ù…Ø«Ù„Ø©", callback_data=f"examples_{payment_key}"),
                InlineKeyboardButton("âš ï¸ Ø£Ø®Ø·Ø§Ø¡ Ø´Ø§Ø¦Ø¹Ø©", callback_data=f"common_errors_{payment_key}")
            ],
            [
                InlineKeyboardButton("âœ… ÙÙ‡Ù…ØªØŒ Ø£Ø¯Ø®Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª", callback_data=f"understood_{payment_key}"),
            ],
            [
                InlineKeyboardButton("ğŸ”™ ØªØºÙŠÙŠØ± Ø§Ù„Ø·Ø±ÙŠÙ‚Ø©", callback_data="payment_selection")
            ]
        ]
        
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def create_validation_retry_keyboard(payment_key: str) -> InlineKeyboardMarkup:
        """Create keyboard for validation retry options"""
        keyboard = [
            [
                InlineKeyboardButton("ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©", callback_data=f"retry_{payment_key}"),
                InlineKeyboardButton("â“ Ù…Ø³Ø§Ø¹Ø¯Ø©", callback_data=f"help_{payment_key}")
            ],
            [
                InlineKeyboardButton("ğŸ”„ ØªØºÙŠÙŠØ± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹", callback_data="payment_selection")
            ],
            [
                InlineKeyboardButton("ğŸ  Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="main_menu")
            ]
        ]
        
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def create_skip_optional_keyboard(step: str) -> InlineKeyboardMarkup:
        """Create keyboard to skip optional steps"""
        keyboard = [
            [
                InlineKeyboardButton("â­ï¸ ØªØ®Ø·ÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ø®Ø·ÙˆØ©", callback_data=f"skip_{step}"),
                InlineKeyboardButton("âœ… Ù…ØªØ§Ø¨Ø¹Ø©", callback_data=f"continue_{step}")
            ]
        ]
        
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_payment_emoji(payment_key: str) -> str:
        """Get emoji for payment method"""
        emojis = {
            'vodafone_cash': 'â­•ï¸',
            'etisalat_cash': 'ğŸŸ¢',
            'orange_cash': 'ğŸŠ',
            'we_cash': 'ğŸŸ£',
            'bank_wallet': 'ğŸ¦',
            'telda': 'ğŸ’³',
            'instapay': 'ğŸ”—'
        }
        return emojis.get(payment_key, 'ğŸ’°')
    
    @staticmethod
    def get_payment_display_name(payment_key: str) -> str:
        """Get display name for payment method"""
        return PAYMENT_METHODS.get(payment_key, "Ø·Ø±ÙŠÙ‚Ø© ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙØ©")
    
    @staticmethod
    def create_final_confirmation_keyboard() -> InlineKeyboardMarkup:
        """Create final confirmation keyboard after all data is entered"""
        keyboard = [
            [
                InlineKeyboardButton("âœ… ØªØ£ÙƒÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª", callback_data="final_confirm"),
                InlineKeyboardButton("âœï¸ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª", callback_data="edit_data")
            ],
            [
                InlineKeyboardButton("ğŸ”„ Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯", callback_data="restart_registration")
            ]
        ]
        
        return InlineKeyboardMarkup(keyboard)

--- FC26_sale_coins_Bot/keyboards/platform_keyboard.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ® FC26 PLATFORM KEYBOARDS - Ù„ÙˆØ­Ø§Øª Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ù…Ù†ØµØ§Øª          â•‘
# â•‘                       Platform Keyboards                                â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from typing import List, Dict
from config import GAMING_PLATFORMS

class PlatformKeyboard:
    """Gaming platform selection keyboards"""
    
    @staticmethod
    def create_platform_selection_keyboard() -> InlineKeyboardMarkup:
        """Create platform selection keyboard"""
        keyboard = []
        
        for platform_key, platform_info in GAMING_PLATFORMS.items():
            keyboard.append([
                InlineKeyboardButton(
                    platform_info["name"],
                    callback_data=f"platform_{platform_key}"
                )
            ])
        
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def create_platform_confirmation_keyboard(platform_key: str) -> InlineKeyboardMarkup:
        """Create platform confirmation keyboard"""
        keyboard = [
            [
                InlineKeyboardButton("âœ… ØªØ£ÙƒÙŠØ¯", callback_data=f"confirm_platform_{platform_key}"),
                InlineKeyboardButton("ğŸ”„ ØªØºÙŠÙŠØ±", callback_data="change_platform")
            ],
            [
                InlineKeyboardButton("ğŸ  Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="main_menu")
            ]
        ]
        
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def create_platform_info_keyboard(platform_key: str) -> InlineKeyboardMarkup:
        """Create keyboard with platform information options"""
        keyboard = [
            [
                InlineKeyboardButton("â„¹ï¸ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ù†ØµØ©", callback_data=f"platform_info_{platform_key}")
            ],
            [
                InlineKeyboardButton("âœ… Ø§Ø®ØªÙŠØ§Ø± Ù‡Ø°Ù‡ Ø§Ù„Ù…Ù†ØµØ©", callback_data=f"platform_{platform_key}"),
                InlineKeyboardButton("ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø©", callback_data="platform_selection")
            ]
        ]
        
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def create_navigation_keyboard() -> InlineKeyboardMarkup:
        """Create navigation keyboard for platform selection"""
        keyboard = [
            [
                InlineKeyboardButton("ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ­Ø¯ÙŠØ¯", callback_data="platform_selection")
            ],
            [
                InlineKeyboardButton("â“ Ù…Ø³Ø§Ø¹Ø¯Ø©", callback_data="platform_help"),
                InlineKeyboardButton("ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="main_menu")
            ]
        ]
        
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_platform_emoji(platform_key: str) -> str:
        """Get emoji for platform"""
        return GAMING_PLATFORMS.get(platform_key, {}).get("emoji", "ğŸ®")
    
    @staticmethod
    def get_platform_name(platform_key: str) -> str:
        """Get display name for platform"""
        return GAMING_PLATFORMS.get(platform_key, {}).get("name", "Ù…Ù†ØµØ© ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙØ©")

--- FC26_sale_coins_Bot/main.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ® FC26 GAMING BOT - MAIN                                   â•‘
# â•‘              Ø¨ÙˆØª FC26 - Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ (Ù…Ù†Ø³Ù‚ ÙÙ‚Ø·) ğŸ”¥                    â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import asyncio
import platform as sys_platform

from core.bot_app import FC26BotApp
from database.models import DatabaseModels
from handlers.commands.basic_commands import get_command_handlers
from handlers.recovery.global_router import get_recovery_handler
from handlers.registration.conversation import get_registration_handler
from services.admin.admin_conversation_handler import AdminConversation
from services.sell_coins.sell_conversation_handler import SellCoinsConversation
from utils.backup_job import register_backup_job
from utils.logger import fc26_logger
from utils.session_monitor import register_monitoring


def setup_handlers(app):
    """
    ğŸ¯ ØªØ³Ø¬ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù€ handlers
    """

    print("\n" + "=" * 80)
    print("ğŸ¯ [SYSTEM] REGISTERING HANDLERS")
    print("=" * 80)

    # 1ï¸âƒ£ REGISTRATION
    print("\nğŸ§  [REGISTRATION] Registering...")
    app.add_handler(get_registration_handler())
    print("   âœ… Done")

    # 2ï¸âƒ£ SELL SERVICE
    print("\nğŸ”§ [SELL] Registering...")
    try:
        app.add_handler(SellCoinsConversation.get_conversation_handler())
        print("   âœ… Done")
    except Exception as e:
        print(f"   âŒ Failed: {e}")

    # 3ï¸âƒ£ ADMIN SERVICE
    print("\nğŸ”§ [ADMIN] Registering...")
    try:
        app.add_handler(AdminConversation.get_conversation_handler())
        print("   âœ… Done")
    except Exception as e:
        print(f"   âŒ Failed: {e}")

    # 4ï¸âƒ£ SIMPLE COMMANDS
    print("\nğŸ”§ [COMMANDS] Registering...")
    for handler in get_command_handlers():
        app.add_handler(handler)
    print("   âœ… Done")

    # 5ï¸âƒ£ GLOBAL RECOVERY
    print("\nğŸ›¡ï¸ [RECOVERY] Registering...")
    app.add_handler(get_recovery_handler(), group=99)
    print("   âœ… Done")

    print("\n" + "=" * 80)
    print("âœ… [SYSTEM] ALL HANDLERS REGISTERED")
    print("=" * 80 + "\n")


def main():
    """ğŸš€ Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"""

    # Windows compatibility
    if sys_platform.system() == "Windows":
        try:
            asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())
        except:
            pass

    # ØªÙ‡ÙŠØ¦Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    fc26_logger.get_logger().info("ğŸ’¾ Initializing database...")
    if not DatabaseModels.create_all_tables():
        print("âŒ Database initialization failed!")
        return

    # Ø¥Ù†Ø´Ø§Ø¡ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¨ÙˆØª (Ù…Ø¹ Persistence)
    bot_app = FC26BotApp()
    app = bot_app.create_application()

    # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù€ handlers
    setup_handlers(app)

    # ğŸ”¥ ØªØ³Ø¬ÙŠÙ„ ÙˆØ¸Ø§Ø¦Ù Ø§Ù„ØµÙŠØ§Ù†Ø© (Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ ÙˆØ§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©)
    register_backup_job(app)
    register_monitoring(app)

    # Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ø¨Ø§Ù†Ø±
    fc26_logger.log_bot_start()
    print(
        """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘       ğŸ® FC26 GAMING BOT - COMPLETE SYSTEM ğŸ®                            â•‘
â•‘         Ø¨ÙˆØª FC26 - Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„ÙƒØ§Ù…Ù„ Ù…Ø¹ Persistence ğŸ”¥                      â•‘
â•‘                                                                          â•‘
â•‘  ğŸ”¥ FEATURES:                                                           â•‘
â•‘  âœ… Modular architecture - Ù‡ÙŠÙƒÙ„ Ù…Ø¹ÙŠØ§Ø±ÙŠ                                 â•‘
â•‘  âœ… Session persistence - Ø¬Ù„Ø³Ø§Øª Ø¯Ø§Ø¦Ù…Ø©                                  â•‘
â•‘  âœ… Session buckets - Ø¹Ø²Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª                                    â•‘
â•‘  âœ… Auto backup - Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠ ØªÙ„Ù‚Ø§Ø¦ÙŠ                                   â•‘
â•‘  âœ… Health monitoring - Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„ØµØ­Ø©                                   â•‘
â•‘  âœ… Message tagging - Ù†Ø¸Ø§Ù… Ø§Ù„ÙˆØ³Ù…                                       â•‘
â•‘  âœ… Zero duplicates - Ø¨Ø¯ÙˆÙ† ØªÙƒØ±Ø§Ø±                                       â•‘
â•‘  âœ… Production ready - Ø¬Ø§Ù‡Ø² Ù„Ù„Ø¥Ù†ØªØ§Ø¬                                    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    """
    )

    # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª
    try:
        app.run_polling(drop_pending_updates=True)
    except KeyboardInterrupt:
        print("ğŸ”´ Bot stopped by user")
    except Exception as e:
        print(f"âŒ Fatal error: {e}")
        import traceback

        traceback.print_exc()
    finally:
        fc26_logger.log_bot_stop()


if __name__ == "__main__":
    main()


--- FC26_sale_coins_Bot/messages/__init__.py ---



--- FC26_sale_coins_Bot/messages/confirmation_msgs.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ‰ FC26 CONFIRMATION MESSAGES - Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ØªØ£ÙƒÙŠØ¯              â•‘
# â•‘                      Confirmation Messages                               â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from typing import Any, Dict
from config import GAMING_PLATFORMS  # Ø¥Ø¶Ø§ÙØ© Ù‡Ø°Ø§ Ø§Ù„import


class ConfirmationMessages:
    """Payment confirmation and success messages"""

    @staticmethod
    def create_payment_confirmation(
        payment_method: str, validation: Dict, payment_name: str
    ) -> str:
        """Create beautiful payment confirmation message"""

        # Mobile wallets confirmation
        if payment_method in [
            "vodafone_cash",
            "etisalat_cash",
            "orange_cash",
            "we_cash",
            "bank_wallet",
        ]:
            return f"""âœ… ØªÙ… Ø­ÙØ¸ {payment_name}!

ğŸ“± Ø§Ù„Ø±Ù‚Ù…: {validation['display']}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"""

        # Telda card confirmation (Ø¨Ø¯ÙˆÙ† ØªØ´ÙÙŠØ±)
        elif payment_method == "telda":
            return f"""âœ… ØªÙ… Ø­ÙØ¸ ÙƒØ§Ø±Øª ØªÙŠÙ„Ø¯Ø§!

ğŸ’³ Ø±Ù‚Ù… Ø§Ù„ÙƒØ§Ø±Øª: {validation['display']}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"""

        # InstaPay confirmation
        elif payment_method == "instapay":
            return f"""âœ… ØªÙ… Ø­ÙØ¸ Ø±Ø§Ø¨Ø· Ø¥Ù†Ø³ØªØ§Ø¨Ø§ÙŠ!

ğŸ”— Ø§Ù„Ø±Ø§Ø¨Ø·: {validation['display']}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"""

        # Fallback for unknown methods
        else:
            return f"""âœ… ØªÙ… Ø­ÙØ¸ {payment_name}!

ğŸ’° Ø§Ù„ØªÙØ§ØµÙŠÙ„: {validation.get('display', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"""

    @staticmethod
    def create_whatsapp_confirmation(validation: Dict) -> str:
        """Create WhatsApp confirmation message"""
        return f"""âœ… ØªÙ… Ø­ÙØ¸ Ø±Ù‚Ù… Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨!

ğŸ“± Ø§Ù„Ø±Ù‚Ù…: {validation['display']}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"""

    @staticmethod
    def create_final_summary(
        user_data: Dict, payment_name: str, validation: Dict, user_info: Dict
    ) -> str:
        """Create enhanced final registration summary"""

        # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„Ù…Ù†ØµØ© Ù…Ù† Ø§Ù„config
        platform_key = user_data.get('platform', '')
        platform_name = GAMING_PLATFORMS.get(platform_key, {}).get('name', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')

        # Format payment details based on method
        if user_data["payment_method"] == "telda":
            # For Telda, show full card number (ØºÙŠØ± Ù…Ø´ÙØ±)
            payment_details_line = f"â€¢ Ø±Ù‚Ù… Ø§Ù„ÙƒØ§Ø±Øª: {validation['display']}"

        elif user_data["payment_method"] == "instapay":
            # For InstaPay, show the clean URL
            payment_details_line = f"â€¢ Ø§Ù„Ø±Ø§Ø¨Ø·: {validation['display']}"

        else:
            # For mobile wallets, show the phone number
            payment_details_line = f"â€¢ Ø§Ù„Ø±Ù‚Ù…: {validation['display']}"

        return f"""
âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§ØªÙƒ Ø¨Ù†Ø¬Ø§Ø­!

ğŸ“Š Ù…Ù„Ø®Øµ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ø¯Ø«Ø©:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ® Ø§Ù„Ù…Ù†ØµØ©: {platform_name}
ğŸ“± ÙˆØ§ØªØ³Ø§Ø¨: {user_data['whatsapp']}
ğŸ’³ Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹: {payment_name}
ğŸ’° Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯ÙØ¹:
{payment_details_line}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ‘¤ Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: @{user_info.get('username', 'ØºÙŠØ± Ù…ØªÙˆÙØ±')}
ğŸ†” Ù…Ø¹Ø±Ù Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…: {user_info['id']}

âœ¨ ØªÙ… ØªØ­Ø¯ÙŠØ« Ù…Ù„ÙÙƒ Ø§Ù„Ø´Ø®ØµÙŠ Ø¨Ù†Ø¬Ø§Ø­!"""

    @staticmethod
    def create_registration_completed_message(
        user_data: Dict, display_format: Dict
    ) -> str:
        """Create message for already completed registration"""

        # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„Ù…Ù†ØµØ© Ù…Ù† Ø§Ù„config
        platform_key = user_data.get('platform', '')
        platform_name = GAMING_PLATFORMS.get(platform_key, {}).get('name', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')

        return f"""âœ… <b>ØªØ³Ø¬ÙŠÙ„Ùƒ Ù…ÙƒØªÙ…Ù„ Ø¨Ø§Ù„ÙØ¹Ù„!</b>

ğŸ“‹ <b>Ù…Ù„Ø®Øµ Ø¨ÙŠØ§Ù†Ø§ØªÙƒ:</b>

ğŸ® <b>Ø§Ù„Ù…Ù†ØµØ©:</b> {platform_name}
ğŸ“± <b>Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨:</b> {display_format.get('whatsapp_display', user_data.get('whatsapp', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'))}
ğŸ’³ <b>Ø§Ù„Ø¯ÙØ¹:</b> {user_data.get('payment_name', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}
ğŸ’° <b>Ø§Ù„ØªÙØ§ØµÙŠÙ„:</b> {display_format.get('payment_display', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}

ğŸš€ <b>Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø¹Ø§Ø¦Ù„Ø© FC26!</b>"""

    @staticmethod
    def create_data_updated_message() -> str:
        """Create data updated confirmation"""
        return """âœ… <b>ØªÙ… ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§ØªÙƒ Ø¨Ù†Ø¬Ø§Ø­!</b>

ğŸ”„ <b>Ù…Ø§Ø°Ø§ Ø­Ø¯Ø«:</b>
â€¢ ØªÙ… Ø­ÙØ¸ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª
â€¢ ØªÙ… ØªØ­Ø¯ÙŠØ« Ù…Ù„ÙÙƒ Ø§Ù„Ø´Ø®ØµÙŠ
â€¢ Ø£ØµØ¨Ø­Øª Ø¬Ø§Ù‡Ø²Ø§Ù‹ Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø®Ø¯Ù…Ø§Øª

ğŸ® <b>Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©:</b>
â€¢ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¬Ù…ÙŠØ¹ Ø®Ø¯Ù…Ø§Øª FC26
â€¢ ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§ Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
â€¢ Ø±Ø§Ø¬Ø¹ Ù…Ù„ÙÙƒ Ø§Ù„Ø´Ø®ØµÙŠ Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª

ğŸš€ <b>Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ FC26!</b>"""

    @staticmethod
    def create_step_completed_message(step_name: str, next_step: str = None) -> str:
        """Create step completion message"""
        base_message = f"âœ… <b>ØªÙ… Ø¥ÙƒÙ…Ø§Ù„: {step_name}</b>\n\n"

        if next_step:
            base_message += f"â¡ï¸ <b>Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„ØªØ§Ù„ÙŠØ©:</b> {next_step}\n\n"

        base_message += "ğŸ¯ <b>Ø£Ù†Øª ØªØªÙ‚Ø¯Ù… Ø¨Ø´ÙƒÙ„ Ù…Ù…ØªØ§Ø²!</b>"

        return base_message

    @staticmethod
    def create_profile_summary(user_data: Dict, formatted_data: Dict = None) -> str:
        """Create complete profile summary"""

        formatted = formatted_data or {}
        
        # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„Ù…Ù†ØµØ© Ù…Ù† Ø§Ù„config
        platform_key = user_data.get('platform', '')
        platform_name = GAMING_PLATFORMS.get(platform_key, {}).get('name', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')

        return f"""ğŸ‘¤ <b>Ù…Ù„ÙÙƒ Ø§Ù„Ø´Ø®ØµÙŠ ÙÙŠ FC26</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ğŸ“‹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©:</b>

ğŸ® <b>Ø§Ù„Ù…Ù†ØµØ©:</b> {platform_name}
ğŸ“± <b>Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨:</b> {formatted.get('whatsapp_display', user_data.get('whatsapp', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'))}
ğŸ’³ <b>Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹:</b> {user_data.get('payment_name', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}
ğŸ’° <b>Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯ÙØ¹:</b> {formatted.get('payment_display', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>â° Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªØ³Ø¬ÙŠÙ„:</b>

ğŸ“… <b>ØªØ§Ø±ÙŠØ® Ø§Ù„ØªØ³Ø¬ÙŠÙ„:</b> {user_data.get('created_at', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}
ğŸ”„ <b>Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«:</b> {user_data.get('updated_at', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}
âœ… <b>Ø­Ø§Ù„Ø© Ø§Ù„ØªØ³Ø¬ÙŠÙ„:</b> Ù…ÙƒØªÙ…Ù„

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ® <b>Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø¹Ø§Ø¦Ù„Ø© FC26!</b>"""

    @staticmethod
    def create_success_animation() -> str:
        """Create animated success message"""
        return """ğŸ‰âœ¨ğŸ‰âœ¨ğŸ‰âœ¨ğŸ‰âœ¨ğŸ‰

      ğŸ† <b>Ù†Ø¬Ø­ Ø§Ù„ØªØ³Ø¬ÙŠÙ„!</b> ğŸ†

      ğŸ® FC26 Gaming Community ğŸ®

ğŸ‰âœ¨ğŸ‰âœ¨ğŸ‰âœ¨ğŸ‰âœ¨ğŸ‰

âœ… <b>Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø§Ù„ÙØ±ÙŠÙ‚!</b>"""


--- FC26_sale_coins_Bot/messages/error_messages.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              âŒ FC26 ERROR MESSAGES - Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡                     â•‘
# â•‘                         Error Messages                                   â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from typing import Dict, Optional

class ErrorMessages:
    """Error and warning messages for the bot"""
    
    @staticmethod
    def get_general_error() -> str:
        """General error message"""
        return "âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰"
    
    @staticmethod
    def get_database_error() -> str:
        """Database error message"""
        return "âŒ Ø®Ø·Ø£ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰"
    
    @staticmethod
    def get_validation_error(details: str = None) -> str:
        """Validation error with optional details"""
        base_message = "âŒ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¯Ø®Ù„Ø© ØºÙŠØ± ØµØ­ÙŠØ­Ø©"
        if details:
            return f"{base_message}\n\nğŸ“‹ <b>Ø§Ù„ØªÙØ§ØµÙŠÙ„:</b> {details}"
        return base_message
    
    @staticmethod
    def get_invalid_platform_error() -> str:
        """Invalid platform error"""
        return "âŒ Ù…Ù†ØµØ© ØºÙŠØ± ØµØ­ÙŠØ­Ø©"
    
    @staticmethod
    def get_invalid_payment_error() -> str:
        """Invalid payment method error"""
        return "âŒ Ø·Ø±ÙŠÙ‚Ø© Ø¯ÙØ¹ ØºÙŠØ± ØµØ­ÙŠØ­Ø©"
    
    @staticmethod
    def get_start_required_error() -> str:
        """Start command required error"""
        return "ğŸš€ Ø§ÙƒØªØ¨ /start Ù„Ù„Ø¨Ø¯Ø¡!"
    
    @staticmethod
    def get_restart_required_error() -> str:
        """Restart required error"""
        return "ğŸš€ Ø§ÙƒØªØ¨ /start Ù„Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯!"
    
    @staticmethod
    def get_phone_validation_error(error_details: str = None) -> str:
        """Phone number validation error with tips"""
        base_error = error_details or "âŒ Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ ØºÙŠØ± ØµØ­ÙŠØ­"
        
        return f"""{base_error}

ğŸ’¡ <b>Ù†ØµØ§Ø¦Ø­:</b>
â€¢ ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø¨Ø¯Ø¡ Ø¨Ù€ 010, 011, 012, Ø£Ùˆ 015
â€¢ Ø£Ø¯Ø®Ù„ 11 Ø±Ù‚Ù…Ø§Ù‹ Ø¨Ø§Ù„Ø¶Ø¨Ø·
â€¢ Ù„Ø§ ØªØ¶Ø¹ ÙƒÙˆØ¯ Ø§Ù„Ø¯ÙˆÙ„Ø© (+20)

ğŸ”¹ <b>Ø£Ù…Ø«Ù„Ø© ØµØ­ÙŠØ­Ø©:</b>
â€¢ 01012345678
â€¢ 01112345678
â€¢ 01212345678
â€¢ 01512345678"""
    
    @staticmethod
    def get_payment_validation_error(payment_method: str, error_details: str = None) -> str:
        """Payment validation error with method-specific tips"""
        base_error = error_details or "âŒ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯ÙØ¹ ØºÙŠØ± ØµØ­ÙŠØ­Ø©"
        
        tips = {
            'vodafone_cash': "ğŸ’¡ <b>ÙÙˆØ¯Ø§ÙÙˆÙ† ÙƒØ§Ø´:</b> Ø±Ù‚Ù… 11 Ø®Ø§Ù†Ø© ÙŠØ¨Ø¯Ø£ Ø¨Ù€ 010",
            'etisalat_cash': "ğŸ’¡ <b>Ø§ØªØµØ§Ù„Ø§Øª ÙƒØ§Ø´:</b> Ø±Ù‚Ù… 11 Ø®Ø§Ù†Ø© ÙŠØ¨Ø¯Ø£ Ø¨Ù€ 011", 
            'orange_cash': "ğŸ’¡ <b>Ø£ÙˆØ±Ø§Ù†Ø¬ ÙƒØ§Ø´:</b> Ø±Ù‚Ù… 11 Ø®Ø§Ù†Ø© ÙŠØ¨Ø¯Ø£ Ø¨Ù€ 012",
            'we_cash': "ğŸ’¡ <b>ÙˆÙŠ ÙƒØ§Ø´:</b> Ø±Ù‚Ù… 11 Ø®Ø§Ù†Ø© ÙŠØ¨Ø¯Ø£ Ø¨Ù€ 015",
            'bank_wallet': "ğŸ’¡ <b>Ù…Ø­ÙØ¸Ø© Ø¨Ù†ÙƒÙŠØ©:</b> Ø±Ù‚Ù… 11 Ø®Ø§Ù†Ø© Ù„Ø£ÙŠ Ø´Ø¨ÙƒØ©",
            'telda': "ğŸ’¡ <b>ØªÙŠÙ„Ø¯Ø§:</b> 16 Ø±Ù‚Ù…Ø§Ù‹ Ø¨Ø¯ÙˆÙ† Ù…Ø³Ø§ÙØ§Øª Ø£Ùˆ Ø´Ø±Ø·Ø§Øª\n<b>Ù…Ø«Ø§Ù„:</b> 1234567890123456",
            'instapay': "ğŸ’¡ <b>Ø¥Ù†Ø³ØªØ§Ø¨Ø§ÙŠ:</b> Ø±Ø§Ø¨Ø· ÙƒØ§Ù…Ù„\n<b>Ù…Ø«Ø§Ù„:</b> https://instapay.com.eg/abc123"
        }
        
        tip = tips.get(payment_method, "ğŸ’¡ ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¯Ø®Ù„Ø©")
        
        return f"""{base_error}

{tip}"""
    
    @staticmethod
    def get_url_validation_error(error_details: str = None) -> str:
        """URL validation error for InstaPay"""
        base_error = error_details or "âŒ Ø±Ø§Ø¨Ø· Ø¥Ù†Ø³ØªØ§Ø¨Ø§ÙŠ ØºÙŠØ± ØµØ­ÙŠØ­"
        
        return f"""{base_error}

ğŸ’¡ <b>Ù†ØµØ§Ø¦Ø­ Ù„Ø±Ø§Ø¨Ø· Ø¥Ù†Ø³ØªØ§Ø¨Ø§ÙŠ:</b>
â€¢ ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ instapay.com.eg Ø£Ùˆ ipn.eg
â€¢ Ø§Ù†Ø³Ø® Ø§Ù„Ø±Ø§Ø¨Ø· ÙƒØ§Ù…Ù„Ø§Ù‹ Ù…Ù† Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
â€¢ ØªØ£ÙƒØ¯ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø±Ø§Ø¨Ø·

ğŸ”¹ <b>Ù…Ø«Ø§Ù„ ØµØ­ÙŠØ­:</b>
https://instapay.com.eg/abc123"""
    
    @staticmethod
    def get_rate_limit_error() -> str:
        """Rate limiting error"""
        return """â³ <b>ØªÙ… ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯ Ø§Ù„Ù…Ø³Ù…ÙˆØ­</b>

ğŸ”¹ <b>Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ø«Ù… Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰</b>
ğŸ”¹ <b>Ù‡Ø°Ø§ Ù„Ù„Ø­Ù…Ø§ÙŠØ© Ù…Ù† Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…ÙØ±Ø·</b>

â° <b>Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø®Ù„Ø§Ù„ Ø¯Ù‚ÙŠÙ‚Ø©</b>"""
    
    @staticmethod
    def get_maintenance_error() -> str:
        """Maintenance mode error"""
        return """ğŸ”§ <b>Ø§Ù„Ø¨ÙˆØª ØªØ­Øª Ø§Ù„ØµÙŠØ§Ù†Ø©</b>

â³ <b>Ù†Ø¹ØªØ°Ø± Ù„Ù„Ø¥Ø²Ø¹Ø§Ø¬ØŒ Ù†Ø­Ù† Ù†Ø¹Ù…Ù„ Ø¹Ù„Ù‰ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø®Ø¯Ù…Ø©</b>

ğŸ”„ <b>Ø³ÙŠØ¹ÙˆØ¯ Ø§Ù„Ø¨ÙˆØª Ù„Ù„Ø¹Ù…Ù„ Ù‚Ø±ÙŠØ¨Ø§Ù‹</b>
ğŸ“ <b>Ù„Ù„Ø¶Ø±ÙˆØ±Ø© Ø§Ù„Ù‚ØµÙˆÙ‰ØŒ ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ</b>"""
    
    @staticmethod
    def get_user_not_found_error() -> str:
        """User not found error"""
        return """âŒ <b>Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§ØªÙƒ</b>

ğŸš€ <b>Ø§ÙƒØªØ¨ /start Ù„Ø¨Ø¯Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ù…Ù† Ø¬Ø¯ÙŠØ¯</b>"""
    
    @staticmethod
    def get_session_expired_error() -> str:
        """Session expired error"""
        return """â° <b>Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø¬Ù„Ø³Ø©</b>

ğŸ”„ <b>Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ù…Ù† Ø¬Ø¯ÙŠØ¯</b>
ğŸš€ <b>Ø§ÙƒØªØ¨ /start Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø©</b>"""
    
    @staticmethod
    def get_security_error() -> str:
        """Security violation error"""
        return """ğŸ›¡ï¸ <b>ØªÙ… Ø§ÙƒØªØ´Ø§Ù Ù†Ø´Ø§Ø· Ù…Ø´Ø¨ÙˆÙ‡</b>

âš ï¸ <b>ØªÙ… Ø­Ø¸Ø± Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ù„Ø£Ø³Ø¨Ø§Ø¨ Ø£Ù…Ù†ÙŠØ©</b>
ğŸ“ <b>ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ø°Ø§ Ø®Ø·Ø£</b>"""
    
    @staticmethod
    def get_network_error() -> str:
        """Network/connection error"""
        return """ğŸŒ <b>Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„</b>

ğŸ”„ <b>Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰</b>
ğŸ“¡ <b>ØªØ£ÙƒØ¯ Ù…Ù† Ø¬ÙˆØ¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª</b>"""
    
    @staticmethod
    def get_file_error() -> str:
        """File operation error"""
        return """ğŸ“ <b>Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©</b>

âŒ <b>Ù„Ù… ÙŠØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­</b>
ğŸ”„ <b>Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰</b>"""
    
    @staticmethod
    def format_error_with_code(error_code: str, message: str) -> str:
        """Format error message with error code"""
        return f"""âŒ <b>Ø®Ø·Ø£ #{error_code}</b>

{message}

ğŸ” <b>ÙƒÙˆØ¯ Ø§Ù„Ø®Ø·Ø£:</b> {error_code}
ğŸ“ <b>Ø§Ø°ÙƒØ± Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ Ø¹Ù†Ø¯ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù…</b>"""
    
    @staticmethod
    def get_custom_error(title: str, message: str, suggestions: list = None) -> str:
        """Create custom error message"""
        error_msg = f"""âŒ <b>{title}</b>

{message}"""
        
        if suggestions:
            error_msg += "\n\nğŸ’¡ <b>Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª:</b>"
            for suggestion in suggestions:
                error_msg += f"\nâ€¢ {suggestion}"
        
        return error_msg

--- FC26_sale_coins_Bot/messages/summary_messages.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ“Š FC26 SUMMARY MESSAGES - Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…Ù„Ø®ØµØ§Øª                 â•‘
# â•‘                        Summary Messages                                  â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from typing import Dict, List, Any
from datetime import datetime

class SummaryMessages:
    """Summary and informational messages"""
    
    @staticmethod
    def create_user_profile_summary(user_data: Dict, formatted_data: Dict = None) -> str:
        """Create complete user profile summary"""
        
        formatted = formatted_data or {}
        
        # Process platform display
        platform = user_data.get('platform', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')
        platform_display = SummaryMessages._get_platform_display_name(platform)
        
        # Process payment display
        payment_method = user_data.get('payment_method', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')
        payment_display = SummaryMessages._get_payment_display_name(payment_method)
        
        # Process payment details display
        payment_details = user_data.get('payment_details', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')
        payment_details_display = formatted.get('payment_display', payment_details)
        
        return f"""ğŸ‘¤ <b>Ù…Ù„ÙÙƒ Ø§Ù„Ø´Ø®ØµÙŠ - FC26</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ğŸ“‹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©</b>

ğŸ® <b>Ø§Ù„Ù…Ù†ØµØ©:</b> {platform_display}
ğŸ“± <b>Ø±Ù‚Ù… Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨:</b> {formatted.get('whatsapp_display', user_data.get('whatsapp', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'))}
ğŸ’³ <b>Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹:</b> {payment_display}
ğŸ’° <b>Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯ÙØ¹:</b> {payment_details_display}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ğŸ“Š Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø¨</b>

âœ… <b>Ø­Ø§Ù„Ø© Ø§Ù„ØªØ³Ø¬ÙŠÙ„:</b> Ù…ÙƒØªÙ…Ù„
ğŸ“… <b>ØªØ§Ø±ÙŠØ® Ø§Ù„ØªØ³Ø¬ÙŠÙ„:</b> {user_data.get('created_at', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}
ğŸ”„ <b>Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«:</b> {user_data.get('updated_at', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}
ğŸ†” <b>Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:</b> {user_data.get('telegram_id', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ® <b>Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù…Ø¬ØªÙ…Ø¹ FC26!</b>"""
    
    @staticmethod
    def _get_platform_display_name(platform: str) -> str:
        """Convert platform code to display name"""
        platform_names = {
            'platform_ps': 'ğŸ® PlayStation (PS4/PS5)',
            'platform_xbox': 'ğŸ® Xbox (One/Series X|S)', 
            'platform_pc': 'ğŸ–¥ï¸ PC (Origin/Steam/Epic)',
            'PlayStation': 'ğŸ® PlayStation (PS4/PS5)',
            'Xbox': 'ğŸ® Xbox (One/Series X|S)', 
            'PC': 'ğŸ–¥ï¸ PC (Origin/Steam/Epic)'
        }
        return platform_names.get(platform, platform if platform else 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')
    
    @staticmethod
    def _get_payment_display_name(payment_method: str) -> str:
        """Convert payment method code to display name"""
        payment_names = {
            'payment_vodafone': 'ğŸ“± ÙÙˆØ¯Ø§ÙÙˆÙ† ÙƒØ§Ø´ (010)',
            'payment_etisalat': 'ğŸ“± Ø§ØªØµØ§Ù„Ø§Øª ÙƒØ§Ø´ (011)',
            'payment_orange': 'ğŸ“± Ø£ÙˆØ±Ø§Ù†Ø¬ ÙƒØ§Ø´ (012)',
            'payment_we': 'ğŸ“± ÙˆÙŠ ÙƒØ§Ø´ (015)',
            'payment_bank': 'ğŸ¦ Ù…Ø­ÙØ¸Ø© Ø¨Ù†ÙƒÙŠØ©',
            'payment_tilda': 'ğŸ’³ ÙƒØ§Ø±Øª ØªÙŠÙ„Ø¯Ø§',
            'payment_instapay': 'ğŸ’° Ø¥Ù†Ø³ØªØ§Ø¨Ø§ÙŠ',
            'ÙÙˆØ¯Ø§ÙÙˆÙ† ÙƒØ§Ø´': 'ğŸ“± ÙÙˆØ¯Ø§ÙÙˆÙ† ÙƒØ§Ø´ (010)',
            'Ø§ØªØµØ§Ù„Ø§Øª ÙƒØ§Ø´': 'ğŸ“± Ø§ØªØµØ§Ù„Ø§Øª ÙƒØ§Ø´ (011)',
            'Ø£ÙˆØ±Ø§Ù†Ø¬ ÙƒØ§Ø´': 'ğŸ“± Ø£ÙˆØ±Ø§Ù†Ø¬ ÙƒØ§Ø´ (012)',
            'ÙˆÙŠ ÙƒØ§Ø´': 'ğŸ“± ÙˆÙŠ ÙƒØ§Ø´ (015)',
            'Ù…Ø­ÙØ¸Ø© Ø¨Ù†ÙƒÙŠØ©': 'ğŸ¦ Ù…Ø­ÙØ¸Ø© Ø¨Ù†ÙƒÙŠØ©',
            'ÙƒØ§Ø±Øª ØªÙŠÙ„Ø¯Ø§': 'ğŸ’³ ÙƒØ§Ø±Øª ØªÙŠÙ„Ø¯Ø§',
            'Ø¥Ù†Ø³ØªØ§Ø¨Ø§ÙŠ': 'ğŸ’° Ø¥Ù†Ø³ØªØ§Ø¨Ø§ÙŠ'
        }
        return payment_names.get(payment_method, payment_method if payment_method else 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')
    
    @staticmethod
    def create_registration_progress_summary(step: str, completed_steps: List[str]) -> str:
        """Create registration progress summary"""
        
        all_steps = [
            ('choosing_platform', '1ï¸âƒ£ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù†ØµØ©'),
            ('entering_whatsapp', '2ï¸âƒ£ ØªØ£ÙƒÙŠØ¯ Ø±Ù‚Ù… Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨'),
            ('choosing_payment', '3ï¸âƒ£ Ø§Ø®ØªÙŠØ§Ø± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹'),
            ('entering_payment_details', '4ï¸âƒ£ Ø¥Ø¯Ø®Ø§Ù„ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¯ÙØ¹'),
            ('completed', '5ï¸âƒ£ Ø¥ØªÙ…Ø§Ù… Ø§Ù„ØªØ³Ø¬ÙŠÙ„')
        ]
        
        progress_text = "ğŸ“Š <b>ØªÙ‚Ø¯Ù… Ø§Ù„ØªØ³Ø¬ÙŠÙ„</b>\n\n"
        
        for step_key, step_name in all_steps:
            if step_key in completed_steps:
                progress_text += f"âœ… {step_name}\n"
            elif step_key == step:
                progress_text += f"ğŸ”„ {step_name} â† <b>Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¢Ù†</b>\n"
            else:
                progress_text += f"â³ {step_name}\n"
        
        # Calculate percentage
        total_steps = len(all_steps)
        completed_count = len(completed_steps)
        percentage = int((completed_count / total_steps) * 100)
        
        progress_text += f"\nğŸ“ˆ <b>Ù†Ø³Ø¨Ø© Ø§Ù„Ø¥Ù†Ø¬Ø§Ø²:</b> {percentage}%"
        
        return progress_text
    
    @staticmethod
    def create_statistics_summary(stats: Dict) -> str:
        """Create bot statistics summary"""
        return f"""ğŸ“Š <b>Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª FC26 Bot</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ğŸ‘¥ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ†</b>

ğŸ‘¤ <b>Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†:</b> {stats.get('total_users', 0):,}
âœ… <b>Ø§Ù„Ù…Ø³Ø¬Ù„ÙŠÙ† Ø¨Ø§Ù„ÙƒØ§Ù…Ù„:</b> {stats.get('completed_registrations', 0):,}
ğŸ”„ <b>Ù‚ÙŠØ¯ Ø§Ù„ØªØ³Ø¬ÙŠÙ„:</b> {stats.get('pending_registrations', 0):,}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ğŸ® Ø§Ù„Ù…Ù†ØµØ§Øª Ø§Ù„Ø£ÙƒØ«Ø± Ø´Ø¹Ø¨ÙŠØ©</b>

ğŸ¥‡ <b>Ø§Ù„Ø£ÙˆÙ„:</b> {stats.get('top_platform', 'PlayStation')}
ğŸ¥ˆ <b>Ø§Ù„Ø«Ø§Ù†ÙŠ:</b> {stats.get('second_platform', 'Xbox')}
ğŸ¥‰ <b>Ø§Ù„Ø«Ø§Ù„Ø«:</b> {stats.get('third_platform', 'PC')}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ğŸ’³ Ø·Ø±Ù‚ Ø§Ù„Ø¯ÙØ¹ Ø§Ù„Ù…ÙØ¶Ù„Ø©</b>

ğŸ¥‡ <b>Ø§Ù„Ø£ÙƒØ«Ø± Ø§Ø³ØªØ®Ø¯Ø§Ù…Ø§Ù‹:</b> {stats.get('top_payment', 'ÙÙˆØ¯Ø§ÙÙˆÙ† ÙƒØ§Ø´')}
ğŸ“ˆ <b>Ø§Ù„Ù†Ù…Ùˆ Ø§Ù„Ø³Ø±ÙŠØ¹:</b> {stats.get('trending_payment', 'Ø¥Ù†Ø³ØªØ§Ø¨Ø§ÙŠ')}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â° <b>Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«:</b> {datetime.now().strftime('%Y-%m-%d %H:%M')}"""
    
    @staticmethod
    def create_daily_report(date: str, metrics: Dict) -> str:
        """Create daily activity report"""
        return f"""ğŸ“… <b>ØªÙ‚Ø±ÙŠØ± ÙŠÙˆÙ…ÙŠ - {date}</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ğŸ“Š Ø§Ù„Ù†Ø´Ø§Ø· Ø§Ù„ÙŠÙˆÙ…ÙŠ</b>

ğŸ†• <b>ØªØ³Ø¬ÙŠÙ„Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©:</b> {metrics.get('new_registrations', 0)}
âœ… <b>ØªØ³Ø¬ÙŠÙ„Ø§Øª Ù…ÙƒØªÙ…Ù„Ø©:</b> {metrics.get('completed_today', 0)}
ğŸ“± <b>Ø±Ø³Ø§Ø¦Ù„ Ù…Ø±Ø³Ù„Ø©:</b> {metrics.get('messages_sent', 0)}
âŒ <b>Ø£Ø®Ø·Ø§Ø¡:</b> {metrics.get('errors_count', 0)}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ğŸ¯ Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ø¬Ø§Ø­</b>

ğŸ“ˆ <b>Ù…Ø¹Ø¯Ù„ Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„ØªØ³Ø¬ÙŠÙ„:</b> {metrics.get('completion_rate', 0):.1f}%
âš¡ <b>Ù…ØªÙˆØ³Ø· ÙˆÙ‚Øª Ø§Ù„ØªØ³Ø¬ÙŠÙ„:</b> {metrics.get('avg_registration_time', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ğŸ” Ø§Ù„Ø°Ø±ÙˆØ§Øª</b>

â° <b>Ø£ÙƒØ«Ø± Ø§Ù„Ø£ÙˆÙ‚Ø§Øª Ù†Ø´Ø§Ø·Ø§Ù‹:</b> {metrics.get('peak_hour', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}
ğŸ® <b>Ù…Ù†ØµØ© Ø§Ù„ÙŠÙˆÙ…:</b> {metrics.get('platform_of_day', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}"""
    
    @staticmethod
    def create_help_summary() -> str:
        """Create comprehensive help summary"""
        return """ğŸ“š <b>Ø¯Ù„ÙŠÙ„ Ø§Ø³ØªØ®Ø¯Ø§Ù… FC26 Bot</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ğŸš€ Ø§Ù„Ø¨Ø¯Ø¡</b>

/start - Ø¨Ø¯Ø¡ Ø£Ùˆ Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„ØªØ³Ø¬ÙŠÙ„
/help - Ø¹Ø±Ø¶ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
/profile - Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ğŸ® Ø§Ù„Ù…Ù†ØµØ§Øª Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ…Ø©</b>

â€¢ PlayStation (PS4/PS5)
â€¢ Xbox (One/Series X|S)  
â€¢ PC (Origin/Steam/Epic)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ğŸ’³ Ø·Ø±Ù‚ Ø§Ù„Ø¯ÙØ¹</b>

â€¢ ÙÙˆØ¯Ø§ÙÙˆÙ† ÙƒØ§Ø´ (010)
â€¢ Ø§ØªØµØ§Ù„Ø§Øª ÙƒØ§Ø´ (011)
â€¢ Ø£ÙˆØ±Ø§Ù†Ø¬ ÙƒØ§Ø´ (012)
â€¢ ÙˆÙŠ ÙƒØ§Ø´ (015)
â€¢ Ù…Ø­ÙØ¸Ø© Ø¨Ù†ÙƒÙŠØ©
â€¢ ÙƒØ§Ø±Øª ØªÙŠÙ„Ø¯Ø§
â€¢ Ø¥Ù†Ø³ØªØ§Ø¨Ø§ÙŠ

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ğŸ“± Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø£Ø±Ù‚Ø§Ù…</b>

âœ… ÙŠØ¨Ø¯Ø£ Ø¨Ù€: 010, 011, 012, 015
âœ… Ø·ÙˆÙ„: 11 Ø±Ù‚Ù…Ø§Ù‹ Ø¨Ø§Ù„Ø¶Ø¨Ø·
âŒ Ù„Ø§ ØªØ¶Ø¹: +20 Ø£Ùˆ Ù…Ø³Ø§ÙØ§Øª

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ğŸ”— Ø±ÙˆØ§Ø¨Ø· Ø¥Ù†Ø³ØªØ§Ø¨Ø§ÙŠ</b>

âœ… ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰: instapay.com.eg
âœ… Ù…Ø«Ø§Ù„: https://instapay.com.eg/abc123

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ğŸ“ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ</b>

Ø¥Ø°Ø§ ÙˆØ§Ø¬Ù‡Øª Ø£ÙŠ Ù…Ø´ÙƒÙ„Ø©ØŒ ØªÙˆØ§ØµÙ„ Ù…Ø¹ ÙØ±ÙŠÙ‚ Ø§Ù„Ø¯Ø¹Ù… ÙˆØ³ØªØ­ØµÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© ÙÙˆØ±Ø§Ù‹."""
    
    @staticmethod
    def create_feature_list() -> str:
        """Create bot features list"""
        return """â­ <b>Ù…Ù…ÙŠØ²Ø§Øª FC26 Bot</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ğŸ”¥ Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</b>

âœ¨ <b>ØªØ³Ø¬ÙŠÙ„ Ø³Ø±ÙŠØ¹ ÙˆØ³Ù‡Ù„</b> - 4 Ø®Ø·ÙˆØ§Øª Ø¨Ø³ÙŠØ·Ø©
ğŸ›¡ï¸ <b>Ø£Ù…Ø§Ù† Ø¹Ø§Ù„ÙŠ</b> - Ø­Ù…Ø§ÙŠØ© Ø´Ø§Ù…Ù„Ø© Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª
ğŸ“± <b>Ø¯Ø¹Ù… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø´Ø¨ÙƒØ§Øª</b> - ÙƒÙ„ Ø·Ø±Ù‚ Ø§Ù„Ø¯ÙØ¹ Ø§Ù„Ù…ØµØ±ÙŠØ©
ğŸ® <b>Ø¯Ø¹Ù… ÙƒÙ„ Ø§Ù„Ù…Ù†ØµØ§Øª</b> - PSØŒ XboxØŒ PC
ğŸ”„ <b>Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„ØªÙ‚Ø¯Ù…</b> - Ø¥ÙƒÙ…Ø§Ù„ Ù…Ù† Ø¢Ø®Ø± Ø®Ø·ÙˆØ©
ğŸ’¬ <b>ÙˆØ§Ø¬Ù‡Ø© Ø¹Ø±Ø¨ÙŠØ©</b> - Ø¨Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
<b>ğŸš€ Ù…Ù…ÙŠØ²Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø©</b>

ğŸ“‹ <b>Ù†Ø³Ø® Ø¨Ù†Ù‚Ø±Ø©</b> - Ù†Ø³Ø® Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø³Ù‡ÙˆÙ„Ø©
ğŸ” <b>ØªØ­Ù‚Ù‚ Ø°ÙƒÙŠ</b> - ÙØ­Øµ ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª
âš¡ <b>Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø³Ø±ÙŠØ¹Ø©</b> - Ø±Ø¯ ÙÙˆØ±ÙŠ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
ğŸ¯ <b>ØªÙˆØ¬ÙŠÙ‡ Ø°ÙƒÙŠ</b> - Ø¥Ø±Ø´Ø§Ø¯Ø§Øª ÙˆØ§Ø¶Ø­Ø© Ù„ÙƒÙ„ Ø®Ø·ÙˆØ©
ğŸ“Š <b>ØªØªØ¨Ø¹ Ù…ÙØµÙ„</b> - Ù…ØªØ§Ø¨Ø¹Ø© ÙƒØ§Ù…Ù„Ø© Ù„Ù„Ø¹Ù…Ù„ÙŠØ©

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ® <b>FC26 - Ø§Ù„Ø®ÙŠØ§Ø± Ø§Ù„Ø£ÙˆÙ„ Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø§Ù„Ù…Ø­ØªØ±ÙÙŠÙ†</b>"""

--- FC26_sale_coins_Bot/messages/welcome_messages.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ® FC26 WELCOME MESSAGES - Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ØªØ±Ø­ÙŠØ¨                   â•‘
# â•‘                      Welcome & Greeting Messages                         â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from typing import Dict

class WelcomeMessages:
    """Welcome and greeting messages for the bot"""
    
    @staticmethod
    def get_start_message() -> str:
        """Get main start/welcome message"""
        return """ğŸ® <b>Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ FC26</b>
Ù…Ù†ØµØ© Ø§Ù„Ø£Ù„Ø¹Ø§Ø¨ Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠØ©

ğŸš€ <b>Ø§Ø®ØªØ± Ù…Ù†ØµØªÙƒ Ø§Ù„Ù…ÙØ¶Ù„Ø© Ù„Ù„Ø¨Ø¯Ø¡:</b>

<b>ğŸ¯ Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªØ³Ø¬ÙŠÙ„:</b>

1ï¸âƒ£ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù†ØµØ©
2ï¸âƒ£ ØªØ£ÙƒÙŠØ¯ Ø±Ù‚Ù… Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨
3ï¸âƒ£ Ø§Ø®ØªÙŠØ§Ø± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹
4ï¸âƒ£ Ø¥Ø¯Ø®Ø§Ù„ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¯ÙØ¹
5ï¸âƒ£ Ø¥ØªÙ…Ø§Ù… Ø§Ù„ØªØ³Ø¬ÙŠÙ„

ğŸ”¥ <b>Ø§Ø¨Ø¯Ø£ Ø±Ø­Ù„ØªÙƒ Ø§Ù„Ø¢Ù†!</b>"""
    
    @staticmethod
    def get_platform_selected_message(platform_name: str) -> str:
        """Get platform selection success message"""
        return f"""âœ… <b>ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù†ØµØ© Ø¨Ù†Ø¬Ø§Ø­!</b>

ğŸ® <b>Ø§Ù„Ù…Ù†ØµØ© Ø§Ù„Ù…Ø®ØªØ§Ø±Ø©:</b> {platform_name}

<b>ğŸ“± ØªØ£ÙƒÙŠØ¯ Ø±Ù‚Ù… Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨</b>

ğŸ”¹ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ
ğŸ”¹ <b>Ù…Ø«Ø§Ù„:</b> 01012345678
ğŸ”¹ <b>ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ¨Ø¯Ø£ Ø¨Ù€:</b> 010, 011, 012, Ø£Ùˆ 015

âš ï¸ <b>ØªØ£ÙƒØ¯ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø±Ù‚Ù… Ù„Ø£Ù†Ù‡ Ø³ÙŠØªÙ… Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ Ø¹Ù„ÙŠÙ‡</b>"""
    
    @staticmethod
    def get_whatsapp_confirmed_message(phone_display: str) -> str:
        """Get WhatsApp confirmation message"""
        return f"""âœ… <b>ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø±Ù‚Ù… Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨ Ø¨Ù†Ø¬Ø§Ø­!</b>

ğŸ“± <b>Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨:</b> <code>{phone_display}</code>

<b>ğŸ’³ Ø§Ø®ØªÙŠØ§Ø± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹</b>

ğŸ”¹ <b>Ø§Ø®ØªØ± Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ùƒ:</b>

<b>ğŸ“‹ Ù‚Ø§Ø¦Ù…Ø© Ø·Ø±Ù‚ Ø§Ù„Ø¯ÙØ¹ Ø§Ù„ÙƒØ§Ù…Ù„Ø©:</b>

â­•ï¸ <b>ÙÙˆØ¯Ø§ÙÙˆÙ† ÙƒØ§Ø´</b> - Ø±Ù‚Ù… 11 Ø®Ø§Ù†Ø© ÙŠØ¨Ø¯Ø£ Ø¨Ù€ 010/011/012/015
ğŸŸ¢ <b>Ø§ØªØµØ§Ù„Ø§Øª ÙƒØ§Ø´</b> - Ø±Ù‚Ù… 11 Ø®Ø§Ù†Ø© ÙŠØ¨Ø¯Ø£ Ø¨Ù€ 010/011/012/015
ğŸŠ <b>Ø£ÙˆØ±Ø§Ù†Ø¬ ÙƒØ§Ø´</b> - Ø±Ù‚Ù… 11 Ø®Ø§Ù†Ø© ÙŠØ¨Ø¯Ø£ Ø¨Ù€ 010/011/012/015
ğŸŸ£ <b>ÙˆÙŠ ÙƒØ§Ø´</b> - Ø±Ù‚Ù… 11 Ø®Ø§Ù†Ø© ÙŠØ¨Ø¯Ø£ Ø¨Ù€ 010/011/012/015
ğŸ¦ <b>Ù…Ø­ÙØ¸Ø© Ø¨Ù†ÙƒÙŠØ©</b> - Ø±Ù‚Ù… 11 Ø®Ø§Ù†Ø© Ù„Ø£ÙŠ Ø´Ø¨ÙƒØ© Ù…ØµØ±ÙŠØ©
ğŸ’³ <b>ØªÙŠÙ„Ø¯Ø§</b> - Ø±Ù‚Ù… ÙƒØ§Ø±Øª 16 Ø±Ù‚Ù…Ø§Ù‹ Ø¨Ø§Ù„Ø¶Ø¨Ø·
ğŸ”— <b>Ø¥Ù†Ø³ØªØ§ Ø¨Ø§ÙŠ</b> - Ø±Ø§Ø¨Ø· ÙƒØ§Ù…Ù„ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ instapay.com.eg Ø£Ùˆ ipn.eg"""
    
    @staticmethod
    def get_payment_method_selected_message(payment_name: str, instruction: str) -> str:
        """Get payment method selection message"""
        return f"""âœ… <b>ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹ Ø¨Ù†Ø¬Ø§Ø­!</b>

ğŸ’³ <b>Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹:</b> {payment_name}

<b>ğŸ“ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„ØªÙØ§ØµÙŠÙ„</b>

ğŸ”¹ {instruction}

âš ï¸ <b>ØªØ£ÙƒØ¯ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù‚Ø¨Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„</b>"""
    
    @staticmethod
    def get_continue_registration_message(step: str, context: Dict = None) -> str:
        """Get continue registration message based on current step"""
        base_message = "ğŸ”„ <b>Ø§Ø³ØªÙƒÙ…Ø§Ù„ Ø§Ù„ØªØ³Ø¬ÙŠÙ„</b>\n\n"
        
        if step == "choosing_platform":
            return base_message + """ğŸ® <b>Ø§Ø®ØªØ± Ù…Ù†ØµØªÙƒ Ø§Ù„Ù…ÙØ¶Ù„Ø©:</b>

ğŸ“ <b>Ù…ÙˆØ¶Ø¹Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ:</b> Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù†ØµØ©"""
        
        elif step == "entering_whatsapp" and context:
            return base_message + f"""ğŸ® <b>Ø§Ù„Ù…Ù†ØµØ©:</b> {context.get('platform_name', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}

<b>ğŸ“± Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ:</b>

ğŸ”¹ <b>Ù…Ø«Ø§Ù„:</b> 01012345678
ğŸ”¹ <b>ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ¨Ø¯Ø£ Ø¨Ù€:</b> 010, 011, 012, Ø£Ùˆ 015

ğŸ“ <b>Ù…ÙˆØ¶Ø¹Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ:</b> ØªØ£ÙƒÙŠØ¯ Ø±Ù‚Ù… Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨"""
        
        elif step == "choosing_payment" and context:
            return base_message + f"""ğŸ“± <b>Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨:</b> <code>{context.get('whatsapp', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}</code>

<b>ğŸ’³ Ø§Ø®ØªØ± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹:</b>

ğŸ“ <b>Ù…ÙˆØ¶Ø¹Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ:</b> Ø§Ø®ØªÙŠØ§Ø± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹"""
        
        elif step == "entering_payment_details" and context:
            return base_message + f"""ğŸ’³ <b>Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹:</b> {context.get('payment_name', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}

<b>ğŸ“ Ø£Ø±Ø³Ù„ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¯ÙØ¹:</b>

ğŸ”¹ {context.get('instruction', 'Ø£Ø¯Ø®Ù„ Ø§Ù„ØªÙØ§ØµÙŠÙ„')}

ğŸ“ <b>Ù…ÙˆØ¶Ø¹Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ:</b> Ø¥Ø¯Ø®Ø§Ù„ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¯ÙØ¹"""
        
        else:
            return base_message + "ğŸ“ <b>Ù…ÙˆØ¶Ø¹Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ:</b> ØºÙŠØ± Ù…Ø­Ø¯Ø¯"
    
    @staticmethod
    def get_help_message() -> str:
        """Get help message"""
        return """ğŸ“š <b>Ù…Ø³Ø§Ø¹Ø¯Ø© FC26 Gaming Bot</b>

<b>ğŸ¤– Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ØªØ§Ø­Ø©:</b>
â€¢ /start - Ø¨Ø¯Ø¡ Ø£Ùˆ Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„ØªØ³Ø¬ÙŠÙ„
â€¢ /profile - Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ
â€¢ /sell - Ø¨ÙŠØ¹ ÙƒÙˆÙŠÙ†Ø² FIFA ğŸ’°
â€¢ /delete - Ø­Ø°Ù Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ
â€¢ /help - Ø¹Ø±Ø¶ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©

<b>ğŸ® Ø§Ù„Ù…Ù†ØµØ§Øª Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ…Ø©:</b>
â€¢ PlayStation (PS4/PS5)
â€¢ Xbox (One/Series X|S)
â€¢ PC (Origin/Steam)

<b>ğŸ’³ Ø·Ø±Ù‚ Ø§Ù„Ø¯ÙØ¹ Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ…Ø©:</b>
â€¢ ÙÙˆØ¯Ø§ÙÙˆÙ† ÙƒØ§Ø´ (010)
â€¢ Ø§ØªØµØ§Ù„Ø§Øª ÙƒØ§Ø´ (011)
â€¢ Ø£ÙˆØ±Ø§Ù†Ø¬ ÙƒØ§Ø´ (012)
â€¢ ÙˆÙŠ ÙƒØ§Ø´ (015)
â€¢ Ù…Ø­ÙØ¸Ø© Ø¨Ù†ÙƒÙŠØ© (Ø£ÙŠ Ø´Ø¨ÙƒØ©)
â€¢ ÙƒØ§Ø±Øª ØªÙŠÙ„Ø¯Ø§ (16 Ø±Ù‚Ù…)
â€¢ Ø¥Ù†Ø³ØªØ§ Ø¨Ø§ÙŠ (Ø±Ø§Ø¨Ø· ÙƒØ§Ù…Ù„)

<b>ğŸ“± Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ù‡Ø§ØªÙ:</b>
â€¢ ÙŠØ¬Ø¨ Ø£Ù† ØªØ¨Ø¯Ø£ Ø¨Ù€ 010/011/012/015
â€¢ ÙŠØ¬Ø¨ Ø£Ù† ØªØªÙƒÙˆÙ† Ù…Ù† 11 Ø±Ù‚Ù…Ø§Ù‹ Ø¨Ø§Ù„Ø¶Ø¨Ø·
â€¢ Ù„Ø§ ØªØ¶Ø¹ ÙƒÙˆØ¯ Ø§Ù„Ø¯ÙˆÙ„Ø© (+20)

<b>ğŸ”— Ø±ÙˆØ§Ø¨Ø· Ø¥Ù†Ø³ØªØ§Ø¨Ø§ÙŠ:</b>
â€¢ ÙŠØ¬Ø¨ Ø£Ù† ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ instapay.com.eg
â€¢ Ø£Ùˆ ipn.eg
â€¢ Ù…Ø«Ø§Ù„: https://instapay.com.eg/abc123

<b>ğŸ—‘ï¸ Ø­Ø°Ù Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ:</b>
â€¢ Ø§Ø³ØªØ®Ø¯Ù… /delete Ø£Ùˆ Ø§Ù„Ø²Ø± ÙÙŠ /profile
â€¢ ØªØ£ÙƒÙŠØ¯ Ù…Ø²Ø¯ÙˆØ¬ Ù…Ø·Ù„ÙˆØ¨ Ù„Ù„Ø­Ù…Ø§ÙŠØ©
â€¢ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù†Ù‡Ø§

<b>ğŸ’° Ø®Ø¯Ù…Ø© Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²:</b>
â€¢ Ø§Ø³ØªØ®Ø¯Ù… /sell Ù„Ø¨ÙŠØ¹ ÙƒÙˆÙŠÙ†Ø² FIFA
â€¢ Ø£ÙØ¶Ù„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± ÙÙŠ Ø§Ù„Ø³ÙˆÙ‚ Ø§Ù„Ù…ØµØ±ÙŠ
â€¢ Ø¯ÙØ¹ ÙÙˆØ±ÙŠ ÙˆØ¢Ù…Ù† 100%
â€¢ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù†ØµØ§Øª Ù…Ø¯Ø¹ÙˆÙ…Ø©

<b>ğŸ“ Ù„Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ:</b>
ØªÙˆØ§ØµÙ„ Ù…Ø¹ ÙØ±ÙŠÙ‚ Ø§Ù„Ø¯Ø¹Ù… Ø¥Ø°Ø§ ÙˆØ§Ø¬Ù‡Øª Ø£ÙŠ Ù…Ø´ÙƒÙ„Ø©"""
    
    @staticmethod
    def get_about_message() -> str:
        """Get about bot message"""
        return """â„¹ï¸ <b>Ø­ÙˆÙ„ FC26 Gaming Bot</b>

ğŸ® <b>Ø¹Ù† Ø§Ù„Ù…Ù†ØµØ©:</b>
FC26 Ù‡ÙŠ Ù…Ù†ØµØ© Ø§Ø­ØªØ±Ø§ÙÙŠØ© Ù„Ø£Ù„Ø¹Ø§Ø¨ FIFA Ùˆ EA Sports FCØŒ Ù†ÙˆÙØ± Ø®Ø¯Ù…Ø§Øª Ù…ØªÙ†ÙˆØ¹Ø© Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† ÙÙŠ Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.

ğŸš€ <b>Ø®Ø¯Ù…Ø§ØªÙ†Ø§:</b>
â€¢ Ø´Ø±Ø§Ø¡ ÙˆØ¨ÙŠØ¹ Ø§Ù„Ø¹Ù…Ù„Ø§Øª
â€¢ ØªØ¬Ø§Ø±Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†
â€¢ Ø®Ø¯Ù…Ø§Øª Ø§Ù„ØªØ·ÙˆÙŠØ±
â€¢ Ø¯Ø¹Ù… ÙÙ†ÙŠ Ù…ØªØ®ØµØµ

ğŸ” <b>Ø§Ù„Ø£Ù…Ø§Ù†:</b>
â€¢ Ø­Ù…Ø§ÙŠØ© ÙƒØ§Ù…Ù„Ø© Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª
â€¢ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¢Ù…Ù†Ø© ÙˆÙ…Ø¶Ù…ÙˆÙ†Ø©
â€¢ Ø¯Ø¹Ù… ÙÙ†ÙŠ Ø¹Ù„Ù‰ Ù…Ø¯Ø§Ø± Ø§Ù„Ø³Ø§Ø¹Ø©

ğŸ’ <b>Ø§Ù„Ø¬ÙˆØ¯Ø©:</b>
â€¢ ÙØ±ÙŠÙ‚ Ù…Ø­ØªØ±Ù ÙˆÙ…ØªØ®ØµØµ
â€¢ Ø£Ø³Ø¹Ø§Ø± ØªÙ†Ø§ÙØ³ÙŠØ©
â€¢ Ø®Ø¯Ù…Ø© Ø³Ø±ÙŠØ¹Ø© ÙˆÙ…ÙˆØ«ÙˆÙ‚Ø©

ğŸ“ <b>Ø§Ù„ØªÙˆØ§ØµÙ„:</b>
Ù†Ø­Ù† Ù‡Ù†Ø§ Ù„Ø®Ø¯Ù…ØªÙƒ ÙÙŠ Ø£ÙŠ ÙˆÙ‚Øª"""

--- FC26_sale_coins_Bot/services/__init__.py ---

# FC26 Services Package

--- FC26_sale_coins_Bot/services/admin/__init__.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ‘‘ FC26 ADMIN SERVICE - Ø®Ø¯Ù…Ø© Ø§Ù„Ø§Ø¯Ø§Ø±Ø©                       â•‘
# â•‘                     Admin Service Package                               â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def _import_admin_components():
    """Import admin components safely"""
    try:
        from .admin_handler import AdminHandler
        from .admin_keyboards import AdminKeyboards
        from .admin_messages import AdminMessages
        from .price_management import PriceManagement
        return AdminHandler, AdminKeyboards, AdminMessages, PriceManagement
    except ImportError:
        return None, None, None, None

# Import components
AdminHandler, AdminKeyboards, AdminMessages, PriceManagement = _import_admin_components()

__all__ = []

# Add components if available
if AdminHandler is not None:
    __all__.extend(['AdminHandler', 'AdminKeyboards', 'AdminMessages', 'PriceManagement'])

--- FC26_sale_coins_Bot/services/admin/admin_conversation_handler.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ‘‘ ADMIN - CONVERSATION HANDLER                             â•‘
# â•‘                   Ø®Ø¯Ù…Ø© Ø§Ù„Ø£Ø¯Ù…Ù† - Ù…Ø¹ bucket Ùˆ persistence                 â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Ø®Ø¯Ù…Ø© Ø§Ù„Ø£Ø¯Ù…Ù† Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… ConversationHandler
- Ù…Ø¹ Ù†Ø¸Ø§Ù… ÙˆØ³Ù… Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ (MessageTagger)
- Ù…Ø¹ Ù†Ø¸Ø§Ù… Ø¹Ø²Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (Session Buckets)
- Ù…Ø¹ Persistence
"""

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import (
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
    ConversationHandler,
    MessageHandler,
    filters,
)

from database.admin_operations import AdminOperations
from utils.message_tagger import MessageTagger
from utils.session_bucket import bucket, clear_bucket

from .price_management import PriceManagement

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# STATES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ADMIN_MAIN, ADMIN_PRICES, ADMIN_PLATFORM, ADMIN_PRICE_INPUT = range(4)


class AdminConversation:
    """Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø£Ø¯Ù…Ù† - Ù…Ø¹ bucket"""

    ADMIN_ID = 1124247595

    @staticmethod
    async def start_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ø¨Ø¯Ø¡ Ù„ÙˆØ­Ø© Ø§Ù„Ø£Ø¯Ù…Ù† - /admin"""
        MessageTagger.mark_as_handled(context)

        user_id = update.effective_user.id
        username = update.effective_user.username or "Unknown"

        print(f"\nğŸ‘‘ [ADMIN] Admin command from user {user_id} (@{username})")

        if user_id != AdminConversation.ADMIN_ID:
            print(f"âŒ [ADMIN] Unauthorized access by {user_id}")
            await update.message.reply_text("âŒ ØºÙŠØ± Ù…ØµØ±Ø­ Ù„Ùƒ Ø¨Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù‡Ø°Ù‡ Ø§Ù„Ø®Ø¯Ù…Ø©!")
            return ConversationHandler.END

        AdminOperations.log_admin_action(user_id, "ADMIN_LOGIN", "Accessed via /admin")
        print(f"âœ… [ADMIN] Admin {user_id} logged in")

        keyboard = [
            [InlineKeyboardButton("ğŸ’° Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø³Ø¹Ø§Ø±", callback_data="admin_prices")],
            [InlineKeyboardButton("ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª", callback_data="admin_stats")],
            [InlineKeyboardButton("âŒ Ø®Ø±ÙˆØ¬", callback_data="admin_exit")],
        ]

        await update.message.reply_text(
            f"ğŸ‘‘ <b>Ù„ÙˆØ­Ø© Ø§Ù„Ø£Ø¯Ù…Ù†</b>\n\n" f"Ù…Ø±Ø­Ø¨Ø§Ù‹ @{username}\n\n" f"Ø§Ø®ØªØ± Ø§Ù„Ø®Ø¯Ù…Ø©:",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="HTML",
        )

        return ADMIN_MAIN

    @staticmethod
    async def handle_main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"""
        MessageTagger.mark_as_handled(context)

        query = update.callback_query
        await query.answer()

        user_id = query.from_user.id

        if query.data == "admin_exit":
            await query.edit_message_text("ğŸ‘‹ ØªÙ… Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ù„ÙˆØ­Ø© Ø§Ù„Ø£Ø¯Ù…Ù†")
            return ConversationHandler.END

        if query.data == "admin_prices":
            print(f"ğŸ’° [ADMIN] {user_id} accessing price management")
            AdminOperations.log_admin_action(user_id, "ACCESSED_PRICE_MANAGEMENT")

            keyboard = [
                [
                    InlineKeyboardButton(
                        "ğŸ® PlayStation", callback_data="admin_platform_playstation"
                    )
                ],
                [InlineKeyboardButton("ğŸ® Xbox", callback_data="admin_platform_xbox")],
                [InlineKeyboardButton("ğŸ–¥ï¸ PC", callback_data="admin_platform_pc")],
                [InlineKeyboardButton("ğŸ”™ Ø±Ø¬ÙˆØ¹", callback_data="admin_back_main")],
            ]

            await query.edit_message_text(
                "ğŸ’° <b>Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø³Ø¹Ø§Ø±</b>\n\nğŸ® Ø§Ø®ØªØ± Ø§Ù„Ù…Ù†ØµØ©:",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="HTML",
            )

            return ADMIN_PLATFORM

        if query.data == "admin_stats":
            await query.edit_message_text(
                "ğŸ“Š <b>Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª</b>\n\nÙ‚Ø±ÙŠØ¨Ø§Ù‹...",
                parse_mode="HTML",
            )
            return ConversationHandler.END

        return ADMIN_MAIN

    @staticmethod
    async def handle_platform_selection(
        update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù†ØµØ©"""
        MessageTagger.mark_as_handled(context)

        query = update.callback_query
        await query.answer()

        if query.data == "admin_back_main":
            keyboard = [
                [
                    InlineKeyboardButton(
                        "ğŸ’° Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø³Ø¹Ø§Ø±", callback_data="admin_prices"
                    )
                ],
                [InlineKeyboardButton("ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª", callback_data="admin_stats")],
                [InlineKeyboardButton("âŒ Ø®Ø±ÙˆØ¬", callback_data="admin_exit")],
            ]

            await query.edit_message_text(
                "ğŸ‘‘ <b>Ù„ÙˆØ­Ø© Ø§Ù„Ø£Ø¯Ù…Ù†</b>\n\nØ§Ø®ØªØ± Ø§Ù„Ø®Ø¯Ù…Ø©:",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="HTML",
            )

            return ADMIN_MAIN

        user_id = query.from_user.id
        platform = query.data.replace("admin_platform_", "")

        print(f"ğŸ® [ADMIN] {user_id} selected platform: {platform}")

        normal_price = PriceManagement.get_current_price(platform, "normal")
        instant_price = PriceManagement.get_current_price(platform, "instant")

        platform_name = {
            "playstation": "ğŸ® PlayStation",
            "xbox": "ğŸ® Xbox",
            "pc": "ğŸ–¥ï¸ PC",
        }.get(platform, platform)

        keyboard = [
            [
                InlineKeyboardButton(
                    f"ğŸ“… Ø¹Ø§Ø¯ÙŠ - {normal_price:,} Ø¬.Ù…" if normal_price else "ğŸ“… Ø¹Ø§Ø¯ÙŠ",
                    callback_data=f"admin_edit_{platform}_normal",
                )
            ],
            [
                InlineKeyboardButton(
                    f"âš¡ ÙÙˆØ±ÙŠ - {instant_price:,} Ø¬.Ù…" if instant_price else "âš¡ ÙÙˆØ±ÙŠ",
                    callback_data=f"admin_edit_{platform}_instant",
                )
            ],
            [InlineKeyboardButton("ğŸ”™ Ø±Ø¬ÙˆØ¹", callback_data="admin_back_platforms")],
        ]

        await query.edit_message_text(
            f"ğŸ’° <b>Ø£Ø³Ø¹Ø§Ø± {platform_name}</b>\n\nØ§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„:",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="HTML",
        )

        return ADMIN_PLATFORM

    @staticmethod
    async def handle_transfer_type_selection(
        update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„"""
        MessageTagger.mark_as_handled(context)

        query = update.callback_query
        await query.answer()

        if query.data == "admin_back_platforms":
            keyboard = [
                [
                    InlineKeyboardButton(
                        "ğŸ® PlayStation", callback_data="admin_platform_playstation"
                    )
                ],
                [InlineKeyboardButton("ğŸ® Xbox", callback_data="admin_platform_xbox")],
                [InlineKeyboardButton("ğŸ–¥ï¸ PC", callback_data="admin_platform_pc")],
                [InlineKeyboardButton("ğŸ”™ Ø±Ø¬ÙˆØ¹", callback_data="admin_back_main")],
            ]

            await query.edit_message_text(
                "ğŸ’° <b>Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø³Ø¹Ø§Ø±</b>\n\nğŸ® Ø§Ø®ØªØ± Ø§Ù„Ù…Ù†ØµØ©:",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="HTML",
            )

            return ADMIN_PLATFORM

        user_id = query.from_user.id

        parts = query.data.split("_")
        if len(parts) >= 4:
            platform = parts[2]
            transfer_type = parts[3]

            print(f"âš¡ [ADMIN] {user_id} editing {platform} {transfer_type}")

            current_price = PriceManagement.get_current_price(platform, transfer_type)

            if current_price is None:
                await query.edit_message_text(
                    "âŒ Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ",
                    parse_mode="HTML",
                )
                return ConversationHandler.END

            # ğŸ”¥ Ø§Ø³ØªØ®Ø¯Ø§Ù… bucket Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† context.user_data
            admin_bucket = bucket(context, "admin")
            admin_bucket["platform"] = platform
            admin_bucket["type"] = transfer_type
            admin_bucket["current_price"] = current_price

            AdminOperations.log_admin_action(
                user_id,
                "STARTED_PRICE_EDIT",
                f"{platform} {transfer_type} - Current: {current_price}",
            )

            platform_name = {
                "playstation": "PlayStation",
                "xbox": "Xbox",
                "pc": "PC",
            }.get(platform, platform)

            transfer_name = "ÙÙˆØ±ÙŠ" if transfer_type == "instant" else "Ø¹Ø§Ø¯ÙŠ"

            await query.edit_message_text(
                f"ğŸ’° <b>ØªØ¹Ø¯ÙŠÙ„ Ø³Ø¹Ø± {platform_name} - {transfer_name}</b>\n\n"
                f"ğŸ’µ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ: {current_price:,} Ø¬.Ù…\n\n"
                f"ğŸ“ Ø£Ø¯Ø®Ù„ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯:\n"
                f"â€¢ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰: 1,000 Ø¬.Ù…\n"
                f"â€¢ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰: 50,000 Ø¬.Ù…\n\n"
                f"âŒ Ù„Ù„Ø¥Ù„ØºØ§Ø¡: /cancel",
                parse_mode="HTML",
            )

            return ADMIN_PRICE_INPUT

        return ADMIN_PLATFORM

    @staticmethod
    async def handle_price_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø³Ø¹Ø±"""
        MessageTagger.mark_as_handled(context)

        user_id = update.effective_user.id
        price_text = update.message.text.strip()

        print(f"ğŸ’° [ADMIN] Price input from {user_id}: {price_text}")

        if not price_text.isdigit():
            print(f"   âŒ [ADMIN] Invalid format")
            await update.message.reply_text("âŒ ØµÙŠØºØ© ØºÙŠØ± ØµØ­ÙŠØ­Ø©! Ø£Ø¯Ø®Ù„ Ø£Ø±Ù‚Ø§Ù…Ø§Ù‹ ÙÙ‚Ø·")
            return ADMIN_PRICE_INPUT

        new_price = int(price_text)

        if new_price < 1000:
            print(f"   âŒ [ADMIN] Price too low: {new_price}")
            await update.message.reply_text(
                f"âŒ Ø§Ù„Ø³Ø¹Ø± Ù‚Ù„ÙŠÙ„ Ø¬Ø¯Ø§Ù‹! Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰: 1,000 Ø¬.Ù…"
            )
            return ADMIN_PRICE_INPUT

        if new_price > 50000:
            print(f"   âŒ [ADMIN] Price too high: {new_price}")
            await update.message.reply_text(
                f"âŒ Ø§Ù„Ø³Ø¹Ø± Ø¹Ø§Ù„ÙŠ Ø¬Ø¯Ø§Ù‹! Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰: 50,000 Ø¬.Ù…"
            )
            return ADMIN_PRICE_INPUT

        # ğŸ”¥ Ø§Ø³ØªØ®Ø¯Ø§Ù… bucket
        admin_bucket = bucket(context, "admin")
        platform = admin_bucket.get("platform")
        transfer_type = admin_bucket.get("type")
        old_price = admin_bucket.get("current_price")

        print(
            f"ğŸ”„ [ADMIN] Updating {platform} {transfer_type}: {old_price} â†’ {new_price}"
        )

        success = await PriceManagement.update_price(
            platform, transfer_type, new_price, user_id
        )

        if not success:
            await update.message.reply_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ø¹Ø±")
            return ConversationHandler.END

        platform_name = {
            "playstation": "PlayStation",
            "xbox": "Xbox",
            "pc": "PC",
        }.get(platform, platform)

        transfer_name = "ÙÙˆØ±ÙŠ" if transfer_type == "instant" else "Ø¹Ø§Ø¯ÙŠ"

        await update.message.reply_text(
            f"âœ… <b>ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ø¹Ø± Ø¨Ù†Ø¬Ø§Ø­!</b>\n\n"
            f"ğŸ® Ø§Ù„Ù…Ù†ØµØ©: {platform_name}\n"
            f"âš¡ Ø§Ù„Ù†ÙˆØ¹: {transfer_name}\n"
            f"ğŸ’° Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ù‚Ø¯ÙŠÙ…: {old_price:,} Ø¬.Ù…\n"
            f"ğŸ’µ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯: {new_price:,} Ø¬.Ù…\n\n"
            f"ğŸ”¹ /admin Ù„Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…",
            parse_mode="HTML",
        )

        # ğŸ”¥ Ù…Ø³Ø­ bucket ÙÙ‚Ø·
        clear_bucket(context, "admin")
        print(f"âœ… [ADMIN] Price updated successfully")

        return ConversationHandler.END

    @staticmethod
    async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©"""
        MessageTagger.mark_as_handled(context)

        user_id = update.effective_user.id
        print(f"âŒ [ADMIN] {user_id} cancelled operation")

        await update.message.reply_text(
            "âŒ ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©\n\nğŸ”¹ /admin Ù„Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…"
        )

        # ğŸ”¥ Ù…Ø³Ø­ bucket ÙÙ‚Ø·
        clear_bucket(context, "admin")
        AdminOperations.log_admin_action(user_id, "CANCELLED_OPERATION")

        return ConversationHandler.END

    @staticmethod
    def get_conversation_handler():
        """Ø¥Ù†Ø´Ø§Ø¡ ConversationHandler Ù„Ù„Ø®Ø¯Ù…Ø©"""
        return ConversationHandler(
            entry_points=[CommandHandler("admin", AdminConversation.start_admin)],
            states={
                ADMIN_MAIN: [
                    CallbackQueryHandler(
                        AdminConversation.handle_main_menu,
                        pattern="^admin_prices$|^admin_stats$|^admin_exit$",
                    )
                ],
                ADMIN_PLATFORM: [
                    CallbackQueryHandler(
                        AdminConversation.handle_platform_selection,
                        pattern="^admin_platform_|^admin_back_main$",
                    ),
                    CallbackQueryHandler(
                        AdminConversation.handle_transfer_type_selection,
                        pattern="^admin_edit_|^admin_back_platforms$",
                    ),
                ],
                ADMIN_PRICE_INPUT: [
                    MessageHandler(
                        filters.TEXT & ~filters.COMMAND,
                        AdminConversation.handle_price_input,
                    )
                ],
            },
            fallbacks=[CommandHandler("cancel", AdminConversation.cancel)],
            name="admin_conversation",
            persistent=True,  # ğŸ”¥ ØªÙØ¹ÙŠÙ„ Persistence
            block=True,
        )


--- FC26_sale_coins_Bot/services/admin/admin_handler.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ‘‘ FC26 ADMIN HANDLER - Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø§Ø¯Ø§Ø±Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ               â•‘
# â•‘                     Main Admin Handler                                  â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import logging
import os
import sys
from typing import Dict, List, Optional

from telegram import InlineKeyboardMarkup, Update
from telegram.ext import (
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    filters,
)

# Ø¥Ø¶Ø§ÙØ© Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ù„Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))

from database.admin_operations import AdminOperations

from .admin_keyboards import AdminKeyboards
from .admin_messages import AdminMessages
from .price_management import PriceManagement

logger = logging.getLogger(__name__)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CUSTOM FILTER - SMART ADMIN DETECTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


class AdminPriceEditFilter(filters.MessageFilter):
    """
    ÙÙ„ØªØ± Ø°ÙƒÙŠ: ÙŠØ³Ù…Ø­ Ø¨Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ ÙÙ‚Ø· Ø¥Ø°Ø§:
    1. Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù‡Ùˆ Ø§Ù„Ø£Ø¯Ù…Ù†
    2. Ø§Ù„Ø£Ø¯Ù…Ù† Ø¹Ù†Ø¯Ù‡ session Ù†Ø´Ø· Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø³Ø¹Ø±

    ÙÙŠ Ø£ÙŠ Ø­Ø§Ù„Ø© ØªØ§Ù†ÙŠØ©ØŒ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¨ØªØªÙ…Ø±Ø± Ù„Ù„Ù€ handler Ø§Ù„ØªØ§Ù†ÙŠ (main handler)
    """

    def __init__(self, admin_id: int, session_storage: dict):
        """
        Args:
            admin_id: Ù…Ø¹Ø±Ù Ø§Ù„Ø£Ø¯Ù…Ù† Ø§Ù„ÙˆØ­ÙŠØ¯
            session_storage: Ù…Ø±Ø¬Ø¹ Ù„Ù€ self.user_sessions
        """
        self.admin_id = admin_id
        self.session_storage = session_storage
        super().__init__()

    def filter(self, message):
        """
        Ø¨ØªØ±Ø¬Ø¹ True ÙÙ‚Ø· Ø¥Ø°Ø§ Ø§Ù„Ø±Ø³Ø§Ù„Ø© ØªØ®Øµ Ø§Ù„Ø£Ø¯Ù…Ù† ÙˆØ¹Ù†Ø¯Ù‡ session Ù†Ø´Ø·
        """
        # Ù„Ùˆ Ù…Ø´ Ø§Ù„Ø£Ø¯Ù…Ù†ØŒ return False Ø¹Ø´Ø§Ù† Ø§Ù„Ø±Ø³Ø§Ù„Ø© ØªØ¹Ø¯ÙŠ Ù„Ù„Ù€ handler Ø§Ù„ØªØ§Ù†ÙŠ
        if message.from_user.id != self.admin_id:
            return False

        # Ù„Ùˆ Ø§Ù„Ø£Ø¯Ù…Ù† Ø¨Ø³ Ù…ÙÙŠØ´ session Ù†Ø´Ø·ØŒ Ø¨Ø±Ø¶Ù‡ return False
        if self.admin_id not in self.session_storage:
            return False

        # Ù„Ùˆ Ø§Ù„Ø£Ø¯Ù…Ù† Ø¹Ù†Ø¯Ù‡ session Ù†Ø´Ø·ØŒ return True
        return True


class AdminHandler:
    """Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø§Ø¯Ø§Ø±Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ"""

    # Ù…Ø¹Ø±Ù Ø§Ù„Ø§Ø¯Ù…Ù†
    ADMIN_ID = 1124247595

    def __init__(self):
        """ØªÙ‡ÙŠØ¦Ø© Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø§Ø¯Ø§Ø±Ø©"""
        self.user_sessions = {}  # Ø¬Ù„Ø³Ø§Øª ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±

        # ØªÙ‡ÙŠØ¦Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        AdminOperations.init_admin_db()

        # ğŸ”¥ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙÙ„ØªØ± Ø§Ù„Ø°ÙƒÙŠ
        self.smart_filter = AdminPriceEditFilter(
            admin_id=self.ADMIN_ID, session_storage=self.user_sessions
        )

        print(f"\nğŸ‘‘ [ADMIN] AdminHandler initialized for admin ID: {self.ADMIN_ID}")
        print(f"ğŸ” [ADMIN] Session storage ready for price editing workflows")
        print(f"ğŸ” [ADMIN] Smart filter created for admin text handler")

        # Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ù€ callback patterns Ù„Ù„ØªØµØ­ÙŠØ­
        self.debug_callback_patterns()

        logger.info("âœ… Admin handler initialized")

    def get_handlers(self) -> List:
        """Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø§Ø¯Ø§Ø±Ø©"""
        print(f"\nğŸ”§ [ADMIN] Registering admin handlers...")

        handlers = [
            # Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø§Ø¯Ù…Ù†
            CommandHandler("admin", self.handle_admin_command),
            CommandHandler("prices", self.handle_prices_command),
            # Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø£Ø²Ø±Ø§Ø±
            CallbackQueryHandler(self.handle_admin_main, pattern="^admin_main$"),
            CallbackQueryHandler(
                self.handle_price_management, pattern="^admin_prices$"
            ),
            CallbackQueryHandler(
                self.handle_platform_edit, pattern="^admin_edit_(playstation|xbox|pc)$"
            ),
            CallbackQueryHandler(
                self.handle_transfer_type_edit,
                pattern="^admin_edit_(playstation|xbox|pc)_(normal|instant)$",
            ),
            # Ù…Ø¹Ø§Ù„Ø¬ Ø¹Ø§Ù… Ù„Ù„Ù€ callbacks ØºÙŠØ± Ø§Ù„Ù…Ø¹Ø±ÙˆÙØ© (Ø¢Ø®Ø± ÙˆØ§Ø­Ø¯ Ø¹Ø´Ø§Ù† Ù…ÙŠØªØ¯Ø§Ø®Ù„Ø´)
            CallbackQueryHandler(self.handle_unknown_callback, pattern="^admin_.*$"),
        ]

        print(f"âœ… [ADMIN] {len(handlers)} admin handlers prepared for registration")
        print(f"ğŸ¯ [ADMIN] Handlers include: commands and callbacks")
        print(
            f"ğŸ“ [ADMIN] Note: Admin text message handler will be registered separately with group=1"
        )
        return handlers

    def get_admin_text_filter(self):
        """Ø¬Ù„Ø¨ Ø§Ù„ÙÙ„ØªØ± Ø§Ù„Ø°ÙƒÙŠ Ù„Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù†ØµÙŠØ©"""
        return self.smart_filter

    def is_admin(self, user_id: int) -> bool:
        """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø§Ø¯Ù…Ù†"""
        is_authorized = user_id == self.ADMIN_ID
        if not is_authorized:
            print(
                f"âš ï¸ [ADMIN] Unauthorized access attempt from user {user_id} (Expected: {self.ADMIN_ID})"
            )
        return is_authorized

    def debug_callback_patterns(self):
        """Ø·Ø¨Ø§Ø¹Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù€ callback patterns Ø§Ù„Ù…ØªØ§Ø­Ø© Ù„Ù„ØªØµØ­ÙŠØ­"""
        patterns = [
            "admin_main",
            "admin_prices",
            "admin_edit_playstation",
            "admin_edit_xbox",
            "admin_edit_pc",
            "admin_edit_playstation_normal",
            "admin_edit_playstation_instant",
            "admin_edit_xbox_normal",
            "admin_edit_xbox_instant",
            "admin_edit_pc_normal",
            "admin_edit_pc_instant",
        ]

        print(f"\nğŸ¯ [ADMIN] Available callback patterns:")
        for i, pattern in enumerate(patterns, 1):
            print(f"   {i:2d}. {pattern}")
        print(f"ğŸ“Š [ADMIN] Total patterns: {len(patterns)}")

        return patterns

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # COMMAND HANDLERS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async def handle_admin_command(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Ù…Ø¹Ø§Ù„Ø¬ Ø£Ù…Ø± /admin"""
        user_id = update.effective_user.id
        username = update.effective_user.username or "Unknown"

        print(f"\nğŸ”‘ [ADMIN] Admin command received from user {user_id} (@{username})")

        if not self.is_admin(user_id):
            print(f"âŒ [ADMIN] Unauthorized access attempt by user {user_id}")
            await update.message.reply_text(
                AdminMessages.get_unauthorized_message(),
                reply_markup=AdminKeyboards.get_unauthorized_keyboard(),
                parse_mode="HTML",
            )
            return

        print(f"âœ… [ADMIN] Admin {user_id} successfully logged in")

        # ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„ Ø§Ù„Ø§Ø¯Ù…Ù†
        AdminOperations.log_admin_action(
            user_id, "ADMIN_LOGIN", f"Accessed via /admin command"
        )

        # Ø¹Ø±Ø¶ Ù„ÙˆØ­Ø© Ø§Ù„Ø§Ø¯Ø§Ø±Ø©
        message = AdminMessages.get_main_admin_message(user_id)
        keyboard = AdminKeyboards.get_main_admin_keyboard()

        await update.message.reply_text(
            message, reply_markup=keyboard, parse_mode="HTML"
        )

        print(f"ğŸ“Š [ADMIN] Admin dashboard sent to user {user_id}")

    async def handle_prices_command(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Ù…Ø¹Ø§Ù„Ø¬ Ø£Ù…Ø± /prices - Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ù…Ø¨Ø§Ø´Ø±Ø©"""
        user_id = update.effective_user.id

        if not self.is_admin(user_id):
            await update.message.reply_text(
                AdminMessages.get_unauthorized_message(),
                reply_markup=AdminKeyboards.get_unauthorized_keyboard(),
                parse_mode="HTML",
            )
            return

        # Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ù…Ø¨Ø§Ø´Ø±Ø©
        await self._show_current_prices(update, user_id)

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # CALLBACK HANDLERS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async def handle_admin_main(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"""
        query = update.callback_query
        user_id = query.from_user.id
        username = query.from_user.username or "Unknown"

        print(
            f"\nğŸ  [ADMIN] Main menu callback received from user {user_id} (@{username})"
        )
        print(f"ğŸ“ [ADMIN] Callback data: {query.data}")

        await query.answer()
        print(f"âœ… [ADMIN] Callback answered for user {user_id}")

        if not self.is_admin(user_id):
            await query.edit_message_text(
                AdminMessages.get_unauthorized_message(),
                reply_markup=AdminKeyboards.get_unauthorized_keyboard(),
                parse_mode="HTML",
            )
            return

        message = AdminMessages.get_main_admin_message(user_id)
        keyboard = AdminKeyboards.get_main_admin_keyboard()

        await query.edit_message_text(message, reply_markup=keyboard, parse_mode="HTML")

    async def handle_price_management(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Ù…Ø¹Ø§Ù„Ø¬ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø³Ø¹Ø§Ø±"""
        query = update.callback_query
        user_id = query.from_user.id
        username = query.from_user.username or "Unknown"

        print(
            f"\nğŸ’° [ADMIN] Price management callback received from user {user_id} (@{username})"
        )
        print(f"ğŸ“ [ADMIN] Callback data: {query.data}")

        await query.answer()
        print(f"âœ… [ADMIN] Callback answered for user {user_id}")

        if not self.is_admin(user_id):
            await query.edit_message_text(AdminMessages.get_unauthorized_message())
            return

        AdminOperations.log_admin_action(user_id, "ACCESSED_PRICE_MANAGEMENT")

        message = AdminMessages.get_price_management_message()
        keyboard = AdminKeyboards.get_price_management_keyboard()

        await query.edit_message_text(message, reply_markup=keyboard, parse_mode="HTML")

    async def handle_view_prices(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Ù…Ø¹Ø§Ù„Ø¬ Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø­Ø§Ù„ÙŠØ©"""
        query = update.callback_query
        user_id = query.from_user.id
        username = query.from_user.username or "Unknown"

        await query.answer()

        print(f"\nğŸ“Š [ADMIN] View prices requested by {user_id} (@{username})")

        if not self.is_admin(user_id):
            print(f"âŒ [ADMIN] Unauthorized view prices request from user {user_id}")
            return

        await self._show_current_prices_callback(query, user_id)
        print(f"âœ… [ADMIN] Prices displayed to admin {user_id}")

    async def handle_platform_edit(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Ù…Ø¹Ø§Ù„Ø¬ Ø§Ø®ØªÙŠØ§Ø± Ù…Ù†ØµØ© Ù„Ù„ØªØ¹Ø¯ÙŠÙ„"""
        query = update.callback_query
        user_id = query.from_user.id
        username = query.from_user.username or "Unknown"

        print(
            f"\nğŸ® [ADMIN] Platform edit callback received from user {user_id} (@{username})"
        )
        print(f"ğŸ“ [ADMIN] Callback data: {query.data}")

        await query.answer()
        print(f"âœ… [ADMIN] Callback answered for user {user_id}")

        if not self.is_admin(user_id):
            return

        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ø³Ù… Ø§Ù„Ù…Ù†ØµØ©
        platform = query.data.split("_")[-1]  # admin_edit_playstation -> playstation
        print(f"ğŸ”§ [ADMIN] Extracted platform: {platform}")

        AdminOperations.log_admin_action(
            user_id, "SELECTED_PLATFORM_EDIT", f"Platform: {platform}"
        )
        print(f"ğŸ“ [ADMIN] Action logged for platform selection: {platform}")

        message = AdminMessages.get_platform_edit_message(platform)
        keyboard = AdminKeyboards.get_platform_edit_keyboard(platform)
        print(f"ğŸ“‹ [ADMIN] Message and keyboard prepared for platform: {platform}")

        try:
            await query.edit_message_text(
                message, reply_markup=keyboard, parse_mode="HTML"
            )
            print(
                f"âœ… [ADMIN] Platform edit interface sent successfully for {platform}"
            )
        except Exception as e:
            print(f"âŒ [ADMIN] Failed to send platform edit interface: {e}")

    async def handle_transfer_type_edit(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Ù…Ø¹Ø§Ù„Ø¬ Ø§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„"""
        query = update.callback_query
        user_id = query.from_user.id
        username = query.from_user.username or "Unknown"

        await query.answer()

        print(f"\nâš¡ [ADMIN] Transfer type edit requested by {user_id} (@{username})")

        if not self.is_admin(user_id):
            print(f"âŒ [ADMIN] Unauthorized callback from user {user_id}")
            return

        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† callback_data
        # ØªÙ†Ø³ÙŠÙ‚: admin_edit_playstation_normal
        print(f"ğŸ” [ADMIN] Parsing callback data: '{query.data}'")

        try:
            parts = query.data.split("_")
            print(f"ğŸ“‹ [ADMIN] Split parts: {parts}")

            if len(parts) < 4:
                print(
                    f"âŒ [ADMIN] Invalid callback data format: expected 4 parts, got {len(parts)}"
                )
                return

            platform = parts[2]  # playstation
            transfer_type = parts[3]  # normal

            print(
                f"ğŸ® [ADMIN] Successfully extracted - Platform: {platform}, Type: {transfer_type}"
            )

        except Exception as e:
            print(f"âŒ [ADMIN] Error parsing callback data: {e}")
            return

        # Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ
        current_price = PriceManagement.get_current_price(platform, transfer_type)

        if current_price is None:
            print(
                f"âŒ [ADMIN] Failed to get current price for {platform} {transfer_type}"
            )
            await query.edit_message_text(
                AdminMessages.get_error_message("database_error"), parse_mode="HTML"
            )
            return

        print(
            f"ğŸ’° [ADMIN] Current price for {platform} {transfer_type}: {current_price}"
        )

        # Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¬Ù„Ø³Ø©
        self.user_sessions[user_id] = {
            "step": "waiting_price",
            "platform": platform,
            "transfer_type": transfer_type,
            "current_price": current_price,
        }

        print(
            f"ğŸ“ [ADMIN] Session created for admin {user_id}: waiting for price input"
        )
        print(f"ğŸ”‘ [ADMIN] Active sessions now: {list(self.user_sessions.keys())}")

        AdminOperations.log_admin_action(
            user_id,
            "STARTED_PRICE_EDIT",
            f"Platform: {platform}, Type: {transfer_type}, Current: {current_price}",
        )

        message = AdminMessages.get_price_edit_prompt(
            platform, transfer_type, current_price
        )
        keyboard = AdminKeyboards.get_price_edit_keyboard(platform, transfer_type)

        try:
            await query.edit_message_text(
                message, reply_markup=keyboard, parse_mode="HTML"
            )
            print(f"âœ… [ADMIN] Price edit prompt sent to admin {user_id}")
        except Exception as e:
            print(f"âŒ [ADMIN] Failed to send price edit prompt: {e}")

    async def handle_admin_logs(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Ù…Ø¹Ø§Ù„Ø¬ Ø¹Ø±Ø¶ Ø³Ø¬Ù„ Ø§Ù„Ø£Ø¹Ù…Ø§Ù„"""
        query = update.callback_query
        user_id = query.from_user.id
        username = query.from_user.username or "Unknown"

        print(f"\nğŸ“Š [ADMIN] Logs callback received from user {user_id} (@{username})")
        print(f"ğŸ“ [ADMIN] Callback data: {query.data}")

        await query.answer()
        print(f"âœ… [ADMIN] Callback answered for user {user_id}")

        if not self.is_admin(user_id):
            return

        logs = AdminOperations.get_admin_logs(50)
        message = AdminMessages.get_admin_logs_message(logs)
        keyboard = AdminKeyboards.get_admin_logs_keyboard()

        await query.edit_message_text(message, reply_markup=keyboard, parse_mode="HTML")

    async def handle_admin_stats(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª"""
        query = update.callback_query
        user_id = query.from_user.id
        username = query.from_user.username or "Unknown"

        print(f"\nğŸ“ˆ [ADMIN] Stats callback received from user {user_id} (@{username})")
        print(f"ğŸ“ [ADMIN] Callback data: {query.data}")

        await query.answer()
        print(f"âœ… [ADMIN] Callback answered for user {user_id}")

        if not self.is_admin(user_id):
            return

        # Ø±Ø³Ø§Ù„Ø© Ù…Ø¤Ù‚ØªØ© - ÙŠÙ…ÙƒÙ† ØªØ·ÙˆÙŠØ±Ù‡Ø§ Ù„Ø§Ø­Ù‚Ø§Ù‹
        await query.edit_message_text(
            "ğŸ“Š <b>Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª</b>\n\nğŸš§ Ù‡Ø°Ù‡ Ø§Ù„Ù…ÙŠØ²Ø© Ù‚ÙŠØ¯ Ø§Ù„ØªØ·ÙˆÙŠØ±...\n\nØ³ØªÙƒÙˆÙ† Ù…ØªØ§Ø­Ø© Ù‚Ø±ÙŠØ¨Ø§Ù‹!",
            reply_markup=AdminKeyboards.get_main_admin_keyboard(),
            parse_mode="HTML",
        )

    async def handle_unknown_callback(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ù€ callbacks ØºÙŠØ± Ø§Ù„Ù…Ø¹Ø±ÙˆÙØ© Ù„Ù„ØªØµØ­ÙŠØ­"""
        query = update.callback_query
        user_id = query.from_user.id
        username = query.from_user.username or "Unknown"

        print(
            f"\nâ“ [ADMIN] UNKNOWN callback received from user {user_id} (@{username})"
        )
        print(f"ğŸ” [ADMIN] Callback data: '{query.data}'")
        print(f"âš ï¸ [ADMIN] This callback was not handled by any specific pattern!")

        await query.answer()

        # Ø¥Ø°Ø§ ÙƒØ§Ù† adminØŒ Ø£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø© ØªÙˆØ¶ÙŠØ­ÙŠØ©
        if self.is_admin(user_id):
            print(f"ğŸ› ï¸ [ADMIN] Sending debug message to admin about unknown callback")
            await query.edit_message_text(
                f"ğŸ› <b>Debug Info</b>\n\n"
                f"â“ Unknown callback received: <code>{query.data}</code>\n\n"
                f"This helps debug admin system issues!",
                reply_markup=AdminKeyboards.get_main_admin_keyboard(),
                parse_mode="HTML",
            )

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # MESSAGE HANDLERS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async def handle_price_input(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Ù…Ø¹Ø§Ù„Ø¬ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯"""
        user_id = update.effective_user.id
        username = update.effective_user.username or "Unknown"

        print(f"\nğŸ’° [ADMIN] ========== PRICE INPUT HANDLER CALLED ==========")
        print(f"ğŸ’° [ADMIN] Price input received from ADMIN {user_id} (@{username})")

        # âœ… Ø§Ù„ÙÙ„ØªØ± Ø¶Ù…Ù† Ø¥Ù†Ù†Ø§ Ù‡Ù†Ø§ ÙÙ‚Ø· Ù„Ùˆ ÙÙŠ sessionØŒ Ø¨Ø³ Ù„Ù„ØªØ£ÙƒÙŠØ¯:
        if user_id not in self.user_sessions:
            print(f"âš ï¸ [ADMIN] No active session (filter should have caught this)")
            return

        session = self.user_sessions[user_id]
        print(f"ğŸ“‹ [ADMIN] Session data: {session}")

        if session.get("step") != "waiting_price":
            print(
                f"âš ï¸ [ADMIN] Admin {user_id} not in price waiting step: {session.get('step', 'unknown')}"
            )
            return

        print(f"âœ… [ADMIN] Admin {user_id} is in correct step: waiting_price")

        price_text = update.message.text.strip()
        print(f"ğŸ“ [ADMIN] Admin {user_id} entered price: '{price_text}'")

        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø³Ø¹Ø±
        is_valid, new_price, error_message = PriceManagement.validate_price_input(
            price_text
        )

        if not is_valid:
            print(
                f"âŒ [ADMIN] Invalid price input from admin {user_id}: {error_message}"
            )
            await update.message.reply_text(
                f"âŒ {error_message}\n\nÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰:", parse_mode="HTML"
            )
            return

        # Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ­Ø¯ÙŠØ«
        platform = session["platform"]
        transfer_type = session["transfer_type"]
        old_price = session["current_price"]

        print(
            f"ğŸ”„ [ADMIN] Updating price: {platform} {transfer_type} from {old_price} to {new_price}"
        )

        # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ø¹Ø± ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        success = await PriceManagement.update_price(
            platform, transfer_type, new_price, user_id
        )

        if not success:
            print(f"âŒ [ADMIN] Failed to update price in database")
            await update.message.reply_text(
                AdminMessages.get_error_message("database_error"), parse_mode="HTML"
            )
            return

        print(f"âœ… [ADMIN] Price successfully updated in database")

        # Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù†Ø¬Ø§Ø­
        success_message = AdminMessages.get_price_update_success(
            platform, transfer_type, old_price, new_price
        )
        keyboard = AdminKeyboards.get_price_update_success_keyboard()

        try:
            await update.message.reply_text(
                success_message, reply_markup=keyboard, parse_mode="HTML"
            )
            print(f"âœ… [ADMIN] Success message sent to admin {user_id}")
        except Exception as e:
            print(f"âŒ [ADMIN] Failed to send success message: {e}")

        # Ù…Ø³Ø­ Ø§Ù„Ø¬Ù„Ø³Ø©
        del self.user_sessions[user_id]
        print(f"ğŸ§¹ [ADMIN] Session cleared for admin {user_id}")
        print(f"ğŸ”‘ [ADMIN] Active sessions now: {list(self.user_sessions.keys())}")

        logger.info(
            f"âœ… Price updated by admin {user_id}: {platform} {transfer_type} {old_price} -> {new_price}"
        )
        print(
            f"ğŸ’¾ [ADMIN] Price update logged: {platform} {transfer_type} {old_price} -> {new_price}"
        )

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # HELPER METHODS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async def _show_current_prices(self, update: Update, user_id: int):
        """Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø­Ø§Ù„ÙŠØ© (Ù„Ù„Ø£ÙˆØ§Ù…Ø±)"""
        prices = PriceManagement.get_all_current_prices()
        message = AdminMessages.get_current_prices_message(prices)
        keyboard = AdminKeyboards.get_view_prices_keyboard()

        AdminOperations.log_admin_action(user_id, "VIEWED_PRICES")

        await update.message.reply_text(
            message, reply_markup=keyboard, parse_mode="HTML"
        )

    async def _show_current_prices_callback(self, query, user_id: int):
        """Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø­Ø§Ù„ÙŠØ© (Ù„Ù„Ø£Ø²Ø±Ø§Ø±)"""
        print(f"ğŸ“‹ [ADMIN] Fetching current prices for admin {user_id}")

        try:
            prices = PriceManagement.get_all_current_prices()
            print(f"ğŸ’° [ADMIN] Retrieved {len(prices)} price entries from database")

            message = AdminMessages.get_current_prices_message(prices)
            keyboard = AdminKeyboards.get_view_prices_keyboard()

            AdminOperations.log_admin_action(user_id, "VIEWED_PRICES")

            await query.edit_message_text(
                message, reply_markup=keyboard, parse_mode="HTML"
            )
            print(f"âœ… [ADMIN] Prices successfully displayed to admin {user_id}")

        except Exception as e:
            print(f"âŒ [ADMIN] Error displaying prices to admin {user_id}: {e}")
            await query.edit_message_text(
                "âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.", parse_mode="HTML"
            )


--- FC26_sale_coins_Bot/services/admin/admin_keyboards.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ‘‘ FC26 ADMIN KEYBOARDS - Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø§Ø¯Ø§Ø±Ø©                     â•‘
# â•‘                     Admin Keyboards Handler                             â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from typing import List

class AdminKeyboards:
    """Ø£Ø²Ø±Ø§Ø± Ù„ÙˆØ­Ø© Ø§Ù„Ø§Ø¯Ø§Ø±Ø©"""
    
    @staticmethod
    def get_main_admin_keyboard() -> InlineKeyboardMarkup:
        """Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„Ù„Ø¥Ø¯Ø§Ø±Ø©"""
        keyboard = [
            [InlineKeyboardButton("ğŸ’° Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø³Ø¹Ø§Ø±", callback_data="admin_prices")]
            # Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ§Ù„ÙŠØ© ØªÙ… Ø­Ø°ÙÙ‡Ø§ (ØºÙŠØ± Ù…Ø·Ù„ÙˆØ¨Ø© Ø­Ø§Ù„ÙŠØ§Ù‹):
            # [InlineKeyboardButton("ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª", callback_data="admin_stats")],
            # [InlineKeyboardButton("ğŸ“ Ø³Ø¬Ù„ Ø§Ù„Ø£Ø¹Ù…Ø§Ù„", callback_data="admin_logs")],
            # [InlineKeyboardButton("âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…", callback_data="admin_settings")],
            # [InlineKeyboardButton("ğŸ”„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙˆØª", callback_data="admin_refresh")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_price_management_keyboard() -> InlineKeyboardMarkup:
        """Ù„ÙˆØ­Ø© Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø³Ø¹Ø§Ø±"""
        keyboard = [
            # [InlineKeyboardButton("ğŸ“‹ Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø­Ø§Ù„ÙŠØ©", callback_data="admin_view_prices")],  # ØªÙ… Ø§Ù„Ø­Ø°Ù
            [InlineKeyboardButton("âœï¸ ØªØ¹Ø¯ÙŠÙ„ Ø£Ø³Ø¹Ø§Ø± PlayStation", callback_data="admin_edit_playstation")],
            [InlineKeyboardButton("âœï¸ ØªØ¹Ø¯ÙŠÙ„ Ø£Ø³Ø¹Ø§Ø± Xbox", callback_data="admin_edit_xbox")],
            [InlineKeyboardButton("âœï¸ ØªØ¹Ø¯ÙŠÙ„ Ø£Ø³Ø¹Ø§Ø± PC", callback_data="admin_edit_pc")],
            # [InlineKeyboardButton("ğŸ“Š Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„Ø£Ø³Ø¹Ø§Ø±", callback_data="admin_compare_prices")],  # ØªÙ… Ø§Ù„Ø­Ø°Ù
            [InlineKeyboardButton("ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="admin_main")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_platform_edit_keyboard(platform: str) -> InlineKeyboardMarkup:
        """Ù„ÙˆØ­Ø© ØªØ¹Ø¯ÙŠÙ„ Ø£Ø³Ø¹Ø§Ø± Ù…Ù†ØµØ© Ù…Ø¹ÙŠÙ†Ø©"""
        keyboard = [
            [InlineKeyboardButton("ğŸ“… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¹Ø§Ø¯ÙŠ", callback_data=f"admin_edit_{platform}_normal")],
            [InlineKeyboardButton("âš¡ï¸ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„ÙÙˆØ±ÙŠ", callback_data=f"admin_edit_{platform}_instant")],
            [InlineKeyboardButton("ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø³Ø¹Ø§Ø±", callback_data="admin_prices")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_price_edit_keyboard(platform: str, transfer_type: str) -> InlineKeyboardMarkup:
        """Ù„ÙˆØ­Ø© ØªØ¹Ø¯ÙŠÙ„ Ø³Ø¹Ø± Ù…Ø¹ÙŠÙ†"""
        keyboard = [
            [InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„", callback_data=f"admin_edit_{platform}")],
            [InlineKeyboardButton("ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø©", callback_data="admin_prices")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_price_update_success_keyboard() -> InlineKeyboardMarkup:
        """Ù„ÙˆØ­Ø© Ø¨Ø¹Ø¯ Ù†Ø¬Ø§Ø­ Ø§Ù„ØªØ­Ø¯ÙŠØ«"""
        keyboard = [
            [InlineKeyboardButton("ğŸ’° ØªØ¹Ø¯ÙŠÙ„ Ø³Ø¹Ø± Ø¢Ø®Ø±", callback_data="admin_prices")],
            [InlineKeyboardButton("ğŸ  Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="admin_main")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_view_prices_keyboard() -> InlineKeyboardMarkup:
        """Ù„ÙˆØ­Ø© Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±"""
        keyboard = [
            [InlineKeyboardButton("âœï¸ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±", callback_data="admin_prices")],
            [InlineKeyboardButton("ğŸ”„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¹Ø±Ø¶", callback_data="admin_view_prices")],
            # [InlineKeyboardButton("ğŸ“Š Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„Ù…Ù†ØµØ§Øª", callback_data="admin_compare_prices")],  # ØªÙ… Ø§Ù„Ø­Ø°Ù
            [InlineKeyboardButton("ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="admin_main")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_admin_logs_keyboard() -> InlineKeyboardMarkup:
        """Ù„ÙˆØ­Ø© Ø³Ø¬Ù„ Ø§Ù„Ø£Ø¹Ù…Ø§Ù„"""
        keyboard = [
            # Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ§Ù„ÙŠØ© ØªÙ… Ø­Ø°ÙÙ‡Ø§ (ØºÙŠØ± Ù…Ø·Ù„ÙˆØ¨Ø© Ø­Ø§Ù„ÙŠØ§Ù‹):
            # [InlineKeyboardButton("ğŸ”„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ø¬Ù„", callback_data="admin_logs")],
            # [InlineKeyboardButton("ğŸ—‘ï¸ Ù…Ø³Ø­ Ø§Ù„Ø³Ø¬Ù„ Ø§Ù„Ù‚Ø¯ÙŠÙ…", callback_data="admin_clear_logs")],
            # [InlineKeyboardButton("ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø³Ø¬Ù„", callback_data="admin_log_stats")],
            [InlineKeyboardButton("ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="admin_main")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_stats_keyboard() -> InlineKeyboardMarkup:
        """Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª"""
        keyboard = [
            [InlineKeyboardButton("ğŸ‘¥ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†", callback_data="admin_user_stats")],
            [InlineKeyboardButton("ğŸ’° Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª", callback_data="admin_sales_stats")],
            [InlineKeyboardButton("ğŸ“ˆ ØªÙ‚Ø±ÙŠØ± ÙŠÙˆÙ…ÙŠ", callback_data="admin_daily_report")],
            [InlineKeyboardButton("ğŸ“Š ØªÙ‚Ø±ÙŠØ± Ø´Ù‡Ø±ÙŠ", callback_data="admin_monthly_report")],
            [InlineKeyboardButton("ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="admin_main")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_unauthorized_keyboard() -> InlineKeyboardMarkup:
        """Ù„ÙˆØ­Ø© Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ ØµÙ„Ø§Ø­ÙŠØ©"""
        keyboard = [
            [InlineKeyboardButton("ğŸ  Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="main_menu")],
            [InlineKeyboardButton("ğŸ“ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù…", callback_data="contact_support")]
        ]
        return InlineKeyboardMarkup(keyboard)

--- FC26_sale_coins_Bot/services/admin/admin_messages.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ‘‘ FC26 ADMIN MESSAGES - Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø§Ø¯Ø§Ø±Ø©                     â•‘
# â•‘                     Admin Messages Handler                              â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from typing import List, Dict
from datetime import datetime

class AdminMessages:
    """Ø±Ø³Ø§Ø¦Ù„ Ù„ÙˆØ­Ø© Ø§Ù„Ø§Ø¯Ø§Ø±Ø©"""
    
    @staticmethod
    def get_main_admin_message(admin_id: int) -> str:
        """Ø±Ø³Ø§Ù„Ø© Ù„ÙˆØ­Ø© Ø§Ù„Ø§Ø¯Ø§Ø±Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"""
        return f"""ğŸ‘‘ <b>Ù„ÙˆØ­Ø© Ø§Ù„Ø§Ø¯Ø§Ø±Ø© - FC26</b>

ğŸ†” <b>Ø§Ù„Ø§Ø¯Ù…Ù†:</b> <code>{admin_id}</code>
â° <b>Ø§Ù„ÙˆÙ‚Øª:</b> {datetime.now().strftime('%Y-%m-%d %H:%M')}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¯ <b>Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©:</b>

ğŸ’° <b>Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø³Ø¹Ø§Ø±:</b>
â€¢ Ø¹Ø±Ø¶ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø­Ø§Ù„ÙŠØ©
â€¢ ØªØ¹Ø¯ÙŠÙ„ Ø£Ø³Ø¹Ø§Ø± Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²
â€¢ Ù…Ø±Ø§Ø¬Ø¹Ø© ØªØ§Ø±ÙŠØ® Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª

ğŸ“Š <b>Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª:</b>
â€¢ Ù…Ø±Ø§Ø¬Ø¹Ø© Ø£Ø¯Ø§Ø¡ Ø§Ù„Ø¨ÙˆØª
â€¢ Ø¹Ø±Ø¶ Ø³Ø¬Ù„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª
â€¢ ØªÙ‚Ø§Ø±ÙŠØ± Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª

âš™ï¸ <b>Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…:</b>
â€¢ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
â€¢ ØªØ­Ø¯ÙŠØ« Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨ÙˆØª
â€¢ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ

Ø§Ø®ØªØ± Ø§Ù„Ø®Ø¯Ù…Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø£Ø¯Ù†Ø§Ù‡ ğŸ‘‡"""

    @staticmethod
    def get_price_management_message() -> str:
        """Ø±Ø³Ø§Ù„Ø© Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø³Ø¹Ø§Ø±"""
        return """ğŸ’° <b>Ø¥Ø¯Ø§Ø±Ø© Ø£Ø³Ø¹Ø§Ø± Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¯ <b>Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©:</b>

ğŸ“‹ <b>Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±:</b>
â€¢ Ø¹Ø±Ø¶ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø­Ø§Ù„ÙŠØ©
â€¢ Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø¨ÙŠÙ† Ø§Ù„Ù…Ù†ØµØ§Øª
â€¢ ØªØ§Ø±ÙŠØ® Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«

âœï¸ <b>ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±:</b>
â€¢ ØªØ¹Ø¯ÙŠÙ„ Ø£Ø³Ø¹Ø§Ø± PlayStation
â€¢ ØªØ¹Ø¯ÙŠÙ„ Ø£Ø³Ø¹Ø§Ø± Xbox  
â€¢ ØªØ¹Ø¯ÙŠÙ„ Ø£Ø³Ø¹Ø§Ø± PC

ğŸ“Š <b>Ø§Ù„Ø³Ø¬Ù„Ø§Øª:</b>
â€¢ Ù…Ø±Ø§Ø¬Ø¹Ø© ØªØ§Ø±ÙŠØ® Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª
â€¢ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª
â€¢ ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ø£Ø³Ø¹Ø§Ø±

âš ï¸ <b>ØªÙ†Ø¨ÙŠÙ‡:</b> Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª ÙŠØªÙ… Ø­ÙØ¸Ù‡Ø§ ÙÙŠ Ø§Ù„Ø³Ø¬Ù„

Ø§Ø®ØªØ± Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:"""

    @staticmethod
    def get_current_prices_message(prices: List[Dict]) -> str:
        """Ø±Ø³Ø§Ù„Ø© Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø­Ø§Ù„ÙŠØ©"""
        if not prices:
            return "âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ø³Ø¹Ø§Ø± Ù…Ø­ÙÙˆØ¸Ø© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"
        
        message = "ğŸ“Š <b>Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø­Ø§Ù„ÙŠØ© - Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù†ØµØ§Øª</b>\n\n"
        
        # ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø­Ø³Ø¨ Ø§Ù„Ù…Ù†ØµØ©
        platforms = {}
        for price in prices:
            platform = price['platform']
            if platform not in platforms:
                platforms[platform] = {}
            
            platforms[platform][price['transfer_type']] = {
                'price': price['price'],
                'amount': price['amount'],
                'updated': price['updated_at']
            }
        
        # Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±
        platform_names = {
            'playstation': 'ğŸ® PlayStation',
            'xbox': 'ğŸ® Xbox', 
            'pc': 'ğŸ–¥ï¸ PC'
        }
        
        for platform, platform_prices in platforms.items():
            platform_name = platform_names.get(platform, platform)
            message += f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            message += f"<b>{platform_name}</b>\n\n"
            
            if 'normal' in platform_prices:
                normal = platform_prices['normal']
                message += f"ğŸ“… <b>Ø¹Ø§Ø¯ÙŠ:</b> {normal['price']:,} Ø¬.Ù…\n"
                message += f"   ğŸ’° Ø§Ù„ÙƒÙ…ÙŠØ©: {normal['amount']:,} ÙƒÙˆÙŠÙ†\n"
                message += f"   ğŸ“… Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«: {normal['updated'][:16]}\n\n"
            
            if 'instant' in platform_prices:
                instant = platform_prices['instant']
                message += f"âš¡ï¸ <b>ÙÙˆØ±ÙŠ:</b> {instant['price']:,} Ø¬.Ù…\n"
                message += f"   ğŸ’° Ø§Ù„ÙƒÙ…ÙŠØ©: {instant['amount']:,} ÙƒÙˆÙŠÙ†\n"
                message += f"   ğŸ“… Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«: {instant['updated'][:16]}\n\n"
        
        message += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        message += "ğŸ’¡ <b>Ù…Ù„Ø§Ø­Ø¸Ø©:</b> Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø¨Ø§Ù„Ø¬Ù†ÙŠÙ‡ Ø§Ù„Ù…ØµØ±ÙŠ"
        
        return message

    @staticmethod
    def get_platform_edit_message(platform: str) -> str:
        """Ø±Ø³Ø§Ù„Ø© ØªØ¹Ø¯ÙŠÙ„ Ø£Ø³Ø¹Ø§Ø± Ù…Ù†ØµØ© Ù…Ø¹ÙŠÙ†Ø©"""
        platform_names = {
            'playstation': 'ğŸ® PlayStation',
            'xbox': 'ğŸ® Xbox',
            'pc': 'ğŸ–¥ï¸ PC'
        }
        
        platform_name = platform_names.get(platform, platform)
        
        return f"""âœï¸ <b>ØªØ¹Ø¯ÙŠÙ„ Ø£Ø³Ø¹Ø§Ø± {platform_name}</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¯ <b>Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„:</b>

ğŸ“… <b>Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¹Ø§Ø¯ÙŠ:</b>
â€¢ Ø§Ù„Ù…Ø¯Ø©: Ø®Ù„Ø§Ù„ 24 Ø³Ø§Ø¹Ø©
â€¢ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ Ø³ÙŠØªÙ… Ø¹Ø±Ø¶Ù‡

âš¡ï¸ <b>Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„ÙÙˆØ±ÙŠ:</b>
â€¢ Ø§Ù„Ù…Ø¯Ø©: Ø®Ù„Ø§Ù„ Ø³Ø§Ø¹Ø© ÙˆØ§Ø­Ø¯Ø©
â€¢ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ Ø³ÙŠØªÙ… Ø¹Ø±Ø¶Ù‡

âš ï¸ <b>ØªØ­Ø°ÙŠØ±:</b>
â€¢ ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø³Ø¹Ø± Ù‚Ø¨Ù„ Ø§Ù„Ø­ÙØ¸
â€¢ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ ÙŠØ¤Ø«Ø± ÙÙˆØ±Ø§Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
â€¢ Ø³ÙŠØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ ÙÙŠ Ø§Ù„Ø³Ø¬Ù„

Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„:"""

    @staticmethod
    def get_price_edit_prompt(platform: str, transfer_type: str, current_price: int) -> str:
        """Ø±Ø³Ø§Ù„Ø© Ø·Ù„Ø¨ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯"""
        platform_names = {
            'playstation': 'ğŸ® PlayStation',
            'xbox': 'ğŸ® Xbox',
            'pc': 'ğŸ–¥ï¸ PC'
        }
        
        transfer_names = {
            'normal': 'ğŸ“… Ø¹Ø§Ø¯ÙŠ',
            'instant': 'âš¡ï¸ ÙÙˆØ±ÙŠ'
        }
        
        platform_name = platform_names.get(platform, platform)
        transfer_name = transfer_names.get(transfer_type, transfer_type)
        
        return f"""ğŸ’° <b>ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø³Ø¹Ø±</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ® <b>Ø§Ù„Ù…Ù†ØµØ©:</b> {platform_name}
â° <b>Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„:</b> {transfer_name}
ğŸ’ <b>Ø§Ù„ÙƒÙ…ÙŠØ©:</b> 1,000,000 ÙƒÙˆÙŠÙ†

ğŸ’° <b>Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ:</b> <code>{current_price:,} Ø¬.Ù…</code>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœï¸ <b>Ø£Ø¯Ø®Ù„ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯:</b>

ğŸ“ <b>Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„:</b>
â€¢ Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø· (Ø¨Ø¯ÙˆÙ† ÙÙˆØ§ØµÙ„ Ø£Ùˆ Ø±Ù…ÙˆØ²)
â€¢ Ø§Ù„Ø³Ø¹Ø± Ø¨Ø§Ù„Ø¬Ù†ÙŠÙ‡ Ø§Ù„Ù…ØµØ±ÙŠ
â€¢ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰: 1000 Ø¬.Ù…
â€¢ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰: 50000 Ø¬.Ù…

ğŸ’¡ <b>Ù…Ø«Ø§Ù„:</b> 5500

Ø§ÙƒØªØ¨ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯:"""

    @staticmethod
    def get_price_update_success(platform: str, transfer_type: str, old_price: int, new_price: int) -> str:
        """Ø±Ø³Ø§Ù„Ø© Ù†Ø¬Ø§Ø­ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ø¹Ø±"""
        platform_names = {
            'playstation': 'ğŸ® PlayStation',
            'xbox': 'ğŸ® Xbox',
            'pc': 'ğŸ–¥ï¸ PC'
        }
        
        transfer_names = {
            'normal': 'ğŸ“… Ø¹Ø§Ø¯ÙŠ',
            'instant': 'âš¡ï¸ ÙÙˆØ±ÙŠ'
        }
        
        platform_name = platform_names.get(platform, platform)
        transfer_name = transfer_names.get(transfer_type, transfer_type)
        
        return f"""âœ… <b>ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ø¹Ø± Ø¨Ù†Ø¬Ø§Ø­!</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‹ <b>ØªÙØ§ØµÙŠÙ„ Ø§Ù„ØªØ­Ø¯ÙŠØ«:</b>

ğŸ® <b>Ø§Ù„Ù…Ù†ØµØ©:</b> {platform_name}
â° <b>Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„:</b> {transfer_name}
ğŸ’ <b>Ø§Ù„ÙƒÙ…ÙŠØ©:</b> 1,000,000 ÙƒÙˆÙŠÙ†

ğŸ’° <b>Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ù‚Ø¯ÙŠÙ…:</b> <s>{old_price:,} Ø¬.Ù…</s>
ğŸ’° <b>Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯:</b> <code>{new_price:,} Ø¬.Ù…</code>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â° <b>ÙˆÙ‚Øª Ø§Ù„ØªØ­Ø¯ÙŠØ«:</b> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

âœ¨ <b>Ø§Ù„ØªØ­Ø¯ÙŠØ« Ù…ÙØ¹Ù„ Ø§Ù„Ø¢Ù†:</b>
â€¢ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø³ÙŠØ±ÙˆÙ† Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯
â€¢ ØªÙ… Ø­ÙØ¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ ÙÙŠ Ø§Ù„Ø³Ø¬Ù„
â€¢ ÙŠÙ…ÙƒÙ† ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø³Ø¹Ø± Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ ÙÙŠ Ø£ÙŠ ÙˆÙ‚Øª

ğŸ”™ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ù„Ù„Ø¹ÙˆØ¯Ø© Ø£Ùˆ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰"""

    @staticmethod
    def get_admin_logs_message(logs: List[Dict]) -> str:
        """Ø±Ø³Ø§Ù„Ø© Ø¹Ø±Ø¶ Ø³Ø¬Ù„ Ø£Ø¹Ù…Ø§Ù„ Ø§Ù„Ø§Ø¯Ù…Ù†"""
        if not logs:
            return "ğŸ“ <b>Ø³Ø¬Ù„ Ø§Ù„Ø£Ø¹Ù…Ø§Ù„ ÙØ§Ø±Øº</b>\n\nÙ„Ø§ ØªÙˆØ¬Ø¯ Ø¹Ù…Ù„ÙŠØ§Øª Ù…Ø³Ø¬Ù„Ø© Ø­ØªÙ‰ Ø§Ù„Ø¢Ù†."
        
        message = "ğŸ“ <b>Ø³Ø¬Ù„ Ø£Ø¹Ù…Ø§Ù„ Ø§Ù„Ø§Ø¯Ø§Ø±Ø©</b>\n\n"
        
        for i, log in enumerate(logs[:10], 1):  # Ø£ÙˆÙ„ 10 Ø¹Ù…Ù„ÙŠØ§Øª
            action_icons = {
                'UPDATE_PRICE': 'ğŸ’°',
                'ADMIN_LOGIN': 'ğŸ”', 
                'VIEWED_PRICES': 'ğŸ‘ï¸',
                'ACCESSED_PRICE_MANAGEMENT': 'âš™ï¸'
            }
            
            icon = action_icons.get(log['action'], 'ğŸ“‹')
            timestamp = log['timestamp'][:16]  # ÙÙ‚Ø· Ø§Ù„ØªØ§Ø±ÙŠØ® ÙˆØ§Ù„ÙˆÙ‚Øª
            
            message += f"{i}. {icon} <b>{log['action']}</b>\n"
            message += f"   â° {timestamp}\n"
            
            if log['details']:
                message += f"   ğŸ“ {log['details'][:50]}...\n"
            
            message += "\n"
        
        if len(logs) > 10:
            message += f"... Ùˆ {len(logs) - 10} Ø¹Ù…Ù„ÙŠØ© Ø£Ø®Ø±Ù‰"
        
        return message

    @staticmethod
    def get_unauthorized_message() -> str:
        """Ø±Ø³Ø§Ù„Ø© Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ ØµÙ„Ø§Ø­ÙŠØ©"""
        return """ğŸš« <b>ØºÙŠØ± Ù…ØµØ±Ø­ Ù„Ùƒ!</b>

âŒ <b>Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„Ù„ÙˆØµÙˆÙ„ Ù„Ù‡Ø°Ù‡ Ø§Ù„Ø®Ø¯Ù…Ø©</b>

ğŸ” <b>Ù‡Ø°Ù‡ Ø§Ù„Ø®Ø¯Ù…Ø© Ù…Ø®ØµØµØ© Ù„Ù„Ø¥Ø¯Ø§Ø±Ø© ÙÙ‚Ø·</b>

ğŸ’¬ Ø¥Ø°Ø§ ÙƒÙ†Øª ØªØ¹ØªÙ‚Ø¯ Ø£Ù† Ù‡Ø°Ø§ Ø®Ø·Ø£ØŒ ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ"""

    @staticmethod
    def get_error_message(error_type: str = "general") -> str:
        """Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…Ø®ØªÙ„ÙØ©"""
        errors = {
            "invalid_price": "âŒ <b>Ø³Ø¹Ø± ØºÙŠØ± ØµØ­ÙŠØ­!</b>\n\nÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­ Ø¨ÙŠÙ† 1000 Ùˆ 50000",
            "database_error": "âŒ <b>Ø®Ø·Ø£ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª!</b>\n\nØ­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­ÙØ¸ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰",
            "general": "âŒ <b>Ø­Ø¯Ø« Ø®Ø·Ø£!</b>\n\nÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø£Ùˆ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ"
        }
        
        return errors.get(error_type, errors["general"])

--- FC26_sale_coins_Bot/services/admin/price_management.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ’° FC26 PRICE MANAGEMENT - Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø³Ø¹Ø§Ø±                    â•‘
# â•‘                     Price Management Handler                            â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import re
from typing import Optional, Tuple
import sys
import os

# Ø¥Ø¶Ø§ÙØ© Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))

from database.admin_operations import AdminOperations

class PriceManagement:
    """Ù…Ø¹Ø§Ù„Ø¬ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø³Ø¹Ø§Ø±"""
    
    # Ø§Ù„Ø­Ø¯ÙˆØ¯ Ø§Ù„Ù…Ø³Ù…ÙˆØ­Ø© Ù„Ù„Ø£Ø³Ø¹Ø§Ø±
    MIN_PRICE = 1000  # 1000 Ø¬.Ù…
    MAX_PRICE = 50000  # 50000 Ø¬.Ù…
    
    # Ø§Ù„ÙƒÙ…ÙŠØ© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
    DEFAULT_AMOUNT = 1000000  # 1M ÙƒÙˆÙŠÙ†
    
    @classmethod
    def validate_price_input(cls, price_text: str) -> Tuple[bool, Optional[int], str]:
        """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ù…Ø¯Ø®Ù„"""
        if not price_text or not isinstance(price_text, str):
            return False, None, "ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø³Ø¹Ø± ØµØ­ÙŠØ­"
        
        # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù†Øµ Ù…Ù† Ø§Ù„ÙÙˆØ§ØµÙ„ ÙˆØ§Ù„Ù…Ø³Ø§ÙØ§Øª
        cleaned = re.sub(r'[^\d]', '', price_text.strip())
        
        if not cleaned:
            return False, None, "ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·"
        
        try:
            price = int(cleaned)
        except ValueError:
            return False, None, "ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­"
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¯ÙˆØ¯
        if price < cls.MIN_PRICE:
            return False, None, f"Ø§Ù„Ø³Ø¹Ø± Ù‚Ù„ÙŠÙ„ Ø¬Ø¯Ø§Ù‹! Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰: {cls.MIN_PRICE:,} Ø¬.Ù…"
        
        if price > cls.MAX_PRICE:
            return False, None, f"Ø§Ù„Ø³Ø¹Ø± Ø¹Ø§Ù„ÙŠ Ø¬Ø¯Ø§Ù‹! Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰: {cls.MAX_PRICE:,} Ø¬.Ù…"
        
        return True, price, "Ø³Ø¹Ø± ØµØ­ÙŠØ­"
    
    @classmethod
    def get_current_price(cls, platform: str, transfer_type: str) -> Optional[int]:
        """Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ"""
        return AdminOperations.get_price(platform, transfer_type, cls.DEFAULT_AMOUNT)
    
    @classmethod
    async def update_price(cls, platform: str, transfer_type: str, new_price: int, admin_id: int) -> bool:
        """ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ø¹Ø± - Thread-safe async version"""
        return await AdminOperations.update_price(
            platform, transfer_type, cls.DEFAULT_AMOUNT, new_price, admin_id
        )
    
    @classmethod
    def get_all_current_prices(cls):
        """Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø­Ø§Ù„ÙŠØ©"""
        return AdminOperations.get_all_prices()
    
    @classmethod
    def calculate_price_difference(cls, old_price: int, new_price: int) -> dict:
        """Ø­Ø³Ø§Ø¨ Ø§Ù„ÙØ±Ù‚ ÙÙŠ Ø§Ù„Ø³Ø¹Ø±"""
        difference = new_price - old_price
        percentage = (difference / old_price) * 100 if old_price > 0 else 0
        
        return {
            'absolute_diff': difference,
            'percentage_diff': round(percentage, 2),
            'is_increase': difference > 0,
            'is_decrease': difference < 0
        }
    
    @classmethod
    def format_price_change(cls, old_price: int, new_price: int) -> str:
        """ØªÙ†Ø³ÙŠÙ‚ Ø¹Ø±Ø¶ ØªØºÙŠÙŠØ± Ø§Ù„Ø³Ø¹Ø±"""
        diff = cls.calculate_price_difference(old_price, new_price)
        
        if diff['is_increase']:
            return f"ğŸ“ˆ Ø²ÙŠØ§Ø¯Ø©: +{diff['absolute_diff']:,} Ø¬.Ù… ({diff['percentage_diff']:+.1f}%)"
        elif diff['is_decrease']:
            return f"ğŸ“‰ Ù†Ù‚Øµ: {diff['absolute_diff']:,} Ø¬.Ù… ({diff['percentage_diff']:+.1f}%)"
        else:
            return "â¡ï¸ Ù„Ø§ ÙŠÙˆØ¬Ø¯ ØªØºÙŠÙŠØ±"
    
    @classmethod
    def validate_platform(cls, platform: str) -> bool:
        """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ù…Ù†ØµØ©"""
        valid_platforms = ['playstation', 'xbox', 'pc']
        return platform.lower() in valid_platforms
    
    @classmethod
    def validate_transfer_type(cls, transfer_type: str) -> bool:
        """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„"""
        valid_types = ['normal', 'instant']
        return transfer_type.lower() in valid_types
    
    @classmethod
    def get_price_history_summary(cls, platform: str, transfer_type: str, limit: int = 5):
        """Ø¬Ù„Ø¨ Ù…Ù„Ø®Øµ ØªØ§Ø±ÙŠØ® ØªØºÙŠÙŠØ± Ø§Ù„Ø³Ø¹Ø± (ÙŠØ­ØªØ§Ø¬ ØªØ·ÙˆÙŠØ± Ø¥Ø¶Ø§ÙÙŠ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª)"""
        # Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© Ù„Ù„ØªØ·ÙˆÙŠØ± Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„ÙŠ
        pass
    
    @classmethod
    def export_prices_data(cls) -> dict:
        """ØªØµØ¯ÙŠØ± Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ø³Ø¹Ø§Ø±"""
        prices = cls.get_all_current_prices()
        
        export_data = {
            'export_time': AdminOperations.get_current_timestamp(),
            'total_prices': len(prices),
            'platforms': {},
            'raw_data': prices
        }
        
        # ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø­Ø³Ø¨ Ø§Ù„Ù…Ù†ØµØ©
        for price in prices:
            platform = price['platform']
            if platform not in export_data['platforms']:
                export_data['platforms'][platform] = {
                    'normal': None,
                    'instant': None
                }
            
            export_data['platforms'][platform][price['transfer_type']] = price['price']
        
        return export_data

--- FC26_sale_coins_Bot/services/sell_coins/__init__.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ’° FC26 COIN SELLING SERVICE - Ø®Ø¯Ù…Ø© Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²             â•‘
# â•‘                     Coin Selling Service Package                        â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Import only when telegram is available
def _import_telegram_components():
    """Import telegram-dependent components"""
    try:
        from .sell_handler import SellCoinsHandler
        from .sell_keyboards import SellKeyboards
        from .sell_conversation_handler import SellConversationHandler
        from .sell_conversation_functions import get_sell_conversation_handler, sell_command
        from .sell_callbacks import handle_sell_callbacks
        return SellCoinsHandler, SellKeyboards, SellConversationHandler, get_sell_conversation_handler, sell_command, handle_sell_callbacks
    except ImportError:
        return None, None, None, None, None, None

# Always available imports (no telegram dependency)
from .sell_pricing import CoinSellPricing, Platform
from .sell_messages import SellMessages

# Conditional imports
SellCoinsHandler, SellKeyboards, SellConversationHandler, get_sell_conversation_handler, sell_command, handle_sell_callbacks = _import_telegram_components()

__all__ = [
    'CoinSellPricing',
    'Platform', 
    'SellMessages'
]

# Add telegram-dependent components if available
if SellCoinsHandler is not None:
    __all__.extend([
        'SellCoinsHandler', 
        'SellKeyboards', 
        'SellConversationHandler', 
        'get_sell_conversation_handler', 
        'sell_command', 
        'handle_sell_callbacks'
    ])

--- FC26_sale_coins_Bot/services/sell_coins/sell_callbacks.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘            ğŸ¯ FC26 SELL CALLBACKS - Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø¨ÙŠØ¹                â•‘
# â•‘                      Sell Callback Handlers                             â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes


async def handle_sell_callbacks(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬ Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø¨ÙŠØ¹"""
    query = update.callback_query
    await query.answer()

    if query.data == "contact_support":
        await query.edit_message_text(
            "ğŸ“ **Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù…**\n\n"
            "ğŸ”¥ **Ù„Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù„Ø³Ø±ÙŠØ¹Ø©:**\n"
            "ÙˆØ§ØªØ³Ø§Ø¨ Ø§Ù„Ø¯Ø¹Ù…: `01094591331`\n\n"
            "âš¡ **Ø£ÙˆÙ‚Ø§Øª Ø§Ù„Ø¹Ù…Ù„:**\n"
            "â€¢ 24 Ø³Ø§Ø¹Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹\n"
            "â€¢ 7 Ø£ÙŠØ§Ù… ÙÙŠ Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹\n"
            "â€¢ Ø±Ø¯ Ø³Ø±ÙŠØ¹ Ø®Ù„Ø§Ù„ Ø¯Ù‚Ø§Ø¦Ù‚\n\n"
            "ğŸ’¬ **Ø§ÙƒØªØ¨ Ø±Ø³Ø§Ù„ØªÙƒ ÙˆØ³Ù†Ø±Ø¯ Ø¹Ù„ÙŠÙƒ ÙÙˆØ±Ø§Ù‹**",
            parse_mode="Markdown"
        )
    
    elif query.data == "main_menu":
        keyboard = [
            [InlineKeyboardButton("ğŸ’° Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²", callback_data="sell_coins_menu")],
            [InlineKeyboardButton("ğŸ“ Ø§Ù„Ø¯Ø¹Ù…", callback_data="contact_support")],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            "ğŸ  **Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© - FC 26**\n\n"
            "Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø¨ÙˆØª FC 26\n"
            "Ø§Ø®ØªØ± Ø§Ù„Ø®Ø¯Ù…Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:",
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )

    elif query.data == "sell_coins_menu":
        keyboard = [
            [InlineKeyboardButton("ğŸ® Ø¨ÙŠØ¹ ÙƒÙˆÙŠÙ†Ø² FC 26", callback_data="sell_fc26")],
            [InlineKeyboardButton("ğŸ“ Ø§Ù„ØªØ­Ø¯Ø« Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù…", callback_data="contact_support")],
            [InlineKeyboardButton("ğŸ  Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="main_menu")],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            "ğŸ’° **Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø² - FC 26**\n\n"
            "ğŸ”¥ **Ø®Ø¯Ù…Ø§ØªÙ†Ø§:**\n"
            "â€¢ Ø¨ÙŠØ¹ ÙƒÙˆÙŠÙ†Ø² FC 26 Ø¨Ø£ÙØ¶Ù„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±\n"
            "â€¢ Ø¯ÙØ¹ ÙÙˆØ±ÙŠ ÙˆØ¢Ù…Ù†\n"
            "â€¢ Ø¯Ø¹Ù… ÙÙ†ÙŠ 24/7\n"
            "â€¢ Ø¶Ù…Ø§Ù† Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©\n\n"
            "Ø§Ø®ØªØ± Ø§Ù„Ø®Ø¯Ù…Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:",
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )

--- FC26_sale_coins_Bot/services/sell_coins/sell_conversation_functions.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘      ğŸ¯ FC26 SELL CONVERSATION FUNCTIONS - Ø¯ÙˆØ§Ù„ Ù…Ø­Ø§Ø¯Ø«Ø© Ø§Ù„Ø¨ÙŠØ¹            â•‘
# â•‘                    Sell Conversation Handler Functions                  â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import (
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
    ConversationHandler,
    MessageHandler,
    filters,
)

from states.sell_states import SellStates

from .sell_conversation_handler import SellConversationHandler
from .sell_pricing import CoinSellPricing


# ================================ Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¨ÙŠØ¹ ================================
async def sell_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø£Ù…Ø± Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø² /sell"""
    user_id = update.effective_user.id

    keyboard = [
        [InlineKeyboardButton("ğŸ® Ø¨ÙŠØ¹ ÙƒÙˆÙŠÙ†Ø² FC 26", callback_data="sell_fc26")],
        [InlineKeyboardButton("ğŸ“ Ø§Ù„ØªØ­Ø¯Ø« Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù…", callback_data="contact_support")],
        [InlineKeyboardButton("ğŸ  Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="main_menu")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(
        "ğŸ’° **Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø² - FC 26**\n\n"
        "ğŸ”¥ **Ø®Ø¯Ù…Ø§ØªÙ†Ø§:**\n"
        "â€¢ Ø¨ÙŠØ¹ ÙƒÙˆÙŠÙ†Ø² FC 26 Ø¨Ø£ÙØ¶Ù„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±\n"
        "â€¢ Ø¯ÙØ¹ ÙÙˆØ±ÙŠ ÙˆØ¢Ù…Ù†\n"
        "â€¢ Ø¯Ø¹Ù… ÙÙ†ÙŠ 24/7\n"
        "â€¢ Ø¶Ù…Ø§Ù† Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©\n\n"
        "Ø§Ø®ØªØ± Ø§Ù„Ø®Ø¯Ù…Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:",
        reply_markup=reply_markup,
        parse_mode="Markdown",
    )


async def sell_coins_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¨Ø¯Ø§ÙŠØ© Ù…Ø­Ø§Ø¯Ø«Ø© Ø§Ù„Ø¨ÙŠØ¹"""
    user_id = update.callback_query.from_user.id

    # Ø¹Ø±Ø¶ Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ù…Ù†ØµØ©
    keyboard = [
        [InlineKeyboardButton("ğŸ® PlayStation", callback_data="platform_playstation")],
        [InlineKeyboardButton("ğŸ® Xbox", callback_data="platform_xbox")],
        [InlineKeyboardButton("ğŸ–¥ï¸ PC", callback_data="platform_pc")],
        [InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="cancel_sell")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.callback_query.edit_message_text(
        "ğŸ® **Ø§Ø®ØªØ± Ù…Ù†ØµØ© Ø§Ù„Ù„Ø¹Ø¨:**\n\n" "Ø§Ø®ØªØ± Ø§Ù„Ù…Ù†ØµØ© Ø§Ù„Ù„ÙŠ Ø¹Ù†Ø¯Ùƒ Ø¹Ù„ÙŠÙ‡Ø§ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²:",
        reply_markup=reply_markup,
        parse_mode="Markdown",
    )

    return SellStates.CHOOSE_PLATFORM


async def platform_chosen(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù†ØµØ©"""
    query = update.callback_query
    await query.answer()

    if query.data == "cancel_sell":
        await query.edit_message_text(
            "âœ… **ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¨ÙŠØ¹**\n\nÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¹ÙˆØ¯Ø© ÙÙŠ Ø£ÙŠ ÙˆÙ‚Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… /sell",
            parse_mode="Markdown",
        )
        return ConversationHandler.END

    # Ø­ÙØ¸ Ø§Ù„Ù…Ù†ØµØ©
    platform = query.data.replace("platform_", "")
    context.user_data["platform"] = platform
    platform_name = SellConversationHandler.get_platform_name(platform)

    # Ø¹Ø±Ø¶ Ø®ÙŠØ§Ø±Ø§Øª Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„
    keyboard = [
        [
            InlineKeyboardButton(
                "âš¡ ØªØ­ÙˆÙŠÙ„ ÙÙˆØ±ÙŠ (Ø®Ù„Ø§Ù„ Ø³Ø§Ø¹Ø©)", callback_data="type_instant"
            )
        ],
        [
            InlineKeyboardButton(
                "ğŸ“… ØªØ­ÙˆÙŠÙ„ Ø¹Ø§Ø¯ÙŠ (Ø®Ù„Ø§Ù„ 24 Ø³Ø§Ø¹Ø©)", callback_data="type_normal"
            )
        ],
        [InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="cancel_sell")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(
        f"âœ… **ØªÙ… Ø§Ø®ØªÙŠØ§Ø± {platform_name}**\n\n"
        "ğŸ’° **Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„:**\n\n"
        "âš¡ **ØªØ­ÙˆÙŠÙ„ ÙÙˆØ±ÙŠ:** Ø®Ù„Ø§Ù„ Ø³Ø§Ø¹Ø© ÙˆØ§Ø­Ø¯Ø© (Ø³Ø¹Ø± Ø£Ø¹Ù„Ù‰)\n"
        "ğŸ“… **ØªØ­ÙˆÙŠÙ„ Ø¹Ø§Ø¯ÙŠ:** Ø®Ù„Ø§Ù„ 24 Ø³Ø§Ø¹Ø© (Ø³Ø¹Ø± Ø¹Ø§Ø¯ÙŠ)\n\n"
        "ğŸ’¡ **Ø§Ù„Ø£Ø³Ø¹Ø§Ø± ØªØ®ØªÙ„Ù Ø­Ø³Ø¨ Ø§Ù„ÙƒÙ…ÙŠØ© ÙˆÙ†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„**",
        reply_markup=reply_markup,
        parse_mode="Markdown",
    )

    return SellStates.CHOOSE_TYPE


async def sell_type_chosen(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬ Ø§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„"""
    query = update.callback_query
    await query.answer()

    if query.data == "cancel_sell":
        await query.edit_message_text(
            "âœ… **ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¨ÙŠØ¹**\n\nÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¹ÙˆØ¯Ø© ÙÙŠ Ø£ÙŠ ÙˆÙ‚Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… /sell",
            parse_mode="Markdown",
        )
        return ConversationHandler.END

    # Ø­ÙØ¸ Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„
    transfer_type = "instant" if query.data == "type_instant" else "normal"
    context.user_data["transfer_type"] = transfer_type

    type_name = SellConversationHandler.get_transfer_type_name(transfer_type)
    platform_name = SellConversationHandler.get_platform_name(
        context.user_data.get("platform", "")
    )

    await query.edit_message_text(
        f"âœ… **ØªÙ… Ø§Ø®ØªÙŠØ§Ø± {platform_name} - {type_name}**\n\n"
        "ğŸ’° **Ø£Ø¯Ø®Ù„ ÙƒÙ…ÙŠØ© Ø§Ù„ÙƒÙˆÙŠÙ†Ø² Ù„Ù„Ø¨ÙŠØ¹:**\n\n"
        "ğŸ“ **Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„:**\n"
        "â€¢ Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø· (Ø¨Ø¯ÙˆÙ† Ø­Ø±ÙˆÙ Ø£Ùˆ Ø±Ù…ÙˆØ²)\n"
        "â€¢ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰: 2 Ø£Ø±Ù‚Ø§Ù… (Ù…Ø«Ø§Ù„: 50)\n"
        "â€¢ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰: 5 Ø£Ø±Ù‚Ø§Ù… (Ù…Ø«Ø§Ù„: 20000)\n"
        "â€¢ Ù…Ù…Ù†ÙˆØ¹ Ø§Ø³ØªØ®Ø¯Ø§Ù… k Ø£Ùˆ m\n\n"
        "ğŸ’¡ **Ø£Ù…Ø«Ù„Ø© ØµØ­ÙŠØ­Ø©:** 500ØŒ 1500ØŒ 20000\n\n"
        "Ø§ÙƒØªØ¨ Ø§Ù„ÙƒÙ…ÙŠØ© Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø§Ø¯ÙŠØ©:",
        parse_mode="Markdown",
    )

    return SellStates.ENTER_AMOUNT


async def sell_amount_entered(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬ Ø¥Ø¯Ø®Ø§Ù„ ÙƒÙ…ÙŠØ© Ø§Ù„ÙƒÙˆÙŠÙ†Ø²"""
    user_id = update.effective_user.id
    amount_text = update.message.text

    # ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙƒÙ…ÙŠØ© Ø§Ù„Ù…Ø¯Ø®Ù„Ø©
    amount = SellConversationHandler.parse_amount(amount_text)

    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…Ø®ØªÙ„ÙØ©
    error_responses = {
        "invalid_format": "âŒ **ØµÙŠØºØ© ØºÙŠØ± ØµØ­ÙŠØ­Ø©!**\n\nğŸš« **Ù…Ù…Ù†ÙˆØ¹ Ø§Ø³ØªØ®Ø¯Ø§Ù… k Ø£Ùˆ m**\n\nâœ… **Ø§Ù„Ù…Ø·Ù„ÙˆØ¨:** Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø· (2-5 Ø£Ø±Ù‚Ø§Ù…)\nğŸ“ **Ù…Ø«Ø§Ù„ ØµØ­ÙŠØ­:** 500 Ø£Ùˆ 1500 Ø£Ùˆ 20000\n\nÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„ÙƒÙ…ÙŠØ© Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø§Ø¯ÙŠØ© ÙÙ‚Ø·:",
        "invalid_length": f"âŒ **Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ØºÙŠØ± ØµØ­ÙŠØ­!**\n\nğŸ“ **Ø§Ù„Ù…Ø·Ù„ÙˆØ¨:**\nâ€¢ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰: 2 Ø£Ø±Ù‚Ø§Ù… (Ù…Ø«Ø§Ù„: 50)\nâ€¢ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰: 5 Ø£Ø±Ù‚Ø§Ù… (Ù…Ø«Ø§Ù„: 20000)\n\nØ£Ù†Øª Ø£Ø¯Ø®Ù„Øª: {len(amount_text)} Ø£Ø±Ù‚Ø§Ù…\n\nğŸ“ **Ø£Ù…Ø«Ù„Ø© ØµØ­ÙŠØ­Ø©:** 500ØŒ 1500ØŒ 20000\n\nÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø¨ÙŠÙ† 2-5 Ø£Ø±Ù‚Ø§Ù…:",
        None: "âŒ **ØµÙŠØºØ© ØºÙŠØ± ØµØ­ÙŠØ­Ø©!**\n\nâœ… **Ø§Ù„Ù…Ø·Ù„ÙˆØ¨:** Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø· (2-5 Ø£Ø±Ù‚Ø§Ù…)\nğŸš« **Ù…Ù…Ù†ÙˆØ¹:** Ø­Ø±ÙˆÙØŒ Ø±Ù…ÙˆØ²ØŒ kØŒ m\n\nğŸ“ **Ø£Ù…Ø«Ù„Ø© ØµØ­ÙŠØ­Ø©:**\nâ€¢ 500 \nâ€¢ 1500 \nâ€¢ 20000\n\nÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰:",
    }

    if amount in error_responses:
        await update.message.reply_text(error_responses[amount], parse_mode="Markdown")
        return SellStates.ENTER_AMOUNT

    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¯ÙˆØ¯
    is_valid, validation_message = SellConversationHandler.validate_amount(amount)
    if not is_valid:
        await update.message.reply_text(
            f"âŒ **{validation_message}**", parse_mode="Markdown"
        )
        return SellStates.ENTER_AMOUNT

    # Ø­ÙØ¸ Ø§Ù„ÙƒÙ…ÙŠØ© ÙˆØ­Ø³Ø§Ø¨ Ø§Ù„Ø³Ø¹Ø±
    context.user_data["amount"] = amount
    transfer_type = context.user_data.get("transfer_type", "normal")
    platform = context.user_data.get("platform", "playstation")
    price = SellConversationHandler.calculate_price(amount, transfer_type)

    # Ø¹Ø±Ø¶ Ù…Ù„Ø®Øµ Ø§Ù„Ø¨ÙŠØ¹
    summary = _create_sale_summary(user_id, amount, transfer_type, platform, price)
    await update.message.reply_text(summary, parse_mode="Markdown")

    # Ù…Ø³Ø­ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© ÙˆØ¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
    context.user_data.clear()
    return ConversationHandler.END


def _create_sale_summary(user_id, amount, transfer_type, platform, price):
    """Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ø®Øµ Ø§Ù„Ø¨ÙŠØ¹"""
    formatted_amount = SellConversationHandler.format_amount(amount)
    type_name = SellConversationHandler.get_transfer_type_name(transfer_type)
    platform_name = SellConversationHandler.get_platform_name(platform)

    # Ø¬Ù„Ø¨ Ø³Ø¹Ø± Ø§Ù„Ù…Ù„ÙŠÙˆÙ† ÙƒÙ…Ø±Ø¬Ø¹ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… - Ù…Ø¹ fallback Ù„Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
    million_price = CoinSellPricing.get_price(platform, 1000000, transfer_type)

    # Ø¥Ø°Ø§ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø¹Ø±ØŒ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø©
    if million_price is None:
        # Ø£Ø³Ø¹Ø§Ø± Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø«Ø§Ø¨ØªØ© (Ù†ÙØ³ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ù…Ù† sell_pricing.py)
        default_prices = {
            "normal": {"playstation": 5600, "xbox": 5600, "pc": 6100},
            "instant": {"playstation": 5300, "xbox": 5300, "pc": 5800},
        }
        million_price = default_prices.get(transfer_type, {}).get(platform, 5600)

    # ØªÙ†Ø³ÙŠÙ‚ Ø³Ø¹Ø± Ø§Ù„Ù…Ù„ÙŠÙˆÙ† Ù…Ø¹ ÙÙˆØ§ØµÙ„
    million_price_formatted = f"{million_price:,}"

    return (
        "ğŸ‰ **ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø·Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ¹ Ø¨Ù†Ø¬Ø§Ø­!**\n\n"
        f"ğŸ“Š **ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø·Ù„Ø¨:**\n"
        f"ğŸ® Ø§Ù„Ù…Ù†ØµØ©: {platform_name}\n"
        f"ğŸ’° Ø§Ù„ÙƒÙ…ÙŠØ©: {formatted_amount} ÙƒÙˆÙŠÙ†\n"
        f"ğŸ’µ Ø§Ù„Ø³Ø¹Ø±: {price} Ø¬Ù†ÙŠÙ‡\n"
        f"â­ (Ø³Ø¹Ø± Ø§Ù„Ù…Ù„ÙŠÙˆÙ†: {million_price_formatted} Ø¬Ù†ÙŠÙ‡)\n"
        f"â° Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„: {type_name}\n\n"
        "ğŸ“ **Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©:**\n"
        "1ï¸âƒ£ Ø³ÙŠØªÙ… Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ Ø®Ù„Ø§Ù„ Ø¯Ù‚Ø§Ø¦Ù‚\n"
        "2ï¸âƒ£ ØªØ³Ù„ÙŠÙ… Ø§Ù„ÙƒÙˆÙŠÙ†Ø² Ù„Ù„Ù…Ù…Ø«Ù„\n"
        "3ï¸âƒ£ Ø§Ø³ØªÙ„Ø§Ù… Ø§Ù„Ù…Ø¨Ù„Øº Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„\n\n"
        "âœ… **ØªÙ… Ø­ÙØ¸ Ø·Ù„Ø¨Ùƒ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…**\n"
        f"ğŸ†” **Ø±Ù‚Ù… Ø§Ù„Ø·Ù„Ø¨:** #{user_id}{amount}\n\n"
        "ğŸ’¬ **Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±:** /sell\n"
        "ğŸ  **Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:** /start"
    )


async def sell_conversation_cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¥Ù„ØºØ§Ø¡ Ù…Ø­Ø§Ø¯Ø«Ø© Ø§Ù„Ø¨ÙŠØ¹"""
    await update.message.reply_text(
        "âœ… **ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¨ÙŠØ¹**\n\nÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… /sell",
        parse_mode="Markdown",
    )
    context.user_data.clear()
    return ConversationHandler.END


# ================================ Ø¥Ø¹Ø¯Ø§Ø¯ Ù…Ø­Ø§Ø¯Ø«Ø© Ø§Ù„Ø¨ÙŠØ¹ ================================
def get_sell_conversation_handler():
    """Ø¥Ø±Ø¬Ø§Ø¹ Ù…Ø¹Ø§Ù„Ø¬ Ù…Ø­Ø§Ø¯Ø«Ø© Ø§Ù„Ø¨ÙŠØ¹"""
    return ConversationHandler(
        entry_points=[CallbackQueryHandler(sell_coins_start, pattern="^sell_fc26$")],
        states={
            SellStates.CHOOSE_PLATFORM: [
                CallbackQueryHandler(
                    platform_chosen,
                    pattern="^(platform_playstation|platform_xbox|platform_pc|cancel_sell)$",
                )
            ],
            SellStates.CHOOSE_TYPE: [
                CallbackQueryHandler(
                    sell_type_chosen,
                    pattern="^(type_instant|type_normal|cancel_sell)$",
                )
            ],
            SellStates.ENTER_AMOUNT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, sell_amount_entered)
            ],
        },
        fallbacks=[CommandHandler("cancel", sell_conversation_cancel)],
    )


--- FC26_sale_coins_Bot/services/sell_coins/sell_conversation_handler.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ’° SELL COINS - CONVERSATION HANDLER                        â•‘
# â•‘                   Ø®Ø¯Ù…Ø© Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø² - Ù…Ø¹ bucket Ùˆ persistence            â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Ø®Ø¯Ù…Ø© Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø² Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… ConversationHandler
- Ù…Ø¹ Ù†Ø¸Ø§Ù… ÙˆØ³Ù… Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ (MessageTagger)
- Ù…Ø¹ Ù†Ø¸Ø§Ù… Ø¹Ø²Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (Session Buckets)
- Ù…Ø¹ Persistence
"""

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import (
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
    ConversationHandler,
    MessageHandler,
    filters,
)

from database.operations import UserOperations
from utils.logger import log_user_action
from utils.message_tagger import MessageTagger
from utils.session_bucket import bucket, clear_bucket

from .sell_pricing import CoinSellPricing

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# STATES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SELL_PLATFORM, SELL_TYPE, SELL_AMOUNT = range(3)


class SellCoinsConversation:
    """Ù…Ø¹Ø§Ù„Ø¬ Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø² - Ù…Ø¹ bucket"""

    @staticmethod
    async def start_sell(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¨ÙŠØ¹ - /sell"""
        MessageTagger.mark_as_handled(context)

        user_id = update.effective_user.id
        log_user_action(user_id, "Started coin selling service")

        print(f"\nğŸ’° [SELL] Service started for user {user_id}")

        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØ³Ø¬ÙŠÙ„
        user_data = UserOperations.get_user_data(user_id)
        if not user_data or user_data.get("registration_step") != "completed":
            await update.message.reply_text(
                "âŒ <b>ÙŠØ¬Ø¨ Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø£ÙˆÙ„Ø§Ù‹!</b>\n\nğŸš€ /start Ù„Ù„ØªØ³Ø¬ÙŠÙ„",
                parse_mode="HTML",
            )
            return ConversationHandler.END

        # Ø¹Ø±Ø¶ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù†ØµØ©
        keyboard = [
            [
                InlineKeyboardButton(
                    "ğŸ® PlayStation", callback_data="sell_platform_playstation"
                )
            ],
            [InlineKeyboardButton("ğŸ® Xbox", callback_data="sell_platform_xbox")],
            [InlineKeyboardButton("ğŸ–¥ï¸ PC", callback_data="sell_platform_pc")],
            [InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="sell_cancel")],
        ]

        await update.message.reply_text(
            "ğŸ’° <b>Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²</b>\n\nğŸ® Ø§Ø®ØªØ± Ù…Ù†ØµØªÙƒ:",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="HTML",
        )

        return SELL_PLATFORM

    @staticmethod
    async def choose_platform(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù†ØµØ©"""
        MessageTagger.mark_as_handled(context)

        query = update.callback_query
        await query.answer()

        if query.data == "sell_cancel":
            await query.edit_message_text("âŒ ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¨ÙŠØ¹")
            return ConversationHandler.END

        user_id = query.from_user.id
        platform = query.data.replace("sell_platform_", "")

        print(f"ğŸ® [SELL] User {user_id} selected platform: {platform}")

        # ğŸ”¥ Ø§Ø³ØªØ®Ø¯Ø§Ù… bucket Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† context.user_data
        bucket(context, "sell")["platform"] = platform
        log_user_action(user_id, f"Selected platform: {platform}")

        # Ø¹Ø±Ø¶ Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ù…Ø¹ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±
        transfer_message = CoinSellPricing.get_platform_pricing_message(platform)

        # Ø¬Ù„Ø¨ Ø£Ø³Ø¹Ø§Ø± 1M
        normal_price = CoinSellPricing.get_price(platform, 1000000, "normal")
        instant_price = CoinSellPricing.get_price(platform, 1000000, "instant")

        normal_formatted = f"{normal_price:,} Ø¬.Ù…" if normal_price else "ØºÙŠØ± Ù…ØªØ§Ø­"
        instant_formatted = f"{instant_price:,} Ø¬.Ù…" if instant_price else "ØºÙŠØ± Ù…ØªØ§Ø­"

        keyboard = [
            [
                InlineKeyboardButton(
                    f"ğŸ“… ØªØ­ÙˆÙŠÙ„ Ø¹Ø§Ø¯ÙŠ - {normal_formatted}",
                    callback_data=f"sell_type_normal",
                )
            ],
            [
                InlineKeyboardButton(
                    f"âš¡ ØªØ­ÙˆÙŠÙ„ ÙÙˆØ±ÙŠ - {instant_formatted}",
                    callback_data=f"sell_type_instant",
                )
            ],
            [InlineKeyboardButton("ğŸ”™ Ø±Ø¬ÙˆØ¹", callback_data="sell_back")],
        ]

        await query.edit_message_text(
            transfer_message,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="Markdown",
        )

        return SELL_TYPE

    @staticmethod
    async def choose_type(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ø§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„"""
        MessageTagger.mark_as_handled(context)

        query = update.callback_query
        await query.answer()

        if query.data == "sell_back":
            keyboard = [
                [
                    InlineKeyboardButton(
                        "ğŸ® PlayStation", callback_data="sell_platform_playstation"
                    )
                ],
                [InlineKeyboardButton("ğŸ® Xbox", callback_data="sell_platform_xbox")],
                [InlineKeyboardButton("ğŸ–¥ï¸ PC", callback_data="sell_platform_pc")],
                [InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="sell_cancel")],
            ]

            await query.edit_message_text(
                "ğŸ’° <b>Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²</b>\n\nğŸ® Ø§Ø®ØªØ± Ù…Ù†ØµØªÙƒ:",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="HTML",
            )
            return SELL_PLATFORM

        user_id = query.from_user.id
        transfer_type = query.data.replace("sell_type_", "")

        # ğŸ”¥ Ø§Ø³ØªØ®Ø¯Ø§Ù… bucket
        sell_bucket = bucket(context, "sell")
        platform = sell_bucket.get("platform", "unknown")

        print(f"âš¡ [SELL] User {user_id} selected type: {transfer_type}")

        # ğŸ”¥ Ø­ÙØ¸ ÙÙŠ bucket
        sell_bucket["type"] = transfer_type
        log_user_action(
            user_id, f"Selected transfer type: {transfer_type} for {platform}"
        )

        platform_name = {
            "playstation": "ğŸ® PlayStation",
            "xbox": "ğŸ® Xbox",
            "pc": "ğŸ–¥ï¸ PC",
        }.get(platform, platform)

        transfer_name = "âš¡ ÙÙˆØ±ÙŠ" if transfer_type == "instant" else "ğŸ“… Ø¹Ø§Ø¯ÙŠ"

        await query.edit_message_text(
            f"âœ… **ØªÙ… Ø§Ø®ØªÙŠØ§Ø± {platform_name} - {transfer_name}**\n\n"
            f"ğŸ’° **Ø£Ø¯Ø®Ù„ ÙƒÙ…ÙŠØ© Ø§Ù„ÙƒÙˆÙŠÙ†Ø² Ù„Ù„Ø¨ÙŠØ¹:**\n\n"
            f"ğŸ“ **Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„:**\n"
            f"â€¢ Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø· (Ø¨Ø¯ÙˆÙ† Ø­Ø±ÙˆÙ Ø£Ùˆ Ø±Ù…ÙˆØ²)\n"
            f"â€¢ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰: 50 ÙƒÙˆÙŠÙ†\n"
            f"â€¢ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰: 20,000 ÙƒÙˆÙŠÙ†\n\n"
            f"ğŸ’¡ **Ù…Ø«Ø§Ù„:** 500 Ø£Ùˆ 1500 Ø£Ùˆ 5000\n\n"
            f"Ø§ÙƒØªØ¨ Ø§Ù„ÙƒÙ…ÙŠØ© Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù…:\n\n"
            f"âŒ Ù„Ù„Ø¥Ù„ØºØ§Ø¡: /cancel",
            parse_mode="Markdown",
        )

        return SELL_AMOUNT

    @staticmethod
    async def enter_amount(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„ÙƒÙ…ÙŠØ©"""
        MessageTagger.mark_as_handled(context)

        user_id = update.effective_user.id
        text = update.message.text.strip()

        print(f"ğŸ’° [SELL] Amount input from user {user_id}: {text}")

        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØµÙŠØºØ©
        if not text.isdigit():
            print(f"   âŒ [SELL] Invalid format: {text}")
            await update.message.reply_text(
                "âŒ **ØµÙŠØºØ© ØºÙŠØ± ØµØ­ÙŠØ­Ø©!**\n\n"
                "âœ… **Ø§Ù„Ù…Ø·Ù„ÙˆØ¨:** Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·\n"
                "ğŸš« **Ù…Ù…Ù†ÙˆØ¹:** Ø­Ø±ÙˆÙØŒ Ø±Ù…ÙˆØ²ØŒ kØŒ m\n\n"
                "ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„ÙƒÙ…ÙŠØ© Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù…:",
                parse_mode="Markdown",
            )
            return SELL_AMOUNT

        amount = int(text)

        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¯ÙˆØ¯
        if amount < 50:
            print(f"   âŒ [SELL] Amount too low: {amount}")
            await update.message.reply_text(
                f"âŒ **Ø§Ù„ÙƒÙ…ÙŠØ© Ù‚Ù„ÙŠÙ„Ø© Ø¬Ø¯Ø§Ù‹!**\n\n"
                f"ğŸ“ **Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰:** 50 ÙƒÙˆÙŠÙ†\n"
                f"Ø£Ù†Øª Ø£Ø¯Ø®Ù„Øª: {amount} ÙƒÙˆÙŠÙ†\n\n"
                f"ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ ÙƒÙ…ÙŠØ© Ø£ÙƒØ¨Ø±:",
                parse_mode="Markdown",
            )
            return SELL_AMOUNT

        if amount > 20000:
            print(f"   âŒ [SELL] Amount too high: {amount}")
            await update.message.reply_text(
                f"âŒ **Ø§Ù„ÙƒÙ…ÙŠØ© ÙƒØ¨ÙŠØ±Ø© Ø¬Ø¯Ø§Ù‹!**\n\n"
                f"ğŸ“ **Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰:** 20,000 ÙƒÙˆÙŠÙ†\n"
                f"Ø£Ù†Øª Ø£Ø¯Ø®Ù„Øª: {amount:,} ÙƒÙˆÙŠÙ†\n\n"
                f"Ù„Ø¨ÙŠØ¹ ÙƒÙ…ÙŠØ§Øª Ø£ÙƒØ¨Ø±ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù….",
                parse_mode="Markdown",
            )
            return SELL_AMOUNT

        # ğŸ”¥ Ø§Ø³ØªØ®Ø¯Ø§Ù… bucket
        sell_bucket = bucket(context, "sell")
        platform = sell_bucket.get("platform", "playstation")
        transfer_type = sell_bucket.get("type", "normal")

        price = SellCoinsConversation.calculate_price(amount, transfer_type)

        print(f"âœ… [SELL] Valid amount: {amount}, calculated price: {price}")

        platform_name = {
            "playstation": "ğŸ® PlayStation",
            "xbox": "ğŸ® Xbox",
            "pc": "ğŸ–¥ï¸ PC",
        }.get(platform, platform)

        transfer_name = "âš¡ ÙÙˆØ±ÙŠ" if transfer_type == "instant" else "ğŸ“… Ø¹Ø§Ø¯ÙŠ"

        million_price = CoinSellPricing.get_price(platform, 1000000, transfer_type)
        if million_price is None:
            default_prices = {
                "normal": {"playstation": 5600, "xbox": 5600, "pc": 6100},
                "instant": {"playstation": 5300, "xbox": 5300, "pc": 5800},
            }
            million_price = default_prices.get(transfer_type, {}).get(platform, 5600)

        await update.message.reply_text(
            f"ğŸ‰ **ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø·Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ¹ Ø¨Ù†Ø¬Ø§Ø­!**\n\n"
            f"ğŸ“Š **ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø·Ù„Ø¨:**\n"
            f"ğŸ® Ø§Ù„Ù…Ù†ØµØ©: {platform_name}\n"
            f"ğŸ’° Ø§Ù„ÙƒÙ…ÙŠØ©: {amount:,} ÙƒÙˆÙŠÙ†\n"
            f"ğŸ’µ Ø§Ù„Ø³Ø¹Ø±: {price} Ø¬Ù†ÙŠÙ‡\n"
            f"â­ (Ø³Ø¹Ø± Ø§Ù„Ù…Ù„ÙŠÙˆÙ†: {million_price:,} Ø¬Ù†ÙŠÙ‡)\n"
            f"â° Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„: {transfer_name}\n\n"
            f"ğŸ“ **Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©:**\n"
            f"1ï¸âƒ£ Ø³ÙŠØªÙ… Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ Ø®Ù„Ø§Ù„ Ø¯Ù‚Ø§Ø¦Ù‚\n"
            f"2ï¸âƒ£ ØªØ³Ù„ÙŠÙ… Ø§Ù„ÙƒÙˆÙŠÙ†Ø² Ù„Ù„Ù…Ù…Ø«Ù„\n"
            f"3ï¸âƒ£ Ø§Ø³ØªÙ„Ø§Ù… Ø§Ù„Ù…Ø¨Ù„Øº Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„\n\n"
            f"âœ… **ØªÙ… Ø­ÙØ¸ Ø·Ù„Ø¨Ùƒ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…**\n"
            f"ğŸ†” **Ø±Ù‚Ù… Ø§Ù„Ø·Ù„Ø¨:** #{user_id}{amount}\n\n"
            f"ğŸ’¬ **Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±:** /sell\n"
            f"ğŸ  **Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:** /start",
            parse_mode="Markdown",
        )

        log_user_action(
            user_id,
            f"Completed sell order: {amount} coins, {transfer_type}, {price} EGP",
        )

        # ğŸ”¥ Ù…Ø³Ø­ bucket ÙÙ‚Ø·
        clear_bucket(context, "sell")
        print(f"ğŸ§¹ [SELL] Session cleared for user {user_id}")

        return ConversationHandler.END

    @staticmethod
    async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©"""
        MessageTagger.mark_as_handled(context)

        user_id = update.effective_user.id
        print(f"âŒ [SELL] User {user_id} cancelled sell service")

        await update.message.reply_text(
            "âŒ ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¨ÙŠØ¹\n\nğŸ”¹ /sell Ù„Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯"
        )

        # ğŸ”¥ Ù…Ø³Ø­ bucket ÙÙ‚Ø·
        clear_bucket(context, "sell")
        log_user_action(user_id, "Cancelled coin selling")

        return ConversationHandler.END

    @staticmethod
    def calculate_price(amount: int, transfer_type: str = "normal") -> int:
        """Ø­Ø³Ø§Ø¨ Ø§Ù„Ø³Ø¹Ø± Ø­Ø³Ø¨ Ø§Ù„ÙƒÙ…ÙŠØ© ÙˆÙ†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„"""
        base_price_per_1000 = 5
        base_price = (amount / 1000) * base_price_per_1000

        if transfer_type == "instant":
            base_price *= 1.2

        return int(base_price)

    @staticmethod
    def get_conversation_handler():
        """Ø¥Ù†Ø´Ø§Ø¡ ConversationHandler Ù„Ù„Ø®Ø¯Ù…Ø©"""
        return ConversationHandler(
            entry_points=[CommandHandler("sell", SellCoinsConversation.start_sell)],
            states={
                SELL_PLATFORM: [
                    CallbackQueryHandler(
                        SellCoinsConversation.choose_platform,
                        pattern="^sell_platform_|^sell_cancel$",
                    )
                ],
                SELL_TYPE: [
                    CallbackQueryHandler(
                        SellCoinsConversation.choose_type,
                        pattern="^sell_type_|^sell_back$",
                    )
                ],
                SELL_AMOUNT: [
                    MessageHandler(
                        filters.TEXT & ~filters.COMMAND,
                        SellCoinsConversation.enter_amount,
                    )
                ],
            },
            fallbacks=[CommandHandler("cancel", SellCoinsConversation.cancel)],
            name="sell_coins_conversation",
            persistent=True,  # ğŸ”¥ ØªÙØ¹ÙŠÙ„ Persistence
            block=True,
        )


--- FC26_sale_coins_Bot/services/sell_coins/sell_handler.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ¯ FC26 COIN SELLING HANDLER - Ù…Ø¹Ø§Ù„Ø¬ Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²            â•‘
# â•‘                    Main Coin Selling Handler                            â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import logging
import re
from typing import Dict, List, Optional

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import (
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    filters,
)

from database.operations import UserOperations

# Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ù…Ù† Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
from utils.logger import log_user_action

from .sell_keyboards import SellKeyboards
from .sell_messages import SellMessages
from .sell_pricing import CoinSellPricing, Platform

logger = logging.getLogger(__name__)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CUSTOM FILTER - SMART SELL SESSION DETECTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


class SellSessionFilter(filters.MessageFilter):
    """
    ÙÙ„ØªØ± Ø°ÙƒÙŠ Ù„Ø®Ø¯Ù…Ø© Ø§Ù„Ø¨ÙŠØ¹: ÙŠØ³Ù…Ø­ Ø¨Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ ÙÙ‚Ø· Ø¥Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¹Ù†Ø¯Ù‡ session Ø¨ÙŠØ¹ Ù†Ø´Ø·
    """

    def __init__(self, session_storage: dict):
        """
        Args:
            session_storage: Ù…Ø±Ø¬Ø¹ Ù„Ù€ self.user_sessions
        """
        self.session_storage = session_storage
        super().__init__()

    def filter(self, message):
        """
        Ø¨ØªØ±Ø¬Ø¹ True ÙÙ‚Ø· Ø¥Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¹Ù†Ø¯Ù‡ session Ø¨ÙŠØ¹ Ù†Ø´Ø·
        """
        user_id = message.from_user.id

        # Ù„Ùˆ Ù…ÙÙŠØ´ sessionØŒ return False Ø¹Ø´Ø§Ù† Ø§Ù„Ø±Ø³Ø§Ù„Ø© ØªØ¹Ø¯ÙŠ Ù„Ù„Ù€ handler Ø§Ù„ØªØ§Ù†ÙŠ
        if user_id not in self.session_storage:
            return False

        session = self.session_storage[user_id]

        # Ù„Ùˆ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø´ ÙÙŠ Ø®Ø·ÙˆØ© Ø¥Ø¯Ø®Ø§Ù„ Ù†ØµØŒ return False
        if session.get("step") not in ["custom_amount_input", "amount_input"]:
            return False

        # Ù„Ùˆ ÙƒÙ„ Ø´ÙŠØ¡ ØªÙ…Ø§Ù…ØŒ return True
        return True


class SellCoinsHandler:
    """Ù…Ø¹Ø§Ù„Ø¬ Ø®Ø¯Ù…Ø© Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø² Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ"""

    def __init__(self):
        """ØªÙ‡ÙŠØ¦Ø© Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø¨ÙŠØ¹"""
        self.user_sessions = {}  # Ø¬Ù„Ø³Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù†Ø´Ø·Ø©
        self.pending_sales = {}  # Ø§Ù„Ø¨ÙŠÙˆØ¹Ø§Øª Ø§Ù„Ù…Ø¹Ù„Ù‚Ø©

        # ğŸ”¥ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙÙ„ØªØ± Ø§Ù„Ø°ÙƒÙŠ
        self.smart_filter = SellSessionFilter(session_storage=self.user_sessions)

    def get_handlers(self) -> List:
        """Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø®Ø¯Ù…Ø© Ø§Ù„Ø¨ÙŠØ¹"""
        return [
            CommandHandler("sell", self.handle_sell_command),
            CallbackQueryHandler(
                self.handle_platform_selection, pattern="^sell_platform_"
            ),
            CallbackQueryHandler(
                self.handle_transfer_type_selection, pattern="^sell_transfer_"
            ),
            CallbackQueryHandler(self.handle_custom_amount, pattern="^sell_custom_"),
            CallbackQueryHandler(
                self.handle_price_confirmation, pattern="^sell_confirm_"
            ),
            CallbackQueryHandler(self.handle_sale_instructions, pattern="^sell_ready_"),
            CallbackQueryHandler(
                self.handle_payment_selection, pattern="^sell_payment_"
            ),
            CallbackQueryHandler(self.handle_navigation, pattern="^sell_back_"),
            CallbackQueryHandler(self.handle_help, pattern="^sell_help"),
            CallbackQueryHandler(self.handle_cancel, pattern="^sell_cancel"),
            CallbackQueryHandler(self.handle_support, pattern="^sell_support"),
            # âŒ ØªÙ… Ø¥Ø²Ø§Ù„Ø© MessageHandler Ù…Ù† Ù‡Ù†Ø§ - Ø³ÙŠØªÙ… ØªØ³Ø¬ÙŠÙ„Ù‡ Ù…Ù†ÙØµÙ„Ø§Ù‹ Ù…Ø¹ Ø§Ù„ÙÙ„ØªØ± Ø§Ù„Ø°ÙƒÙŠ
        ]

    def get_sell_text_filter(self):
        """Ø¬Ù„Ø¨ Ø§Ù„ÙÙ„ØªØ± Ø§Ù„Ø°ÙƒÙŠ Ù„Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù†ØµÙŠØ©"""
        return self.smart_filter

    async def handle_sell_command(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ù…Ø± /sell"""
        user_id = update.effective_user.id
        log_user_action(user_id, "Started coin selling service")

        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        user_data = UserOperations.get_user_data(user_id)
        if not user_data:
            await update.message.reply_text(
                "âŒ <b>ÙŠØ¬Ø¨ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø£ÙˆÙ„Ø§Ù‹!</b>\n\nğŸš€ Ø§Ø³ØªØ®Ø¯Ù… /start Ù„Ù„ØªØ³Ø¬ÙŠÙ„ Ù‚Ø¨Ù„ Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²",
                parse_mode="HTML",
            )
            return

        # Ø¨Ø¯Ø¡ Ø¬Ù„Ø³Ø© Ø¨ÙŠØ¹ Ø¬Ø¯ÙŠØ¯Ø©
        self.user_sessions[user_id] = {
            "step": "platform_selection",
            "platform": None,
            "coins": None,
            "price": None,
            "started_at": update.message.date,
        }

        # Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ±Ø­ÙŠØ¨
        welcome_message = SellMessages.get_welcome_sell_message()
        keyboard = SellKeyboards.get_main_sell_keyboard()

        await update.message.reply_text(
            welcome_message, reply_markup=keyboard, parse_mode="HTML"
        )

    async def handle_platform_selection(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù†ØµØ©"""
        query = update.callback_query
        user_id = query.from_user.id

        await query.answer()

        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ù†ØµØ© Ù…Ù† callback_data
        platform = query.data.replace("sell_platform_", "")

        # Ø­ÙØ¸ Ø§Ù„Ù…Ù†ØµØ© ÙÙŠ Ø§Ù„Ø¬Ù„Ø³Ø©
        if user_id not in self.user_sessions:
            self.user_sessions[user_id] = {}

        self.user_sessions[user_id].update(
            {"step": "transfer_type_selection", "platform": platform}
        )

        log_user_action(user_id, f"Selected platform: {platform}")

        # Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø¨Ø³ÙŠØ·Ø©
        transfer_message = CoinSellPricing.get_platform_pricing_message(platform)

        # Ø¬Ù„Ø¨ Ø£Ø³Ø¹Ø§Ø± 1M Ù„Ù„Ø£Ø²Ø±Ø§Ø±
        normal_price = CoinSellPricing.get_price(platform, 1000000, "normal")
        instant_price = CoinSellPricing.get_price(platform, 1000000, "instant")

        normal_formatted = f"{normal_price:,} Ø¬.Ù…" if normal_price else "ØºÙŠØ± Ù…ØªØ§Ø­"
        instant_formatted = f"{instant_price:,} Ø¬.Ù…" if instant_price else "ØºÙŠØ± Ù…ØªØ§Ø­"

        keyboard = [
            [
                InlineKeyboardButton(
                    f"ğŸ“… ØªØ­ÙˆÙŠÙ„ Ø¹Ø§Ø¯ÙŠ - {normal_formatted}",
                    callback_data=f"sell_transfer_normal_{platform}",
                )
            ],
            [
                InlineKeyboardButton(
                    f"âš¡ï¸ ØªØ­ÙˆÙŠÙ„ ÙÙˆØ±ÙŠ - {instant_formatted}",
                    callback_data=f"sell_transfer_instant_{platform}",
                )
            ],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            transfer_message, reply_markup=reply_markup, parse_mode="Markdown"
        )

    async def handle_transfer_type_selection(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„"""
        query = update.callback_query
        user_id = query.from_user.id

        await query.answer()

        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„ ÙˆØ§Ù„Ù…Ù†ØµØ© Ù…Ù† callback_data
        # ØªÙ†Ø³ÙŠÙ‚: sell_transfer_{transfer_type}_{platform}
        parts = query.data.split("_")
        if len(parts) >= 4:
            transfer_type = parts[2]  # instant Ø£Ùˆ normal
            platform = parts[3]

            # Ø­ÙØ¸ Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„ ÙÙŠ Ø§Ù„Ø¬Ù„Ø³Ø©
            self.user_sessions[user_id].update(
                {
                    "step": "amount_input",
                    "transfer_type": transfer_type,
                    "platform": platform,
                }
            )

            log_user_action(
                user_id, f"Selected transfer type: {transfer_type} for {platform}"
            )

            # Ø¥Ø¹Ø¯Ø§Ø¯ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø¹Ø±Ø¶
            platform_name = {
                "playstation": "ğŸ® PlayStation",
                "xbox": "ğŸ® Xbox",
                "pc": "ğŸ–¥ï¸ PC",
            }.get(platform, platform)
            transfer_name = "âš¡ ÙÙˆØ±ÙŠ" if transfer_type == "instant" else "ğŸ“… Ø¹Ø§Ø¯ÙŠ"

            # Ø±Ø³Ø§Ù„Ø© Ø·Ù„Ø¨ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„ÙƒÙ…ÙŠØ©
            amount_message = f"""âœ… **ØªÙ… Ø§Ø®ØªÙŠØ§Ø± {platform_name} - {transfer_name}**

ğŸ’° **Ø£Ø¯Ø®Ù„ ÙƒÙ…ÙŠØ© Ø§Ù„ÙƒÙˆÙŠÙ†Ø² Ù„Ù„Ø¨ÙŠØ¹:**

ğŸ“ **Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„:**
â€¢ Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø· (Ø¨Ø¯ÙˆÙ† Ø­Ø±ÙˆÙ Ø£Ùˆ Ø±Ù…ÙˆØ²)
â€¢ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰: 2 Ø£Ø±Ù‚Ø§Ù… (Ù…Ø«Ø§Ù„: 50)
â€¢ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰: 5 Ø£Ø±Ù‚Ø§Ù… (Ù…Ø«Ø§Ù„: 20000)
â€¢ Ù…Ù…Ù†ÙˆØ¹ Ø§Ø³ØªØ®Ø¯Ø§Ù… k Ø£Ùˆ m

ğŸ’¡ **Ø£Ù…Ø«Ù„Ø© ØµØ­ÙŠØ­Ø©:** 500ØŒ 1500ØŒ 20000

Ø§ÙƒØªØ¨ Ø§Ù„ÙƒÙ…ÙŠØ© Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø§Ø¯ÙŠØ©:"""

            reply_markup = None

            await query.edit_message_text(
                amount_message, reply_markup=reply_markup, parse_mode="Markdown"
            )

    async def handle_custom_amount(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨ ÙƒÙ…ÙŠØ© Ù…Ø®ØµØµØ©"""
        query = update.callback_query
        user_id = query.from_user.id

        await query.answer()

        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ù†ØµØ©
        platform = query.data.replace("sell_custom_", "")

        # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¬Ù„Ø³Ø©
        self.user_sessions[user_id].update(
            {"step": "custom_amount_input", "platform": platform}
        )

        log_user_action(user_id, f"Requested custom amount for {platform}")

        # Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø·Ù„Ø¨ Ø§Ù„ÙƒÙ…ÙŠØ© Ø§Ù„Ù…Ø®ØµØµØ©
        custom_message = SellMessages.get_custom_amount_message(platform)
        keyboard = SellKeyboards.get_custom_amount_cancel_keyboard(platform)

        await query.edit_message_text(
            custom_message, reply_markup=keyboard, parse_mode="HTML"
        )

    async def handle_text_input(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù†Øµ Ø§Ù„Ù…ÙØ¯Ø®Ù„ (Ù„Ù„ÙƒÙ…ÙŠØ© Ø§Ù„Ù…Ø®ØµØµØ©)"""
        user_id = update.effective_user.id

        # âœ… Ø§Ù„ÙÙ„ØªØ± Ø¶Ù…Ù† Ø¥Ù†Ù†Ø§ Ù‡Ù†Ø§ ÙÙ‚Ø· Ù„Ùˆ ÙÙŠ sessionØŒ Ø¨Ø³ Ù„Ù„ØªØ£ÙƒÙŠØ¯:
        if user_id not in self.user_sessions:
            print(f"âš ï¸ [SELL] No active session (filter should have caught this)")
            return

        session = self.user_sessions[user_id]

        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
        if session.get("step") not in ["custom_amount_input", "amount_input"]:
            return

        text = update.message.text.strip()
        platform = session.get("platform")
        transfer_type = session.get("transfer_type", "normal")

        # ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙƒÙ…ÙŠØ© Ø§Ù„Ù…Ø¯Ø®Ù„Ø©
        amount = self.parse_amount(text)

        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØµÙŠØºØ© Ø§Ù„Ø®Ø§Ø·Ø¦Ø© (k Ø£Ùˆ m)
        if amount == "invalid_format":
            await update.message.reply_text(
                "âŒ **ØµÙŠØºØ© ØºÙŠØ± ØµØ­ÙŠØ­Ø©!**\n\n"
                "ğŸš« **Ù…Ù…Ù†ÙˆØ¹ Ø§Ø³ØªØ®Ø¯Ø§Ù… k Ø£Ùˆ m**\n\n"
                "âœ… **Ø§Ù„Ù…Ø·Ù„ÙˆØ¨:** Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø· (2-5 Ø£Ø±Ù‚Ø§Ù…)\n"
                "ğŸ“ **Ù…Ø«Ø§Ù„ ØµØ­ÙŠØ­:** 500 Ø£Ùˆ 1500 Ø£Ùˆ 20000\n\n"
                "ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„ÙƒÙ…ÙŠØ© Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø§Ø¯ÙŠØ© ÙÙ‚Ø·:",
                parse_mode="Markdown",
            )
            return

        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø·ÙˆÙ„ Ø§Ù„Ø±Ù‚Ù…
        if amount == "invalid_length":
            await update.message.reply_text(
                "âŒ **Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ØºÙŠØ± ØµØ­ÙŠØ­!**\n\n"
                "ğŸ“ **Ø§Ù„Ù…Ø·Ù„ÙˆØ¨:**\n"
                "â€¢ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰: 2 Ø£Ø±Ù‚Ø§Ù… (Ù…Ø«Ø§Ù„: 50)\n"
                "â€¢ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰: 5 Ø£Ø±Ù‚Ø§Ù… (Ù…Ø«Ø§Ù„: 20000)\n\n"
                f"Ø£Ù†Øª Ø£Ø¯Ø®Ù„Øª: {len(text)} Ø£Ø±Ù‚Ø§Ù…\n\n"
                "ğŸ“ **Ø£Ù…Ø«Ù„Ø© ØµØ­ÙŠØ­Ø©:** 500ØŒ 1500ØŒ 20000\n\n"
                "ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø¨ÙŠÙ† 2-5 Ø£Ø±Ù‚Ø§Ù…:",
                parse_mode="Markdown",
            )
            return

        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„ØµÙŠØºØ© Ø§Ù„Ø¹Ø§Ù…Ø©
        if amount is None:
            await update.message.reply_text(
                "âŒ **ØµÙŠØºØ© ØºÙŠØ± ØµØ­ÙŠØ­Ø©!**\n\n"
                "âœ… **Ø§Ù„Ù…Ø·Ù„ÙˆØ¨:** Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø· (2-5 Ø£Ø±Ù‚Ø§Ù…)\n"
                "ğŸš« **Ù…Ù…Ù†ÙˆØ¹:** Ø­Ø±ÙˆÙØŒ Ø±Ù…ÙˆØ²ØŒ kØŒ m\n\n"
                "ğŸ“ **Ø£Ù…Ø«Ù„Ø© ØµØ­ÙŠØ­Ø©:**\n"
                "â€¢ 500 \n"
                "â€¢ 1500 \n"
                "â€¢ 20000\n\n"
                "ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰:",
                parse_mode="Markdown",
            )
            return

        # ØªØ¹Ø±ÙŠÙ Ø§Ù„Ø­Ø¯ÙˆØ¯ Ø§Ù„ÙØ¹Ù„ÙŠØ©
        MIN_SELL_AMOUNT = 50  # 50 ÙƒÙˆÙŠÙ†
        MAX_SELL_AMOUNT = 20000  # 20000 ÙƒÙˆÙŠÙ†

        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¯ÙˆØ¯
        if amount < MIN_SELL_AMOUNT:
            await update.message.reply_text(
                f"âŒ **Ø§Ù„ÙƒÙ…ÙŠØ© Ù‚Ù„ÙŠÙ„Ø© Ø¬Ø¯Ø§Ù‹!**\n\n"
                f"ğŸ“ **Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰:** {self.format_amount(MIN_SELL_AMOUNT)} ÙƒÙˆÙŠÙ†\n"
                f"Ø£Ù†Øª Ø£Ø¯Ø®Ù„Øª: {self.format_amount(amount)} ÙƒÙˆÙŠÙ†\n\n"
                "ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ ÙƒÙ…ÙŠØ© Ø£ÙƒØ¨Ø±:",
                parse_mode="Markdown",
            )
            return

        if amount > MAX_SELL_AMOUNT:
            await update.message.reply_text(
                f"âŒ **Ø§Ù„ÙƒÙ…ÙŠØ© ÙƒØ¨ÙŠØ±Ø© Ø¬Ø¯Ø§Ù‹!**\n\n"
                f"ğŸ“ **Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰:** {self.format_amount(MAX_SELL_AMOUNT)} ÙƒÙˆÙŠÙ†\n"
                f"Ø£Ù†Øª Ø£Ø¯Ø®Ù„Øª: {self.format_amount(amount)} ÙƒÙˆÙŠÙ†\n\n"
                "Ù„Ø¨ÙŠØ¹ ÙƒÙ…ÙŠØ§Øª Ø£ÙƒØ¨Ø±ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù….",
                parse_mode="Markdown",
            )
            return

        coins = amount
        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø³Ø¹Ø± Ù„Ù„ÙƒÙ…ÙŠØ© Ø§Ù„Ù…Ø¯Ø®Ù„Ø©
        price = self.calculate_price(coins, transfer_type)

        # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¬Ù„Ø³Ø©
        session.update({"step": "sale_completed", "coins": coins, "price": price})

        log_user_action(
            user_id,
            f"Entered amount: {coins} coins, {transfer_type} transfer, price: {price} EGP",
        )

        # Ø¥Ø¹Ø¯Ø§Ø¯ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø¹Ø±Ø¶
        platform_name = {
            "playstation": "ğŸ® PlayStation",
            "xbox": "ğŸ® Xbox",
            "pc": "ğŸ–¥ï¸ PC",
        }.get(platform, platform)
        transfer_name = "âš¡ ÙÙˆØ±ÙŠ" if transfer_type == "instant" else "ğŸ“… Ø¹Ø§Ø¯ÙŠ"

        # Ø¬Ù„Ø¨ Ø³Ø¹Ø± Ø§Ù„Ù…Ù„ÙŠÙˆÙ† ÙƒÙ…Ø±Ø¬Ø¹ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
        million_price = CoinSellPricing.get_price(platform, 1000000, transfer_type)

        # Ø¥Ø°Ø§ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø¹Ø±ØŒ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø©
        if million_price is None:
            # Ø£Ø³Ø¹Ø§Ø± Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø«Ø§Ø¨ØªØ© (Ù†ÙØ³ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ù…Ù† sell_pricing.py)
            default_prices = {
                "normal": {"playstation": 5600, "xbox": 5600, "pc": 6100},
                "instant": {"playstation": 5300, "xbox": 5300, "pc": 5800},
            }
            million_price = default_prices.get(transfer_type, {}).get(platform, 5600)

        # ØªÙ†Ø³ÙŠÙ‚ Ø³Ø¹Ø± Ø§Ù„Ù…Ù„ÙŠÙˆÙ† Ù…Ø¹ ÙÙˆØ§ØµÙ„
        million_price_formatted = f"{million_price:,}"

        # Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©
        await update.message.reply_text(
            "ğŸ‰ **ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø·Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ¹ Ø¨Ù†Ø¬Ø§Ø­!**\n\n"
            f"ğŸ“Š **ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø·Ù„Ø¨:**\n"
            f"ğŸ® Ø§Ù„Ù…Ù†ØµØ©: {platform_name}\n"
            f"ğŸ’° Ø§Ù„ÙƒÙ…ÙŠØ©: {self.format_amount(coins)} ÙƒÙˆÙŠÙ†\n"
            f"ğŸ’µ Ø§Ù„Ø³Ø¹Ø±: {price} Ø¬Ù†ÙŠÙ‡\n"
            f"â­ (Ø³Ø¹Ø± Ø§Ù„Ù…Ù„ÙŠÙˆÙ†: {million_price_formatted} Ø¬Ù†ÙŠÙ‡)\n"
            f"â° Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„: {transfer_name}\n\n"
            "ğŸ“ **Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©:**\n"
            "1ï¸âƒ£ Ø³ÙŠØªÙ… Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ Ø®Ù„Ø§Ù„ Ø¯Ù‚Ø§Ø¦Ù‚\n"
            "2ï¸âƒ£ ØªØ³Ù„ÙŠÙ… Ø§Ù„ÙƒÙˆÙŠÙ†Ø² Ù„Ù„Ù…Ù…Ø«Ù„\n"
            "3ï¸âƒ£ Ø§Ø³ØªÙ„Ø§Ù… Ø§Ù„Ù…Ø¨Ù„Øº Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„\n\n"
            "âœ… **ØªÙ… Ø­ÙØ¸ Ø·Ù„Ø¨Ùƒ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…**\n"
            f"ğŸ†” **Ø±Ù‚Ù… Ø§Ù„Ø·Ù„Ø¨:** #{user_id}{coins}\n\n"
            "ğŸ’¬ **Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±:** /sell\n"
            "ğŸ  **Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:** /start",
            parse_mode="Markdown",
        )

        # Ù…Ø³Ø­ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
        self.clear_user_session(user_id)

    async def handle_price_confirmation(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø³Ø¹Ø±"""
        query = update.callback_query
        user_id = query.from_user.id

        await query.answer()

        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† callback_data
        # ØªÙ†Ø³ÙŠÙ‚: sell_confirm_{platform}_{coins}_{price}
        parts = query.data.split("_")
        if len(parts) >= 5:
            platform = parts[2]
            coins = int(parts[3])
            price = int(parts[4])

            # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¬Ù„Ø³Ø©
            self.user_sessions[user_id].update(
                {
                    "step": "sale_instructions",
                    "platform": platform,
                    "coins": coins,
                    "price": price,
                }
            )

            log_user_action(user_id, f"Confirmed sale: {coins} coins for {price} EGP")

            # Ø¹Ø±Ø¶ ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø§Ù„Ø¨ÙŠØ¹
            instructions_message = SellMessages.get_sale_instructions_message(
                platform, coins
            )
            keyboard = SellKeyboards.get_sale_instructions_keyboard(platform, coins)

            await query.edit_message_text(
                instructions_message, reply_markup=keyboard, parse_mode="HTML"
            )

    async def handle_sale_instructions(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰ ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø§Ù„Ø¨ÙŠØ¹"""
        query = update.callback_query
        user_id = query.from_user.id

        await query.answer()

        session = self.user_sessions.get(user_id, {})

        # Ø¥Ù†Ø´Ø§Ø¡ Ø·Ù„Ø¨ Ø¨ÙŠØ¹
        sale_id = self._create_sale_request(user_id, session)

        log_user_action(user_id, f"Started sale process, sale_id: {sale_id}")

        # Ø¹Ø±Ø¶ Ø§Ø®ØªÙŠØ§Ø± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹
        payment_message = (
            "ğŸ’³ <b>Ø§Ø®ØªØ± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹ Ø§Ù„Ù…ÙØ¶Ù„Ø©:</b>\n\n"
            + "Ø³ØªØ³ØªÙ„Ù… Ø£Ù…ÙˆØ§Ù„Ùƒ Ø¹Ù„Ù‰ Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ù…Ø®ØªØ§Ø±Ø© ÙÙˆØ± Ø¥ØªÙ…Ø§Ù… Ø§Ù„Ø¨ÙŠØ¹"
        )
        keyboard = SellKeyboards.get_payment_method_keyboard()

        await query.edit_message_text(
            payment_message, reply_markup=keyboard, parse_mode="HTML"
        )

    async def handle_payment_selection(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø®ØªÙŠØ§Ø± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹"""
        query = update.callback_query
        user_id = query.from_user.id

        await query.answer()

        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹
        payment_method = query.data.replace("sell_payment_", "")

        # Ø­ÙØ¸ Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹ ÙÙŠ Ø§Ù„Ø¬Ù„Ø³Ø©
        if user_id in self.user_sessions:
            self.user_sessions[user_id]["payment_method"] = payment_method

        log_user_action(user_id, f"Selected payment method: {payment_method}")

        # Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ù†Ø¬Ø§Ø­ Ø§Ù„Ø¨Ø¯Ø¡
        success_message = """âœ… <b>ØªÙ… Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¨ÙŠØ¹ Ø¨Ù†Ø¬Ø§Ø­!</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‹ <b>Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©:</b>

1ï¸âƒ£ Ø³ÙŠØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ ÙØ±ÙŠÙ‚ Ø§Ù„Ø¯Ø¹Ù… Ø®Ù„Ø§Ù„ 5 Ø¯Ù‚Ø§Ø¦Ù‚
2ï¸âƒ£ Ø³ÙŠØªÙ… Ø¥Ø±Ø´Ø§Ø¯Ùƒ Ù„ØªÙ†ÙÙŠØ° Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª
3ï¸âƒ£ Ø³ØªØ³ØªÙ„Ù… Ø£Ù…ÙˆØ§Ù„Ùƒ ÙÙˆØ± Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„ÙƒÙˆÙŠÙ†Ø²

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â° <b>ÙˆÙ‚Øª Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©:</b> 5-10 Ø¯Ù‚Ø§Ø¦Ù‚ ÙƒØ­Ø¯ Ø£Ù‚ØµÙ‰
ğŸ“ <b>Ù„Ù„Ø§Ø³ØªØ¹Ø¬Ø§Ù„:</b> ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ

ğŸ‰ <b>Ø´ÙƒØ±Ø§Ù‹ Ù„Ø«Ù‚ØªÙƒ ÙÙŠ FC26!</b>"""

        keyboard = SellKeyboards.get_sale_progress_keyboard()

        await query.edit_message_text(
            success_message, reply_markup=keyboard, parse_mode="HTML"
        )

    async def handle_navigation(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªÙ†Ù‚Ù„ Ø¨ÙŠÙ† Ø§Ù„ØµÙØ­Ø§Øª"""
        query = update.callback_query
        user_id = query.from_user.id

        await query.answer()

        action = query.data.replace("sell_back_", "")

        if action == "main":
            # Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
            welcome_message = SellMessages.get_welcome_sell_message()
            keyboard = SellKeyboards.get_main_sell_keyboard()

            await query.edit_message_text(
                welcome_message, reply_markup=keyboard, parse_mode="HTML"
            )

        elif action == "platforms":
            # Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù†ØµØ©
            platform_message = SellMessages.get_platform_selection_message()
            keyboard = SellKeyboards.get_main_sell_keyboard()

            await query.edit_message_text(
                platform_message, reply_markup=keyboard, parse_mode="HTML"
            )

    async def handle_help(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©"""
        query = update.callback_query
        await query.answer()

        help_message = SellMessages.get_help_message()
        keyboard = SellKeyboards.get_help_keyboard()

        await query.edit_message_text(
            help_message, reply_markup=keyboard, parse_mode="HTML"
        )

    async def handle_cancel(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¨ÙŠØ¹"""
        query = update.callback_query
        user_id = query.from_user.id

        await query.answer()

        # Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø¬Ù„Ø³Ø©
        if user_id in self.user_sessions:
            del self.user_sessions[user_id]

        log_user_action(user_id, "Cancelled coin selling")

        cancel_message = SellMessages.get_error_message("sale_cancelled")
        keyboard = SellKeyboards.get_error_keyboard()

        await query.edit_message_text(
            cancel_message, reply_markup=keyboard, parse_mode="HTML"
        )

    async def handle_support(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ"""
        query = update.callback_query
        await query.answer()

        support_message = """ğŸ“ <b>Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ FC26</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ• <b>Ù…ØªÙˆÙØ± 24/7 Ù„Ø®Ø¯Ù…ØªÙƒ</b>

ğŸ“± <b>Ø·Ø±Ù‚ Ø§Ù„ØªÙˆØ§ØµÙ„:</b>
â€¢ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø© ÙÙŠ Ø§Ù„Ø¨ÙˆØª
â€¢ ÙˆØ§ØªØ³Ø§Ø¨: Ù…ØªÙˆÙØ± ÙÙŠ Ù…Ù„ÙÙƒ Ø§Ù„Ø´Ø®ØµÙŠ
â€¢ Ø±Ø³Ø§Ø¦Ù„ Ø®Ø§ØµØ©

âš¡ <b>Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø³Ø±ÙŠØ¹Ø©:</b> Ø®Ù„Ø§Ù„ Ø¯Ù‚Ø§Ø¦Ù‚ Ù…Ø¹Ø¯ÙˆØ¯Ø©

Ù†Ø­Ù† Ù‡Ù†Ø§ Ù„Ù…Ø³Ø§Ø¹Ø¯ØªÙƒ! ğŸ¤"""

        await query.edit_message_text(support_message, parse_mode="HTML")

    def _create_sale_request(self, user_id: int, session: Dict) -> str:
        """Ø¥Ù†Ø´Ø§Ø¡ Ø·Ù„Ø¨ Ø¨ÙŠØ¹ Ø¬Ø¯ÙŠØ¯"""
        import time

        sale_id = f"SALE_{user_id}_{int(time.time())}"

        # Ø­ÙØ¸ Ø·Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ¹
        self.pending_sales[sale_id] = {
            "user_id": user_id,
            "platform": session.get("platform"),
            "coins": session.get("coins"),
            "price": session.get("price"),
            "status": "pending",
            "created_at": time.time(),
        }

        return sale_id

    def get_user_session(self, user_id: int) -> Optional[Dict]:
        """Ø¬Ù„Ø¨ Ø¬Ù„Ø³Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…"""
        return self.user_sessions.get(user_id)

    def clear_user_session(self, user_id: int):
        """Ù…Ø³Ø­ Ø¬Ù„Ø³Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…"""
        if user_id in self.user_sessions:
            del self.user_sessions[user_id]

    @staticmethod
    def parse_amount(text: str):
        """ØªØ­Ù„ÙŠÙ„ ÙƒÙ…ÙŠØ© Ø§Ù„ÙƒÙˆÙŠÙ†Ø² - Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø· (2-5 Ø£Ø±Ù‚Ø§Ù…)"""
        if not text or not isinstance(text, str):
            return None

        text = text.strip()

        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ k Ø£Ùˆ m - Ù…Ù…Ù†ÙˆØ¹
        if "k" in text.lower() or "m" in text.lower():
            return "invalid_format"

        try:
            if not text.isdigit():
                return None

            number = int(text)

            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… (2-5 Ø£Ø±Ù‚Ø§Ù…)
            if len(text) < 2 or len(text) > 5:
                return "invalid_length"

            return number

        except (ValueError, TypeError):
            return None

    @staticmethod
    def calculate_price(amount, transfer_type="normal"):
        """Ø­Ø³Ø§Ø¨ Ø§Ù„Ø³Ø¹Ø± Ø­Ø³Ø¨ Ø§Ù„ÙƒÙ…ÙŠØ© ÙˆÙ†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„"""
        base_price_per_1000 = 5  # 5 Ø¬Ù†ÙŠÙ‡ Ù„ÙƒÙ„ 1000 ÙƒÙˆÙŠÙ†

        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
        base_price = (amount / 1000) * base_price_per_1000

        # Ø¥Ø¶Ø§ÙØ© Ø±Ø³ÙˆÙ… Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„
        if transfer_type == "instant":
            base_price *= 1.2  # Ø²ÙŠØ§Ø¯Ø© 20% Ù„Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„ÙÙˆØ±ÙŠ

        return int(base_price)

    @staticmethod
    def format_amount(amount: int) -> str:
        """
        ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø§Ø¯ÙŠØ© Ù„Ù€ K/M format
        Ù…Ø«Ø§Ù„: 915 -> 915 K | 1500 -> 1Ù¬500 M
        """
        if not isinstance(amount, (int, float)):
            return "0"

        amount = int(amount)

        if 50 <= amount <= 999:
            # Ù…Ù† 50 Ø¥Ù„Ù‰ 999: Ø¹Ø±Ø¶ Ø¨ØµÙŠØºØ© K
            return f"{amount} K"
        elif 1000 <= amount <= 20000:
            # Ù…Ù† 1,000 Ø¥Ù„Ù‰ 20,000: Ø¹Ø±Ø¶ Ø¨ØµÙŠØºØ© M Ù…Ø¹ Ø§Ù„ÙØ§ØµÙ„Ø© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
            formatted = f"{amount:,}".replace(",", "Ù¬")
            return f"{formatted} M"
        else:
            # Ù„Ù„Ù‚ÙŠÙ… Ø®Ø§Ø±Ø¬ Ø§Ù„Ù†Ø·Ø§Ù‚: Ø¹Ø±Ø¶ Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø§Ø¯ÙŠØ©
            return str(amount)


--- FC26_sale_coins_Bot/services/sell_coins/sell_keyboards.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              âŒ¨ï¸ FC26 COIN SELLING KEYBOARDS - Ø£Ø²Ø±Ø§Ø± Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²          â•‘
# â•‘                       Coin Selling Keyboards                            â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from typing import List, Dict
from .sell_pricing import CoinSellPricing, Platform

class SellKeyboards:
    """Ø£Ø²Ø±Ø§Ø± ÙˆÙ„ÙˆØ­Ø§Øª Ù…ÙØ§ØªÙŠØ­ Ø®Ø¯Ù…Ø© Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²"""
    
    @staticmethod
    def get_main_sell_keyboard() -> InlineKeyboardMarkup:
        """Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„Ø®Ø¯Ù…Ø© Ø§Ù„Ø¨ÙŠØ¹"""
        keyboard = [
            [InlineKeyboardButton("ğŸ® PlayStation", callback_data="sell_platform_playstation")],
            [InlineKeyboardButton("ğŸ® Xbox", callback_data="sell_platform_xbox")],
            [InlineKeyboardButton("ğŸ–¥ï¸ PC", callback_data="sell_platform_pc")],
            [InlineKeyboardButton("â“ Ù…Ø³Ø§Ø¹Ø¯Ø©", callback_data="sell_help"),
             InlineKeyboardButton("ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø©", callback_data="sell_back_main")]
        ]
        return InlineKeyboardMarkup(keyboard)
    

    @staticmethod
    def get_price_confirmation_keyboard(platform: str, coins: int, price: int) -> InlineKeyboardMarkup:
        """Ù„ÙˆØ­Ø© ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø³Ø¹Ø±"""
        keyboard = [
            [InlineKeyboardButton("âœ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¨ÙŠØ¹", callback_data=f"sell_confirm_{platform}_{coins}_{price}")],
            [InlineKeyboardButton("ğŸ“ Ø¥Ø¯Ø®Ø§Ù„ ÙƒÙ…ÙŠØ© Ø£Ø®Ø±Ù‰", callback_data=f"sell_platform_{platform}"),
             InlineKeyboardButton("ğŸ® ØªØºÙŠÙŠØ± Ø§Ù„Ù…Ù†ØµØ©", callback_data="sell_back_platforms")],
            [InlineKeyboardButton("ğŸš« Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¨ÙŠØ¹", callback_data="sell_cancel")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_sale_instructions_keyboard(platform: str, coins: int) -> InlineKeyboardMarkup:
        """Ù„ÙˆØ­Ø© ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø§Ù„Ø¨ÙŠØ¹"""
        keyboard = [
            [InlineKeyboardButton("âœ… ÙÙ‡Ù…Øª Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§ØªØŒ Ù…ØªØ§Ø¨Ø¹Ø©", callback_data=f"sell_ready_{platform}_{coins}")],
            [InlineKeyboardButton("â“ Ø£Ø­ØªØ§Ø¬ Ù…Ø³Ø§Ø¹Ø¯Ø©", callback_data="sell_help_instructions")],
            [InlineKeyboardButton("ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø³Ø¹Ø±", callback_data=f"sell_back_price_{platform}_{coins}"),
             InlineKeyboardButton("ğŸš« Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¨ÙŠØ¹", callback_data="sell_cancel")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_payment_method_keyboard() -> InlineKeyboardMarkup:
        """Ù„ÙˆØ­Ø© Ø§Ø®ØªÙŠØ§Ø± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹"""
        keyboard = [
            [InlineKeyboardButton("ğŸ“± ÙÙˆØ¯Ø§ÙÙˆÙ† ÙƒØ§Ø´", callback_data="sell_payment_vodafone")],
            [InlineKeyboardButton("ğŸ“± Ø§ØªØµØ§Ù„Ø§Øª ÙƒØ§Ø´", callback_data="sell_payment_etisalat")],
            [InlineKeyboardButton("ğŸ“± Ø£ÙˆØ±Ø§Ù†Ø¬ ÙƒØ§Ø´", callback_data="sell_payment_orange")], 
            [InlineKeyboardButton("ğŸ“± ÙˆÙŠ ÙƒØ§Ø´", callback_data="sell_payment_we")],
            [InlineKeyboardButton("ğŸ’° Ø¥Ù†Ø³ØªØ§Ø¨Ø§ÙŠ", callback_data="sell_payment_instapay")],
            [InlineKeyboardButton("ğŸ¦ ØªØ­ÙˆÙŠÙ„ Ø¨Ù†ÙƒÙŠ", callback_data="sell_payment_bank")],
            [InlineKeyboardButton("ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø©", callback_data="sell_back_instructions")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_sale_progress_keyboard() -> InlineKeyboardMarkup:
        """Ù„ÙˆØ­Ø© Ù…ØªØ§Ø¨Ø¹Ø© Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙŠØ¹"""
        keyboard = [
            [InlineKeyboardButton("ğŸ“Š Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙŠØ¹", callback_data="sell_status")],
            [InlineKeyboardButton("ğŸ“ ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù…", callback_data="sell_support")],
            [InlineKeyboardButton("ğŸš« Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¨ÙŠØ¹", callback_data="sell_cancel_confirm")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_sale_completed_keyboard() -> InlineKeyboardMarkup:
        """Ù„ÙˆØ­Ø© Ø¥ØªÙ…Ø§Ù… Ø§Ù„Ø¨ÙŠØ¹"""
        keyboard = [
            [InlineKeyboardButton("ğŸ’° Ø¨ÙŠØ¹ Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„ÙƒÙˆÙŠÙ†Ø²", callback_data="sell_more")],
            [InlineKeyboardButton("ğŸ“Š ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø®Ø¯Ù…Ø©", callback_data="sell_rate_service")],
            [InlineKeyboardButton("ğŸ  Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="sell_main_menu")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_custom_amount_cancel_keyboard(platform: str) -> InlineKeyboardMarkup:
        """Ù„ÙˆØ­Ø© Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ÙƒÙ…ÙŠØ© Ø§Ù„Ù…Ø®ØµØµØ©"""
        keyboard = [
            [InlineKeyboardButton("ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù†ØµØ©", callback_data="sell_back_platforms")],
            [InlineKeyboardButton("ğŸ® ØªØºÙŠÙŠØ± Ø§Ù„Ù…Ù†ØµØ©", callback_data="sell_back_platforms")],
            [InlineKeyboardButton("ğŸš« Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¨ÙŠØ¹", callback_data="sell_cancel")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_help_keyboard() -> InlineKeyboardMarkup:
        """Ù„ÙˆØ­Ø© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©"""
        keyboard = [
            [InlineKeyboardButton("ğŸ“ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ", callback_data="sell_support")],
            [InlineKeyboardButton("ğŸ’¡ Ø£Ø³Ø¦Ù„Ø© Ø´Ø§Ø¦Ø¹Ø©", callback_data="sell_faq")],
            [InlineKeyboardButton("ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø¨ÙŠØ¹", callback_data="sell_back_main")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_error_keyboard(error_type: str = "general") -> InlineKeyboardMarkup:
        """Ù„ÙˆØ­Ø© Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡"""
        keyboard = [
            [InlineKeyboardButton("ğŸ”„ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰", callback_data="sell_retry")],
            [InlineKeyboardButton("ğŸ“ ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù…", callback_data="sell_support")],
            [InlineKeyboardButton("ğŸ  Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="sell_main_menu")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_admin_sell_keyboard() -> InlineKeyboardMarkup:
        """Ù„ÙˆØ­Ø© Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¨ÙŠØ¹ (Ù„Ù„Ø£Ø¯Ù…Ù†)"""
        keyboard = [
            [InlineKeyboardButton("ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙŠØ¹", callback_data="admin_sell_stats")],
            [InlineKeyboardButton("ğŸ’° ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ø³Ø¹Ø§Ø±", callback_data="admin_sell_prices")],
            [InlineKeyboardButton("ğŸ“‹ Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø¨ÙŠØ¹ Ø§Ù„Ù†Ø´Ø·Ø©", callback_data="admin_sell_active")],
            [InlineKeyboardButton("ğŸ”™ Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©", callback_data="admin_main")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @classmethod
    def get_quick_sell_keyboard(cls) -> InlineKeyboardMarkup:
        """Ù„ÙˆØ­Ø© Ø§Ù„Ø¨ÙŠØ¹ Ø§Ù„Ø³Ø±ÙŠØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"""
        keyboard = [
            [InlineKeyboardButton("ğŸ’° Ø¨ÙŠØ¹ ÙƒÙˆÙŠÙ†Ø² FIFA", callback_data="sell_start")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @classmethod 
    def get_platform_comparison_keyboard(cls) -> InlineKeyboardMarkup:
        """Ù„ÙˆØ­Ø© Ù…Ù‚Ø§Ø±Ù†Ø© Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ù…Ù†ØµØ§Øª"""
        keyboard = [
            [InlineKeyboardButton("ğŸ“Š Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„Ø£Ø³Ø¹Ø§Ø±", callback_data="sell_compare_prices")],
            [InlineKeyboardButton("ğŸ® PlayStation", callback_data="sell_platform_playstation"),
             InlineKeyboardButton("ğŸ® Xbox", callback_data="sell_platform_xbox")],
            [InlineKeyboardButton("ğŸ–¥ï¸ PC", callback_data="sell_platform_pc")],
            [InlineKeyboardButton("ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø©", callback_data="sell_back_main")]
        ]
        return InlineKeyboardMarkup(keyboard)

    @classmethod
    def build_dynamic_keyboard(cls, buttons_data: List[Dict], rows: int = 2) -> InlineKeyboardMarkup:
        """Ø¨Ù†Ø§Ø¡ Ù„ÙˆØ­Ø© Ù…ÙØ§ØªÙŠØ­ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©"""
        keyboard = []
        current_row = []
        
        for i, button in enumerate(buttons_data):
            current_row.append(InlineKeyboardButton(
                button['text'], 
                callback_data=button['callback_data']
            ))
            
            # Ø¥Ø°Ø§ ÙˆØµÙ„Ù†Ø§ Ù„Ø¢Ø®Ø± Ø¹Ù†ØµØ± ÙÙŠ Ø§Ù„ØµÙ Ø£Ùˆ Ø¢Ø®Ø± Ø¹Ù†ØµØ± Ø¨Ø´ÙƒÙ„ Ø¹Ø§Ù…
            if len(current_row) == rows or i == len(buttons_data) - 1:
                keyboard.append(current_row)
                current_row = []
        
        return InlineKeyboardMarkup(keyboard)

--- FC26_sale_coins_Bot/services/sell_coins/sell_messages.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ’¬ FC26 COIN SELLING MESSAGES - Ø±Ø³Ø§Ø¦Ù„ Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²           â•‘
# â•‘                      Coin Selling Messages                               â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from typing import Dict, List, Optional
from .sell_pricing import CoinSellPricing

class SellMessages:
    """Ø±Ø³Ø§Ø¦Ù„ Ø®Ø¯Ù…Ø© Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²"""
    
    @staticmethod
    def get_welcome_sell_message() -> str:
        """Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ø¨Ø®Ø¯Ù…Ø© Ø§Ù„Ø¨ÙŠØ¹"""
        return """ğŸ’° <b>Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø®Ø¯Ù…Ø© Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø² FC26</b>

ğŸ® <b>Ù†Ø´ØªØ±ÙŠ ÙƒÙˆÙŠÙ†Ø² FIFA Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù†ØµØ§Øª:</b>
â€¢ PlayStation (PS4/PS5)
â€¢ Xbox (One/Series X|S)  
â€¢ PC (Origin/Steam/Epic)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ <b>ÙƒÙŠÙ ØªØªÙ… Ø§Ù„Ø¹Ù…Ù„ÙŠØ©ØŸ</b>

1ï¸âƒ£ Ø§Ø®ØªØ± Ù…Ù†ØµØªÙƒ
2ï¸âƒ£ Ø­Ø¯Ø¯ ÙƒÙ…ÙŠØ© Ø§Ù„ÙƒÙˆÙŠÙ†Ø²
3ï¸âƒ£ Ø§Ø·Ù„Ø¹ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø¹Ø±
4ï¸âƒ£ Ø£ÙƒØ¯ Ø§Ù„Ø¨ÙŠØ¹
5ï¸âƒ£ Ø§Ø³ØªÙ„Ù… Ø£Ù…ÙˆØ§Ù„Ùƒ

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â­ <b>Ù…Ù…ÙŠØ²Ø§Øª Ø®Ø¯Ù…ØªÙ†Ø§:</b>
â€¢ ğŸš€ Ø¯ÙØ¹ ÙÙˆØ±ÙŠ Ø®Ù„Ø§Ù„ Ø¯Ù‚Ø§Ø¦Ù‚
â€¢ ğŸ›¡ï¸ Ø¶Ù…Ø§Ù† Ø¢Ù…Ù† 100%
â€¢ ğŸ’ Ø£ÙØ¶Ù„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± ÙÙŠ Ø§Ù„Ø³ÙˆÙ‚
â€¢ ğŸ“ Ø¯Ø¹Ù… ÙÙ†ÙŠ Ø¹Ù„Ù‰ Ù…Ø¯Ø§Ø± Ø§Ù„Ø³Ø§Ø¹Ø©

Ø§Ø®ØªØ± Ù…Ù†ØµØªÙƒ Ù„Ù„Ø¨Ø¯Ø¡ ğŸ‘‡"""

    @staticmethod
    def get_platform_selection_message() -> str:
        """Ø±Ø³Ø§Ù„Ø© Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù†ØµØ©"""
        return """ğŸ® <b>Ø§Ø®ØªØ± Ù…Ù†ØµØ© Ø§Ù„Ù„Ø¹Ø¨:</b>

Ø§Ø®ØªØ± Ø§Ù„Ù…Ù†ØµØ© Ø§Ù„Ù„ÙŠ Ø¹Ù†Ø¯Ùƒ Ø¹Ù„ÙŠÙ‡Ø§ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²:"""



    @staticmethod
    def get_custom_amount_message(platform: str) -> str:
        """Ø±Ø³Ø§Ù„Ø© Ø·Ù„Ø¨ ÙƒÙ…ÙŠØ© Ù…Ø®ØµØµØ©"""
        platform_name = CoinSellPricing.get_platform_display_name(platform)
        
        return f"""ğŸ¯ <b>ÙƒÙ…ÙŠØ© Ù…Ø®ØµØµØ© - {platform_name}</b>

ğŸ“ <b>Ø£Ø¯Ø®Ù„ ÙƒÙ…ÙŠØ© Ø§Ù„ÙƒÙˆÙŠÙ†Ø² Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø¨ÙŠØ¹Ù‡Ø§:</b>

âš ï¸ <b>Ø§Ù„Ø´Ø±ÙˆØ·:</b>
â€¢ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰: 50,000 ÙƒÙˆÙŠÙ†  
â€¢ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰: 10,000,000 ÙƒÙˆÙŠÙ†
â€¢ ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ù…Ù† Ù…Ø¶Ø§Ø¹ÙØ§Øª 10,000

ğŸ’¡ <b>Ø£Ù…Ø«Ù„Ø© ØµØ­ÙŠØ­Ø©:</b>
â€¢ 150000 (150K ÙƒÙˆÙŠÙ†)
â€¢ 750000 (750K ÙƒÙˆÙŠÙ†)  
â€¢ 1500000 (1.5M ÙƒÙˆÙŠÙ†)

âŒ <b>Ø£Ù…Ø«Ù„Ø© Ø®Ø§Ø·Ø¦Ø©:</b>
â€¢ 155000 (Ù„ÙŠØ³Øª Ù…Ù† Ù…Ø¶Ø§Ø¹ÙØ§Øª 10K)
â€¢ 25000 (Ø£Ù‚Ù„ Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰)

Ø§ÙƒØªØ¨ Ø§Ù„ÙƒÙ…ÙŠØ© Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·:"""

    @staticmethod
    def get_price_confirmation_message(platform: str, coins: int, price: int) -> str:
        """Ø±Ø³Ø§Ù„Ø© ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø³Ø¹Ø±"""
        platform_name = CoinSellPricing.get_platform_display_name(platform)
        coins_display = CoinSellPricing._format_coins(coins)
        
        # Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©
        discount_info = CoinSellPricing.get_discount_info(coins)
        discount_text = f"\nğŸ‰ <b>{discount_info}</b>" if discount_info else ""
        
        return f"""ğŸ’° <b>ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø³Ø¹Ø±</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‹ <b>ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¨ÙŠØ¹:</b>

ğŸ® <b>Ø§Ù„Ù…Ù†ØµØ©:</b> {platform_name}
ğŸ’ <b>Ø§Ù„ÙƒÙ…ÙŠØ©:</b> {coins_display} ÙƒÙˆÙŠÙ†
ğŸ’° <b>Ø§Ù„Ø³Ø¹Ø±:</b> <b>{price} Ø¬Ù†ÙŠÙ‡ Ù…ØµØ±ÙŠ</b>{discount_text}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ <b>Ø®Ø·ÙˆØ§Øª Ø§Ù„Ø¨ÙŠØ¹:</b>

1ï¸âƒ£ Ø£ÙƒØ¯ Ø§Ù„Ø¨ÙŠØ¹ Ø¨Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ "ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¨ÙŠØ¹"
2ï¸âƒ£ Ø³ØªØ­ØµÙ„ Ø¹Ù„Ù‰ ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø§Ù„ØªØ³Ù„ÙŠÙ…
3ï¸âƒ£ Ø³Ù†Ø±Ø§Ø¬Ø¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø² ÙÙŠ Ø­Ø³Ø§Ø¨Ùƒ
4ï¸âƒ£ Ø³ØªØ³ØªÙ„Ù… Ø£Ù…ÙˆØ§Ù„Ùƒ Ø®Ù„Ø§Ù„ 5-10 Ø¯Ù‚Ø§Ø¦Ù‚

ğŸ›¡ï¸ <b>Ø¶Ù…Ø§Ù† Ø¢Ù…Ù†:</b> Ù„Ø§ Ù†Ø£Ø®Ø° Ø§Ù„ÙƒÙˆÙŠÙ†Ø² Ø¥Ù„Ø§ Ø¨Ø¹Ø¯ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ØµØ­ØªÙ‡Ø§

Ù‡Ù„ ØªØ±ÙŠØ¯ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©ØŸ"""

    @staticmethod
    def get_sale_instructions_message(platform: str, coins: int) -> str:
        """Ø±Ø³Ø§Ù„Ø© ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø§Ù„Ø¨ÙŠØ¹"""
        platform_name = CoinSellPricing.get_platform_display_name(platform)
        coins_display = CoinSellPricing._format_coins(coins)
        
        return f"""ğŸ“‹ <b>ØªØ¹Ù„ÙŠÙ…Ø§Øª ØªØ³Ù„ÙŠÙ… Ø§Ù„ÙƒÙˆÙŠÙ†Ø²</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ® <b>Ø§Ù„Ù…Ù†ØµØ©:</b> {platform_name}
ğŸ’ <b>Ø§Ù„ÙƒÙ…ÙŠØ©:</b> {coins_display} ÙƒÙˆÙŠÙ†

ğŸ”¹ <b>Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªØ³Ù„ÙŠÙ…:</b>

1ï¸âƒ£ <b>Ø§Ø¯Ø®Ù„ Ø¹Ù„Ù‰ FIFA Ultimate Team</b>
2ï¸âƒ£ <b>Ø§Ø°Ù‡Ø¨ Ø¥Ù„Ù‰ Transfer Market</b> 
3ï¸âƒ£ <b>Ø¶Ø¹ Ù„Ø§Ø¹Ø¨ Ø±Ø®ÙŠØµ Ù„Ù„Ø¨ÙŠØ¹ Ø¨Ø§Ù„Ø³Ø¹Ø± Ø§Ù„ØªØ§Ù„ÙŠ:</b>
   ğŸ’° Ø§Ù„Ø³Ø¹Ø±: Ø³Ù†Ø±Ø³Ù„ Ù„Ùƒ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ù…Ø­Ø¯Ø¯
   â° Ø§Ù„Ù…Ø¯Ø©: 1 Ø³Ø§Ø¹Ø©

4ï¸âƒ£ <b>Ø£Ø±Ø³Ù„ Ù„Ù†Ø§:</b>
   â€¢ Ø§Ø³Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨
   â€¢ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ù…Ø·Ù„ÙˆØ¨
   â€¢ ØµÙˆØ±Ø© Ù…Ù† Ø´Ø§Ø´Ø© Ø§Ù„Ø¨ÙŠØ¹

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš ï¸ <b>ØªÙ†Ø¨ÙŠÙ‡Ø§Øª Ù…Ù‡Ù…Ø©:</b>

â€¢ Ù„Ø§ ØªØ¶Ø¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ù„Ù„Ø¨ÙŠØ¹ Ù‚Ø¨Ù„ Ù…ÙˆØ§ÙÙ‚ØªÙ†Ø§
â€¢ ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„ÙƒÙˆÙŠÙ†Ø² Ù…ØªÙˆÙØ±Ø© ÙÙŠ Ø­Ø³Ø§Ø¨Ùƒ
â€¢ Ù„Ø§ ØªÙ„Ø¹Ø¨ FIFA Ø£Ø«Ù†Ø§Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¨ÙŠØ¹

â° <b>ÙˆÙ‚Øª Ø§Ù„ØªØ³Ù„ÙŠÙ…:</b> Ø³Ù†Ø´ØªØ±ÙŠ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø®Ù„Ø§Ù„ 5 Ø¯Ù‚Ø§Ø¦Ù‚ Ù…Ù† Ø§Ù„ØªØ£ÙƒÙŠØ¯

Ù‡Ù„ Ø£Ù†Øª Ø¬Ø§Ù‡Ø² Ù„Ù„Ø¨Ø¯Ø¡ØŸ"""

    @staticmethod 
    def get_payment_info_message(payment_method: str) -> str:
        """Ø±Ø³Ø§Ù„Ø© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¯ÙØ¹"""
        return f"""ğŸ’³ <b>Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¯ÙØ¹</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“± <b>Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹ Ø§Ù„Ù…Ø®ØªØ§Ø±Ø©:</b> {payment_method}

âš¡ <b>Ø³Ø±Ø¹Ø© Ø§Ù„ØªØ­ÙˆÙŠÙ„:</b>
â€¢ ÙÙˆØ¯Ø§ÙÙˆÙ† ÙƒØ§Ø´: ÙÙˆØ±ÙŠ (1-2 Ø¯Ù‚ÙŠÙ‚Ø©)
â€¢ Ø§ØªØµØ§Ù„Ø§Øª ÙƒØ§Ø´: ÙÙˆØ±ÙŠ (1-2 Ø¯Ù‚ÙŠÙ‚Ø©)  
â€¢ Ø¥Ù†Ø³ØªØ§Ø¨Ø§ÙŠ: ÙÙˆØ±ÙŠ (1-3 Ø¯Ù‚Ø§Ø¦Ù‚)
â€¢ Ø§Ù„Ø¨Ù†Ùƒ: 5-15 Ø¯Ù‚ÙŠÙ‚Ø©

ğŸ›¡ï¸ <b>Ø§Ù„Ø£Ù…Ø§Ù†:</b> Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ù…Ø¶Ù…ÙˆÙ†Ø© ÙˆÙ…Ø¤Ù…Ù†Ø©

ğŸ“ <b>Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±:</b> ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ ÙÙŠ Ø£ÙŠ ÙˆÙ‚Øª"""

    @staticmethod
    def get_sale_completed_message(coins: int, price: int) -> str:
        """Ø±Ø³Ø§Ù„Ø© Ø¥ØªÙ…Ø§Ù… Ø§Ù„Ø¨ÙŠØ¹"""
        coins_display = CoinSellPricing._format_coins(coins)
        
        return f"""âœ… <b>ØªÙ… Ø¥ØªÙ…Ø§Ù… Ø§Ù„Ø¨ÙŠØ¹ Ø¨Ù†Ø¬Ø§Ø­!</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ‰ <b>ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¨ÙŠØ¹:</b>

ğŸ’ <b>Ø§Ù„ÙƒÙˆÙŠÙ†Ø² Ø§Ù„Ù…Ø¨Ø§Ø¹Ø©:</b> {coins_display} ÙƒÙˆÙŠÙ†
ğŸ’° <b>Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ù…Ø³ØªÙ„Ù…:</b> {price} Ø¬Ù†ÙŠÙ‡ Ù…ØµØ±ÙŠ
â° <b>ÙˆÙ‚Øª Ø§Ù„Ø¨ÙŠØ¹:</b> Ø§Ù„Ø¢Ù†

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ™ <b>Ø´ÙƒØ±Ø§Ù‹ Ù„Ø«Ù‚ØªÙƒ ÙÙŠ FC26!</b>

â­ Ù‡Ù„ ÙƒÙ†Øª Ø±Ø§Ø¶ÙŠ Ø¹Ù† Ø§Ù„Ø®Ø¯Ù…Ø©ØŸ
ğŸ“ Ù„Ø£ÙŠ Ø§Ø³ØªÙØ³Ø§Ø± ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§ ÙÙŠ Ø£ÙŠ ÙˆÙ‚Øª
ğŸ”„ Ù†ØªØ·Ù„Ø¹ Ù„Ø®Ø¯Ù…ØªÙƒ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰!

ğŸ’° <b>Ù‡Ù„ ØªØ±ÙŠØ¯ Ø¨ÙŠØ¹ Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„ÙƒÙˆÙŠÙ†Ø²ØŸ</b>"""

    @staticmethod
    def get_error_message(error_type: str) -> str:
        """Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…Ø®ØªÙ„ÙØ©"""
        error_messages = {
            'invalid_amount': """âŒ <b>ÙƒÙ…ÙŠØ© ØºÙŠØ± ØµØ­ÙŠØ­Ø©</b>

ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ ÙƒÙ…ÙŠØ© ØµØ­ÙŠØ­Ø© Ù…Ù† Ø§Ù„ÙƒÙˆÙŠÙ†Ø²:
â€¢ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰: 50,000 ÙƒÙˆÙŠÙ†
â€¢ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰: 10,000,000 ÙƒÙˆÙŠÙ†  
â€¢ ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ù…Ù† Ù…Ø¶Ø§Ø¹ÙØ§Øª 10,000

ğŸ’¡ Ù…Ø«Ø§Ù„ ØµØ­ÙŠØ­: 150000""",
            
            'invalid_platform': """âŒ <b>Ù…Ù†ØµØ© ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…Ø©</b>

Ø§Ù„Ù…Ù†ØµØ§Øª Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ…Ø© Ø­Ø§Ù„ÙŠØ§Ù‹:
â€¢ PlayStation (PS4/PS5)
â€¢ Xbox (One/Series X|S)
â€¢ PC (Origin/Steam/Epic)""",
            
            'sale_cancelled': """ğŸš« <b>ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¨ÙŠØ¹</b>

Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø´ÙƒÙ„Ø©! ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¨Ø¯Ø¡ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ ÙÙŠ Ø£ÙŠ ÙˆÙ‚Øª.
Ø§Ø³ØªØ®Ø¯Ù… /sell Ù„Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯.""",
            
            'system_error': """âš ï¸ <b>Ø®Ø·Ø£ Ù…Ø¤Ù‚Øª</b>

Ø­Ø¯Ø« Ø®Ø·Ø£ Ù…Ø¤Ù‚Øª ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù….
ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø®Ù„Ø§Ù„ Ø¯Ù‚Ø§Ø¦Ù‚.

Ø¥Ø°Ø§ Ø§Ø³ØªÙ…Ø± Ø§Ù„Ø®Ø·Ø£ØŒ ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ."""
        }
        
        return error_messages.get(error_type, error_messages['system_error'])
    
    @staticmethod
    def get_help_message() -> str:
        """Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ø®Ø¯Ù…Ø© Ø§Ù„Ø¨ÙŠØ¹"""
        return """â“ <b>Ù…Ø³Ø§Ø¹Ø¯Ø© Ø®Ø¯Ù…Ø© Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¤” <b>ÙƒÙŠÙ ØªØ¹Ù…Ù„ Ø§Ù„Ø®Ø¯Ù…Ø©ØŸ</b>

1ï¸âƒ£ Ø§Ø®ØªØ± Ù…Ù†ØµØªÙƒ (PlayStation/Xbox/PC)
2ï¸âƒ£ Ø­Ø¯Ø¯ ÙƒÙ…ÙŠØ© Ø§Ù„ÙƒÙˆÙŠÙ†Ø² 
3ï¸âƒ£ Ø§Ø·Ù„Ø¹ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ù…Ù‚ØªØ±Ø­
4ï¸âƒ£ Ø£ÙƒØ¯ Ø§Ù„Ø¨ÙŠØ¹ ÙˆØ§ØªØ¨Ø¹ Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª
5ï¸âƒ£ Ø§Ø³ØªÙ„Ù… Ø£Ù…ÙˆØ§Ù„Ùƒ Ø®Ù„Ø§Ù„ Ø¯Ù‚Ø§Ø¦Ù‚

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ <b>Ù†ØµØ§Ø¦Ø­ Ù…Ù‡Ù…Ø©:</b>

â€¢ ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„ÙƒÙˆÙŠÙ†Ø² ÙÙŠ Ø­Ø³Ø§Ø¨Ùƒ
â€¢ Ù„Ø§ ØªÙ„Ø¹Ø¨ FIFA Ø£Ø«Ù†Ø§Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¨ÙŠØ¹  
â€¢ Ø§ØªØ¨Ø¹ Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø¨Ø¯Ù‚Ø© Ù„Ø¶Ù…Ø§Ù† Ù†Ø¬Ø§Ø­ Ø§Ù„Ø¨ÙŠØ¹
â€¢ Ø§Ø­ØªÙØ¸ Ø¨ØµÙˆØ± Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ <b>Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ:</b>
Ù…ØªÙˆÙØ± 24/7 Ù„Ù…Ø³Ø§Ø¹Ø¯ØªÙƒ ÙÙŠ Ø£ÙŠ Ø§Ø³ØªÙØ³Ø§Ø±

Ø§Ø³ØªØ®Ø¯Ù… /sell Ù„Ù„Ø¨Ø¯Ø¡ Ø§Ù„Ø¢Ù†!"""

--- FC26_sale_coins_Bot/services/sell_coins/sell_pricing.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ’° FC26 COIN SELLING PRICING - Ù†Ø¸Ø§Ù… Ø£Ø³Ø¹Ø§Ø± Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²        â•‘
# â•‘                     Coin Selling Price Management                        â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from typing import Dict, List, Optional, Tuple
from enum import Enum

# Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø§Ø¯Ù…Ù† Ù„Ù„Ø±Ø¨Ø· Ù…Ø¹ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±
try:
    from database.admin_operations import AdminOperations
    DATABASE_AVAILABLE = True
except ImportError:
    DATABASE_AVAILABLE = False

class Platform(Enum):
    """Ù…Ù†ØµØ§Øª Ø§Ù„Ù„Ø¹Ø¨ Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ…Ø©"""
    PLAYSTATION = "playstation"
    XBOX = "xbox" 
    PC = "pc"

class CoinSellPricing:
    """Ø¥Ø¯Ø§Ø±Ø© Ø£Ø³Ø¹Ø§Ø± Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²"""
    
    # Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø¹Ø§Ø¯ÙŠØ© (Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø®Ù„Ø§Ù„ 24 Ø³Ø§Ø¹Ø©) - Ø£ØºÙ„Ù‰ Ù…Ù† Ø§Ù„ÙÙˆØ±ÙŠ
    NORMAL_PRICES = {
        # PlayStation Ùˆ Xbox Ù†ÙØ³ Ø§Ù„Ø³Ø¹Ø±
        Platform.PLAYSTATION.value: {
            1000000: 5600,  # 1M = 5600 Ø¬.Ù… (Ø§Ù„Ø¹Ø§Ø¯ÙŠ - Ø£ØºÙ„Ù‰)
        },
        Platform.XBOX.value: {
            1000000: 5600,  # 1M = 5600 Ø¬.Ù… (Ø§Ù„Ø¹Ø§Ø¯ÙŠ - Ø£ØºÙ„Ù‰)
        },
        # PC Ø³Ø¹Ø± Ù…Ù†ÙØµÙ„ (Ø£ØºÙ„Ù‰ Ø´ÙˆÙŠØ©)
        Platform.PC.value: {
            1000000: 6100,  # 1M = 6100 Ø¬.Ù… (Ø§Ù„Ø¹Ø§Ø¯ÙŠ - Ø£ØºÙ„Ù‰)
        }
    }
    
    # Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„ÙÙˆØ±ÙŠØ© (Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø®Ù„Ø§Ù„ Ø³Ø§Ø¹Ø©) - Ø£Ø±Ø®Øµ Ù…Ù† Ø§Ù„Ø¹Ø§Ø¯ÙŠ
    INSTANT_PRICES = {
        # PlayStation Ùˆ Xbox Ù†ÙØ³ Ø§Ù„Ø³Ø¹Ø±
        Platform.PLAYSTATION.value: {
            1000000: 5300,  # 1M = 5300 Ø¬.Ù… (Ø§Ù„ÙÙˆØ±ÙŠ - Ø£Ù‚Ù„)
        },
        Platform.XBOX.value: {
            1000000: 5300,  # 1M = 5300 Ø¬.Ù… (Ø§Ù„ÙÙˆØ±ÙŠ - Ø£Ù‚Ù„)
        },
        # PC Ø³Ø¹Ø± Ù…Ù†ÙØµÙ„ (Ø£ØºÙ„Ù‰ Ø´ÙˆÙŠØ©)
        Platform.PC.value: {
            1000000: 5800,  # 1M = 5800 Ø¬.Ù… (Ø§Ù„ÙÙˆØ±ÙŠ - Ø£Ù‚Ù„)
        }
    }
    
    # Ù„Ù„ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù‚Ø¯ÙŠÙ…
    CURRENT_PRICES = NORMAL_PRICES
    

    @classmethod
    def get_price(cls, platform: str, coins: int, transfer_type: str = "normal") -> Optional[int]:
        """Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¹Ø± Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø£ÙˆÙ„Ø§Ù‹ØŒ Ø«Ù… Ø§Ù„ÙƒÙˆØ¯ ÙƒØ§Ø­ØªÙŠØ§Ø·ÙŠ"""
        
        # Ù…Ø­Ø§ÙˆÙ„Ø© Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¹Ø± Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø°ÙƒÙŠØ© Ø£ÙˆÙ„Ø§Ù‹
        if DATABASE_AVAILABLE:
            try:
                db_price = AdminOperations.get_price(platform, transfer_type, coins)
                if db_price is not None:
                    return db_price
            except Exception:
                pass  # ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ø®Ø·Ø£ØŒ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
        
        # ÙÙŠ Ø­Ø§Ù„Ø© Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø³Ø¹Ø± ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŒ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
        price_table = cls.INSTANT_PRICES if transfer_type == "instant" else cls.NORMAL_PRICES
        
        if platform not in price_table:
            return None
        
        return price_table[platform].get(coins)
    
    @classmethod
    def get_transfer_prices(cls, platform: str, coins: int) -> Dict[str, Optional[int]]:
        """Ø¬Ù„Ø¨ Ø£Ø³Ø¹Ø§Ø± Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¹Ø§Ø¯ÙŠ ÙˆØ§Ù„ÙÙˆØ±ÙŠ Ù„ÙƒÙ…ÙŠØ© Ù…Ø¹ÙŠÙ†Ø©"""
        return {
            "normal": cls.get_price(platform, coins, "normal"),
            "instant": cls.get_price(platform, coins, "instant")
        }
    
    @classmethod
    def calculate_custom_price(cls, platform: str, coins: int) -> Optional[int]:
        """Ø­Ø³Ø§Ø¨ Ø§Ù„Ø³Ø¹Ø± Ù„ÙƒÙ…ÙŠØ© Ù…Ø®ØµØµØ© Ù…Ù† Ø§Ù„ÙƒÙˆÙŠÙ†Ø²"""
        if platform not in cls.CURRENT_PRICES:
            return None
        
        platform_prices = cls.CURRENT_PRICES[platform]
        
        # Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„ÙƒÙ…ÙŠØ© Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ Ø§Ù„Ø¨Ø§Ù‚Ø§Øª Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©
        if coins in platform_prices:
            return platform_prices[coins]
        
        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø³Ø¹Ø± Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø£Ù‚Ø±Ø¨ ÙƒÙ…ÙŠØ©
        price_per_100k = cls._get_price_per_100k(platform)
        if price_per_100k:
            return int((coins / 100000) * price_per_100k)
        
        return None
    
    @classmethod
    def _get_price_per_100k(cls, platform: str) -> Optional[float]:
        """Ø­Ø³Ø§Ø¨ Ø³Ø¹Ø± Ø§Ù„Ù€ 100k ÙƒÙˆÙŠÙ† Ù„Ù„Ù…Ù†ØµØ©"""
        if platform not in cls.CURRENT_PRICES:
            return None
        
        # Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø³Ø¹Ø± Ø§Ù„Ù€ 100k ÙƒØ£Ø³Ø§Ø³
        return cls.CURRENT_PRICES[platform].get(100000, 150)
    
    @classmethod
    def _format_coins(cls, coins: int) -> str:
        """ØªÙ†Ø³ÙŠÙ‚ Ø¹Ø±Ø¶ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²"""
        if coins >= 1000000:
            millions = coins / 1000000
            if millions == int(millions):
                return f"{int(millions)}M"
            else:
                return f"{millions:.1f}M"
        elif coins >= 1000:
            thousands = coins / 1000
            if thousands == int(thousands):
                return f"{int(thousands)}K" 
            else:
                return f"{thousands:.0f}K"
        else:
            return str(coins)
    
    @classmethod
    def format_price(cls, price: int) -> Dict[str, str]:
        """ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø³Ø¹Ø± Ø¨ÙØ§ØµÙ„Ø© Ø¹Ø§Ø¯ÙŠØ©"""
        if not isinstance(price, (int, float)) or price <= 0:
            return {"egp": "0 Ø¬.Ù…"}
        
        price = int(price)
        
        # Ø¨Ø§Ù„Ø¬Ù†ÙŠÙ‡ Ù…Ø¹ Ø§Ù„ÙØ§ØµÙ„Ø© Ø§Ù„Ø¹Ø§Ø¯ÙŠØ©
        formatted_egp = f"{price:,} Ø¬.Ù…"  # ÙØ§ØµÙ„Ø© Ø¹Ø§Ø¯ÙŠØ© ","
        
        return {"egp": formatted_egp}
    
    @classmethod
    def get_platform_display_name(cls, platform: str) -> str:
        """Ø¬Ù„Ø¨ Ø§Ø³Ù… Ø§Ù„Ù…Ù†ØµØ© Ù„Ù„Ø¹Ø±Ø¶"""
        platform_names = {
            Platform.PLAYSTATION.value: "ğŸ® PlayStation",
            Platform.XBOX.value: "ğŸ® Xbox", 
            Platform.PC.value: "ğŸ–¥ï¸ PC"
        }
        return platform_names.get(platform, platform)
    
    @classmethod
    def validate_coin_amount(cls, coins: int) -> Tuple[bool, str]:
        """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© ÙƒÙ…ÙŠØ© Ø§Ù„ÙƒÙˆÙŠÙ†Ø²"""
        if coins < 50000:
            return False, "âŒ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ø¨ÙŠØ¹ Ù‡Ùˆ 50,000 ÙƒÙˆÙŠÙ†"
        
        if coins > 10000000:  # 10M max
            return False, "âŒ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø¨ÙŠØ¹ Ù‡Ùˆ 10,000,000 ÙƒÙˆÙŠÙ†"
        
        if coins % 10000 != 0:
            return False, "âŒ ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø§Ù„ÙƒÙ…ÙŠØ© Ù…Ù† Ù…Ø¶Ø§Ø¹ÙØ§Øª 10,000 ÙƒÙˆÙŠÙ†"
        
        return True, "âœ… ÙƒÙ…ÙŠØ© ØµØ­ÙŠØ­Ø©"
    
    @classmethod
    def get_discount_info(cls, coins: int) -> Optional[str]:
        """Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø®ØµÙ… Ø¥Ù† ÙˆØ¬Ø¯"""
        if coins >= 2000000:  # 2M+
            return "ğŸ‰ Ø®ØµÙ… Ø®Ø§Øµ Ù„Ù„ÙƒÙ…ÙŠØ§Øª Ø§Ù„ÙƒØ¨ÙŠØ±Ø©!"
        elif coins >= 1000000:  # 1M+
            return "ğŸ’° Ø³Ø¹Ø± Ù…Ù…ÙŠØ² Ù„Ù„Ù…Ù„ÙŠÙˆÙ† ÙƒÙˆÙŠÙ†!"
        elif coins >= 500000:  # 500K+
            return "â­ Ø¹Ø±Ø¶ Ø®Ø§Øµ Ù„Ù„ÙƒÙ…ÙŠØ§Øª Ø§Ù„Ù…ØªÙˆØ³Ø·Ø©!"
        
        return None
    
    @classmethod
    def get_all_platforms(cls) -> List[str]:
        """Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù†ØµØ§Øª Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ…Ø©"""
        return list(cls.CURRENT_PRICES.keys())
    
    @classmethod 
    def update_price(cls, platform: str, coins: int, new_price: int) -> bool:
        """ØªØ­Ø¯ÙŠØ« Ø³Ø¹Ø± ÙƒÙ…ÙŠØ© Ù…Ø¹ÙŠÙ†Ø© (Ù„Ù„Ø¥Ø¯Ø§Ø±Ø©)"""
        if platform not in cls.CURRENT_PRICES:
            return False
        
        cls.CURRENT_PRICES[platform][coins] = new_price
        return True
    
    @classmethod
    def get_price_comparison(cls) -> Dict:
        """Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø¨ÙŠÙ† Ø§Ù„Ù…Ù†ØµØ§Øª"""
        comparison = {}
        for platform in cls.NORMAL_PRICES:
            comparison[platform] = {
                "platform_name": cls.get_platform_display_name(platform),
                "normal_base_price": cls.NORMAL_PRICES[platform].get(100000, 0),
                "instant_base_price": cls.INSTANT_PRICES[platform].get(100000, 0),
                "price_tiers": len(cls.NORMAL_PRICES[platform])
            }
        
        return comparison
    
    @classmethod
    def get_platform_pricing_message(cls, platform: str) -> str:
        """Ø±Ø³Ø§Ù„Ø© Ø£Ø³Ø¹Ø§Ø± Ù…Ø®ØªØµØ±Ø© - 1M ÙÙ‚Ø· - ØªØ¬Ù„Ø¨ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
        if platform not in cls.NORMAL_PRICES:
            return "âŒ Ù…Ù†ØµØ© ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…Ø©"
        
        platform_name = cls.get_platform_display_name(platform)
        
        # Ø¬Ù„Ø¨ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (Ù†ÙØ³ Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø£Ø²Ø±Ø§Ø±)
        normal_price_1m = cls.get_price(platform, 1000000, "normal")
        instant_price_1m = cls.get_price(platform, 1000000, "instant")
        
        normal_formatted = f"{normal_price_1m:,} Ø¬.Ù…" if normal_price_1m else "ØºÙŠØ± Ù…ØªØ§Ø­"
        instant_formatted = f"{instant_price_1m:,} Ø¬.Ù…" if instant_price_1m else "ØºÙŠØ± Ù…ØªØ§Ø­"
        
        return f"""âœ… ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù†ØµØ©

ğŸ’° Ø£Ø³Ø¹Ø§Ø± {platform_name}:

ğŸ”¸ 1M ÙƒÙˆÙŠÙ†:
   ğŸ“… Ø¹Ø§Ø¯ÙŠ: {normal_formatted}
   âš¡ï¸ ÙÙˆØ±ÙŠ: {instant_formatted}


ğŸ’¡ Ù…Ù„Ø§Ø­Ø¸Ø§Øª:
ğŸ“… Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¹Ø§Ø¯ÙŠ: Ø®Ù„Ø§Ù„ 24 Ø³Ø§Ø¹Ø©
âš¡ï¸ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„ÙÙˆØ±ÙŠ: Ø®Ù„Ø§Ù„ Ø³Ø§Ø¹Ø© ÙˆØ§Ø­Ø¯Ø©

ğŸ¯ Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„:"""

--- FC26_sale_coins_Bot/services/service_template.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘                    ğŸ¯ SERVICE TEMPLATE - Ù‚Ø§Ù„Ø¨ Ø§Ù„Ø®Ø¯Ù…Ø§Øª                    â•‘
# â•‘              Universal Template for Adding New Services                 â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Template Ù„Ø¥Ø¶Ø§ÙØ© Ø®Ø¯Ù…Ø© Ø¬Ø¯ÙŠØ¯Ø© Ø¨Ø¯ÙˆÙ† ØªØ¶Ø§Ø±Ø¨ Ù†Ù‡Ø§Ø¦ÙŠØ§Ù‹

ğŸ“ ÙƒÙŠÙÙŠØ© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:
1. Ø§Ù†Ø³Ø® Ù‡Ø°Ø§ Ø§Ù„Ù…Ù„Ù â†’ `services/my_service.py`
2. ØºÙŠÙ‘Ø± Ø§Ø³Ù… Ø§Ù„Ù€ Class â†’ `MyService`
3. ØºÙŠÙ‘Ø± Ø§Ù„Ù€ States â†’ Ø­Ø³Ø¨ Ø®Ø¯Ù…ØªÙƒ
4. Ø§ÙƒØªØ¨ Ø§Ù„Ù€ handlers
5. Ø³Ø¬Ù‘Ù„ ÙÙŠ main.py

âœ… Ù…Ø¶Ù…ÙˆÙ† 100% Ø¨Ø¯ÙˆÙ† ØªØ¶Ø§Ø±Ø¨!
"""

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import (
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
    ConversationHandler,
    MessageHandler,
    filters,
)

from database.operations import UserOperations
from utils.logger import log_user_action

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# STATES - Ø­Ø¯Ø¯ Ø­Ø§Ù„Ø§Øª Ø®Ø¯Ù…ØªÙƒ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Ù…Ø«Ø§Ù„: Ø®Ø¯Ù…Ø© Ø´Ø±Ø§Ø¡ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²
BUY_PLATFORM, BUY_AMOUNT, BUY_PAYMENT = range(3)


class BuyCoinsService:
    """
    Ù…Ø«Ø§Ù„ Ø¹Ù„Ù‰ Ø®Ø¯Ù…Ø© Ø¬Ø¯ÙŠØ¯Ø© - Ø´Ø±Ø§Ø¡ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²

    ğŸ“ Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø¯Ù…Ø© Ø¬Ø¯ÙŠØ¯Ø©:
    1. ØºÙŠÙ‘Ø± Ø§Ø³Ù… Ø§Ù„Ù€ Class
    2. ØºÙŠÙ‘Ø± Ø§Ù„Ù€ States
    3. ØºÙŠÙ‘Ø± entry_points (/buy â†’ /yourcommand)
    4. Ø¹Ø¯Ù‘Ù„ Ø§Ù„Ù€ handlers Ø­Ø³Ø¨ Ø§Ø­ØªÙŠØ§Ø¬Ùƒ
    """

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ENTRY POINT - Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @staticmethod
    async def start_buy(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """
        Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© - /buy

        Ù‡Ù†Ø§ ØªØ¨Ø¯Ø£ Ø§Ù„Ø®Ø¯Ù…Ø© Ø¹Ù†Ø¯ ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø£Ù…Ø±
        """
        user_id = update.effective_user.id

        print(f"ğŸ’° [BUY] Service started for user {user_id}")
        log_user_action(user_id, "Started buy coins service")

        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØ³Ø¬ÙŠÙ„ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)
        user_data = UserOperations.get_user_data(user_id)
        if not user_data or user_data.get("registration_step") != "completed":
            await update.message.reply_text(
                "âŒ <b>ÙŠØ¬Ø¨ Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø£ÙˆÙ„Ø§Ù‹!</b>\n\nğŸš€ /start Ù„Ù„ØªØ³Ø¬ÙŠÙ„",
                parse_mode="HTML",
            )
            return ConversationHandler.END

        # Ø¹Ø±Ø¶ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ø£ÙˆÙ„Ù‰
        keyboard = [
            [InlineKeyboardButton("ğŸ® PlayStation", callback_data="buy_ps")],
            [InlineKeyboardButton("ğŸ® Xbox", callback_data="buy_xbox")],
            [InlineKeyboardButton("ğŸ–¥ï¸ PC", callback_data="buy_pc")],
            [InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="buy_cancel")],
        ]

        await update.message.reply_text(
            "ğŸ’° <b>Ø´Ø±Ø§Ø¡ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²</b>\n\nğŸ® Ø§Ø®ØªØ± Ù…Ù†ØµØªÙƒ:",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="HTML",
        )

        return BUY_PLATFORM

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # STATE HANDLERS - Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø­Ø§Ù„Ø§Øª
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @staticmethod
    async def choose_platform(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ - Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù†ØµØ©"""
        query = update.callback_query
        await query.answer()

        # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¥Ù„ØºØ§Ø¡
        if query.data == "buy_cancel":
            await query.edit_message_text("âŒ ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø´Ø±Ø§Ø¡")
            return ConversationHandler.END

        user_id = query.from_user.id
        platform = query.data.replace("buy_", "")

        # Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ context
        context.user_data["buy_platform"] = platform

        print(f"ğŸ® [BUY] User {user_id} selected: {platform}")
        log_user_action(user_id, f"Selected platform: {platform}")

        # Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ù„Ù„Ø­Ø§Ù„Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©
        await query.edit_message_text(
            f"âœ… Ø§Ø®ØªØ±Øª: {platform}\n\nğŸ’° Ø£Ø¯Ø®Ù„ Ø§Ù„ÙƒÙ…ÙŠØ© (Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù…):",
            parse_mode="HTML",
        )

        return BUY_AMOUNT

    @staticmethod
    async def enter_amount(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ© - Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„ÙƒÙ…ÙŠØ©"""
        user_id = update.effective_user.id
        text = update.message.text.strip()

        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª
        if not text.isdigit():
            await update.message.reply_text("âŒ Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·! Ø£Ø¹Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©:")
            return BUY_AMOUNT

        amount = int(text)

        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¯ÙˆØ¯
        if amount < 100:
            await update.message.reply_text("âŒ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰: 100 ÙƒÙˆÙŠÙ†\nØ£Ø¹Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©:")
            return BUY_AMOUNT

        # Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        context.user_data["buy_amount"] = amount

        print(f"ğŸ’° [BUY] User {user_id} amount: {amount}")

        # Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ù„Ù„Ø­Ø§Ù„Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©
        await update.message.reply_text(
            f"âœ… Ø§Ù„ÙƒÙ…ÙŠØ©: {amount:,} ÙƒÙˆÙŠÙ†\n\nğŸ’³ Ø£Ø¯Ø®Ù„ Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹:",
            parse_mode="HTML",
        )

        return BUY_PAYMENT

    @staticmethod
    async def enter_payment(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø«Ø§Ù„Ø«Ø© (Ø§Ù„Ø£Ø®ÙŠØ±Ø©) - Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¯ÙØ¹"""
        user_id = update.effective_user.id
        payment = update.message.text.strip()

        # Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©
        platform = context.user_data.get("buy_platform", "unknown")
        amount = context.user_data.get("buy_amount", 0)

        # Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø«Ù„Ø§Ù‹)
        # YourDatabase.save_buy_order(user_id, platform, amount, payment)

        # Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù†Ø¬Ø§Ø­
        await update.message.reply_text(
            f"âœ… <b>ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø·Ù„Ø¨ Ø§Ù„Ø´Ø±Ø§Ø¡!</b>\n\n"
            f"ğŸ® Ø§Ù„Ù…Ù†ØµØ©: {platform}\n"
            f"ğŸ’° Ø§Ù„ÙƒÙ…ÙŠØ©: {amount:,} ÙƒÙˆÙŠÙ†\n"
            f"ğŸ’³ Ø§Ù„Ø¯ÙØ¹: {payment}\n\n"
            f"ğŸ“ Ø³ÙŠØªÙ… Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ Ù‚Ø±ÙŠØ¨Ø§Ù‹!\n\n"
            f"ğŸ”¹ /buy Ù„Ù„Ø´Ø±Ø§Ø¡ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰",
            parse_mode="HTML",
        )

        log_user_action(
            user_id,
            f"Completed buy order: {amount} coins, platform: {platform}",
        )

        # Ù…Ø³Ø­ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        context.user_data.clear()
        print(f"âœ… [BUY] Order completed for user {user_id}")

        # Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
        return ConversationHandler.END

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # FALLBACKS - Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø¥Ù„ØºØ§Ø¡
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @staticmethod
    async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© ÙÙŠ Ø£ÙŠ ÙˆÙ‚Øª - /cancel"""
        user_id = update.effective_user.id

        print(f"âŒ [BUY] User {user_id} cancelled")
        log_user_action(user_id, "Cancelled buy service")

        await update.message.reply_text(
            "âŒ ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø´Ø±Ø§Ø¡\n\nğŸ”¹ /buy Ù„Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯"
        )

        context.user_data.clear()
        return ConversationHandler.END

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # CONVERSATION HANDLER - Ø§Ù„ØªØ³Ø¬ÙŠÙ„
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @staticmethod
    def get_conversation_handler():
        """
        Ø¥Ù†Ø´Ø§Ø¡ ConversationHandler Ù„Ù„Ø®Ø¯Ù…Ø©

        ğŸ“ Ù‡Ø°Ø§ Ù‡Ùˆ Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„ÙˆØ­ÙŠØ¯ Ø§Ù„Ù„ÙŠ Ù‡ØªØ³Ø¬Ù„Ù‡ ÙÙŠ main.py
        """
        return ConversationHandler(
            # Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© - Ø§Ù„Ø£Ù…Ø± Ø§Ù„Ù„ÙŠ ÙŠØ¨Ø¯Ø£ Ø§Ù„Ø®Ø¯Ù…Ø©
            entry_points=[CommandHandler("buy", BuyCoinsService.start_buy)],
            # Ø§Ù„Ø­Ø§Ù„Ø§Øª - ÙƒÙ„ Ø­Ø§Ù„Ø© Ù„ÙŠÙ‡Ø§ handlers Ø®Ø§ØµØ©
            states={
                BUY_PLATFORM: [
                    CallbackQueryHandler(
                        BuyCoinsService.choose_platform,
                        pattern="^buy_",  # ÙÙ‚Ø· callbacks ØªØ¨Ø¯Ø£ Ø¨Ù€ buy_
                    )
                ],
                BUY_AMOUNT: [
                    MessageHandler(
                        filters.TEXT & ~filters.COMMAND,
                        BuyCoinsService.enter_amount,
                    )
                ],
                BUY_PAYMENT: [
                    MessageHandler(
                        filters.TEXT & ~filters.COMMAND,
                        BuyCoinsService.enter_payment,
                    )
                ],
            },
            # Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø¥Ù„ØºØ§Ø¡ - ØªØ´ØªØºÙ„ ÙÙŠ Ø£ÙŠ Ø­Ø§Ù„Ø©
            fallbacks=[CommandHandler("cancel", BuyCoinsService.cancel)],
            # Ø§Ø³Ù… ÙØ±ÙŠØ¯ Ù„Ù„Ø®Ø¯Ù…Ø©
            name="buy_coins_conversation",
            # Ø­ÙØ¸ Ø§Ù„Ø­Ø§Ù„Ø© (True = ÙŠØ­ÙØ¸ Ø§Ù„Ø­Ø§Ù„Ø© Ø­ØªÙ‰ Ù„Ùˆ Ø§Ù„Ø¨ÙˆØª ØªÙˆÙ‚Ù)
            persistent=False,
        )


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ÙƒÙŠÙÙŠØ© Ø§Ù„ØªØ³Ø¬ÙŠÙ„ ÙÙŠ main.py:
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
ÙÙŠ Ù…Ù„Ù main.pyØŒ ÙÙŠ method start_bot():

# 1. Ø§Ø³ØªÙˆØ±Ø¯ Ø§Ù„Ø®Ø¯Ù…Ø©
from services.service_template import BuyCoinsService

# 2. Ø³Ø¬Ù‘Ù„ Ø§Ù„Ù€ conversation
buy_conv = BuyCoinsService.get_conversation_handler()
self.app.add_handler(buy_conv)
print("âœ… [4] Buy coins conversation registered")

âœ… Ø®Ù„Ø§Øµ! Ù…Ø§ÙÙŠØ´ ØªØ¶Ø§Ø±Ø¨ Ø£Ø¨Ø¯Ø§Ù‹!
"""


--- FC26_sale_coins_Bot/states/__init__.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘                 ğŸ¯ FC26 STATES - Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ù…Ø®ØªÙ„ÙØ©                    â•‘
# â•‘                           Bot States Package                             â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from .sell_states import SellStates

__all__ = ['SellStates']

--- FC26_sale_coins_Bot/states/sell_states.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘                ğŸ¯ FC26 SELL STATES - Ø­Ø§Ù„Ø§Øª Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²                  â•‘
# â•‘                       Sell Conversation States                          â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SellStates:
    """Ø­Ø§Ù„Ø§Øª Ù…Ø­Ø§Ø¯Ø«Ø© Ø¨ÙŠØ¹ Ø§Ù„ÙƒÙˆÙŠÙ†Ø²"""
    CHOOSE_PLATFORM = "choose_platform"
    CHOOSE_TYPE = "choose_type"
    ENTER_AMOUNT = "enter_amount"
    CONFIRM_SALE = "confirm_sale"

--- FC26_sale_coins_Bot/utils/__init__.py ---



--- FC26_sale_coins_Bot/utils/backup_job.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘                    ğŸ’¾ BACKUP JOB SYSTEM                                  â•‘
# â•‘                  Ù†Ø¸Ø§Ù… Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ                          â•‘
# â•‘            Ø­Ù…Ø§ÙŠØ© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ù…Ù† Ø§Ù„ÙÙ‚Ø¯Ø§Ù†                             â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
ğŸ’¾ Ù†Ø¸Ø§Ù… Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ Ø§Ù„ÙŠÙˆÙ…ÙŠ

Ø§Ù„Ù‡Ø¯Ù:
-------
Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø¯ÙˆØ±ÙŠØ© Ù…Ù† Ù…Ù„Ù Ø§Ù„Ø¬Ù„Ø³Ø§Øª ÙƒØ·Ø¨Ù‚Ø© Ø£Ù…Ø§Ù† Ø¥Ø¶Ø§ÙÙŠØ©.

Ø§Ù„Ù…ÙŠØ²Ø§Øª:
--------
âœ… Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠ ÙŠÙˆÙ…ÙŠ ÙÙŠ ÙˆÙ‚Øª Ù…Ø­Ø¯Ø¯ (3 ØµØ¨Ø§Ø­Ø§Ù‹)
âœ… Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠ Ø¹Ù†Ø¯ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ´ØºÙŠÙ„ (Ø¨Ø¹Ø¯ Ø³Ø§Ø¹Ø©)
âœ… Ø­Ø°Ù ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„Ù†Ø³Ø® Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© (Ø£ÙƒØ«Ø± Ù…Ù† 7 Ø£ÙŠØ§Ù…)
âœ… ØªÙ†Ø¸ÙŠÙ… ÙÙŠ Ù…Ø¬Ù„Ø¯ data/backups/
"""

import shutil
from datetime import datetime, timedelta, time
from pathlib import Path


async def daily_backup_job(context):
    """
    ÙˆØ¸ÙŠÙØ© Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ Ø§Ù„ÙŠÙˆÙ…ÙŠ

    ØªÙ‚ÙˆÙ… Ø¨Ù€:
    1. Ù†Ø³Ø® Ù…Ù„Ù Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
    2. Ø­ÙØ¸Ù‡ ÙÙŠ Ù…Ø¬Ù„Ø¯ backups/ Ø¨Ø§Ø³Ù… ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø§Ù„ØªØ§Ø±ÙŠØ®
    3. Ø­Ø°Ù Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø£Ù‚Ø¯Ù… Ù…Ù† 7 Ø£ÙŠØ§Ù…

    Args:
        context: telegram.ext.ContextTypes.DEFAULT_TYPE
    """
    print(f"\n{'='*80}")
    print(f"ğŸ’¾ [BACKUP-JOB] Starting daily backup...")
    print(f"{'='*80}")

    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø£ØµÙ„ÙŠ
    source = Path("data/sessions.pkl")
    if not source.exists():
        print(f"   âš ï¸ [BACKUP-JOB] Source file not found: {source}")
        print(f"{'='*80}\n")
        return

    # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù„Ø¯ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ
    backup_dir = Path("data/backups")
    backup_dir.mkdir(parents=True, exist_ok=True)
    print(f"   âœ… [BACKUP-JOB] Backup directory ready: {backup_dir}")

    # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ø³Ù… Ø§Ù„Ù…Ù„Ù Ø¨Ø§Ù„ØªØ§Ø±ÙŠØ®
    today = datetime.now().strftime("%Y%m%d")
    backup_path = backup_dir / f"sessions_{today}.pkl"

    try:
        # Ù†Ø³Ø® Ø§Ù„Ù…Ù„Ù
        shutil.copy2(source, backup_path)
        size_mb = backup_path.stat().st_size / (1024 * 1024)
        print(
            f"   âœ… [BACKUP-JOB] Backup created: {backup_path.name} ({size_mb:.2f} MB)"
        )
    except Exception as e:
        print(f"   âŒ [BACKUP-JOB] Failed to create backup: {e}")
        print(f"{'='*80}\n")
        return

    # Ø­Ø°Ù Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
    print(f"   ğŸ§¹ [BACKUP-JOB] Cleaning old backups...")
    cutoff = datetime.now() - timedelta(days=7)
    deleted_count = 0

    for backup_file in backup_dir.glob("sessions_*.pkl"):
        try:
            # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ØªØ§Ø±ÙŠØ® Ù…Ù† Ø§Ø³Ù… Ø§Ù„Ù…Ù„Ù
            date_str = backup_file.stem.split("_")[1]
            file_date = datetime.strptime(date_str, "%Y%m%d")

            # Ø­Ø°Ù Ø¥Ø°Ø§ ÙƒØ§Ù† Ø£Ù‚Ø¯Ù… Ù…Ù† 7 Ø£ÙŠØ§Ù…
            if file_date < cutoff:
                backup_file.unlink()
                deleted_count += 1
                print(f"      ğŸ—‘ï¸ Deleted old backup: {backup_file.name}")
        except Exception as e:
            print(f"      âš ï¸ Error processing {backup_file.name}: {e}")

    if deleted_count == 0:
        print(f"      âœ… No old backups to delete")
    else:
        print(f"      âœ… Deleted {deleted_count} old backup(s)")

    print(f"{'='*80}")
    print(f"âœ… [BACKUP-JOB] Daily backup completed successfully")
    print(f"{'='*80}\n")


def register_backup_job(app):
    """
    ØªØ³Ø¬ÙŠÙ„ ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ ÙÙŠ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø²Ù…Ù†ÙŠ

    ÙŠÙ‚ÙˆÙ… Ø¨ØªØ³Ø¬ÙŠÙ„:
    1. Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠ ÙŠÙˆÙ…ÙŠ ÙÙŠ Ø§Ù„Ø³Ø§Ø¹Ø© 3 ØµØ¨Ø§Ø­Ø§Ù‹
    2. Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠ Ø¹Ù†Ø¯ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ´ØºÙŠÙ„ (Ø¨Ø¹Ø¯ Ø³Ø§Ø¹Ø©)

    Args:
        app: telegram.ext.Application
    """
    print("\nğŸ’¾ [BACKUP-SYSTEM] Registering backup jobs...")

    # Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠ ÙŠÙˆÙ…ÙŠ ÙÙŠ 3 ØµØ¨Ø§Ø­Ø§Ù‹
    app.job_queue.run_daily(
        daily_backup_job,
        time=time(hour=3, minute=0),
        name="daily_backup",
    )
    print("   âœ… Daily backup scheduled: 03:00 AM")

    # Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠ Ø¨Ø¹Ø¯ Ø³Ø§Ø¹Ø© Ù…Ù† Ø§Ù„Ø¨Ø¯Ø¡ (Ø§Ø­ØªØ±Ø§Ø²ÙŠ)
    app.job_queue.run_once(
        daily_backup_job,
        when=3600,  # 1 Ø³Ø§Ø¹Ø© Ø¨Ø§Ù„Ø«ÙˆØ§Ù†ÙŠ
        name="startup_backup",
    )
    print("   âœ… Startup backup scheduled: 1 hour after start")

    print("ğŸ’¾ [BACKUP-SYSTEM] Backup jobs registered successfully\n")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ› ï¸ UTILITY FUNCTIONS (Ø¥Ø¶Ø§ÙÙŠØ©)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


def list_backups() -> list:
    """
    Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©

    Returns:
        list: Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ù„ÙØ§Øª ÙˆØ£Ø­Ø¬Ø§Ù…Ù‡Ø§
    """
    backup_dir = Path("data/backups")
    if not backup_dir.exists():
        return []

    backups = []
    for backup_file in sorted(backup_dir.glob("sessions_*.pkl"), reverse=True):
        size_mb = backup_file.stat().st_size / (1024 * 1024)
        backups.append(
            {
                "name": backup_file.name,
                "date": backup_file.stem.split("_")[1],
                "size_mb": round(size_mb, 2),
            }
        )

    return backups


def restore_from_backup(backup_name: str) -> bool:
    """
    Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ù…Ù† Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©

    Args:
        backup_name: Ø§Ø³Ù… Ù…Ù„Ù Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©

    Returns:
        bool: True Ø¥Ø°Ø§ Ù†Ø¬Ø­Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ©

    âš ï¸ ØªØ­Ø°ÙŠØ±: Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© Ø®Ø·ÙŠØ±Ø©! ØªÙØ³ØªØ®Ø¯Ù… ÙÙ‚Ø· ÙÙŠ Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø·ÙˆØ§Ø±Ø¦
    """
    backup_file = Path("data/backups") / backup_name
    if not backup_file.exists():
        print(f"âŒ Backup file not found: {backup_name}")
        return False

    session_file = Path("data/sessions.pkl")

    try:
        # Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ù…Ù† Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø­Ø§Ù„ÙŠ Ø£ÙˆÙ„Ø§Ù‹
        if session_file.exists():
            emergency_backup = Path("data/sessions_emergency_backup.pkl")
            shutil.copy2(session_file, emergency_backup)
            print(f"   ğŸ’¾ Emergency backup created: {emergency_backup.name}")

        # Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ù…Ù† Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©
        shutil.copy2(backup_file, session_file)
        print(f"   âœ… Restored from: {backup_name}")
        return True

    except Exception as e:
        print(f"   âŒ Restore failed: {e}")
        return False


--- FC26_sale_coins_Bot/utils/handler_filters.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘                   ğŸ¯ SMART FILTERS - Ù…Ù†Ø¹ Ø§Ù„ØªØ¶Ø§Ø±Ø¨ Ø§Ù„ÙƒØ§Ù…Ù„                 â•‘
# â•‘              Handler Conflict Prevention - Zero Overlaps                â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
ÙÙ„Ø§ØªØ± Ø°ÙƒÙŠØ© Ù„Ù…Ù†Ø¹ ØªØ¶Ø§Ø±Ø¨ Ø§Ù„Ù€ handlers ØªÙ…Ø§Ù…Ø§Ù‹

Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©:
- ÙƒÙ„ handler Ø¨ÙŠØ´ÙˆÙ Ø±Ø³Ø§Ø¦Ù„Ù‡ ÙÙ‚Ø·
- Ø§Ù„ÙÙ„Ø§ØªØ± Ø¨ØªØ±ÙØ¶ Ø¨Ø³Ø±Ø¹Ø© Ù„Ùˆ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù…Ø´ Ù„ÙŠÙ‡Ø§
- ØµÙØ± manual checks Ø¯Ø§Ø®Ù„ Ø§Ù„Ù€ handlers
"""

from telegram.ext import filters


class AdminSessionFilter(filters.MessageFilter):
    """
    ÙÙ„ØªØ± Ø§Ù„Ø£Ø¯Ù…Ù† - ÙŠÙ‚Ø¨Ù„ ÙÙ‚Ø·:
    - Ø±Ø³Ø§Ø¦Ù„ Ù…Ù† Ø§Ù„Ø£Ø¯Ù…Ù†
    - Ø§Ù„Ø£Ø¯Ù…Ù† Ø¹Ù†Ø¯Ù‡ session Ù†Ø´Ø·
    - Ø§Ù„Ù€ session ÙÙŠ Ø®Ø·ÙˆØ© "waiting_price"
    """

    def __init__(self, admin_handler):
        """
        Args:
            admin_handler: Ù…Ø±Ø¬Ø¹ Ù„Ù€ AdminHandler instance
        """
        self.admin_handler = admin_handler
        super().__init__()

    def filter(self, message):
        """
        Returns:
            True: Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ø£Ø¯Ù…Ù† Ù…Ø¹ session Ù†Ø´Ø·
            False: Ø£ÙŠ Ø­Ø§Ù„Ø© ØªØ§Ù†ÙŠØ© (silent rejection)
        """
        # Ù„Ùˆ Ù…Ø§ÙÙŠØ´ admin handler Ø£ØµÙ„Ø§Ù‹
        if not self.admin_handler:
            return False

        user_id = message.from_user.id

        # 1. Ù‡Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… adminØŸ
        if user_id != self.admin_handler.ADMIN_ID:
            return False

        # 2. Ù‡Ù„ Ø¹Ù†Ø¯Ù‡ session Ù†Ø´Ø·ØŸ
        if user_id not in self.admin_handler.user_sessions:
            return False

        # 3. Ù‡Ù„ Ø§Ù„Ù€ session ÙÙŠ Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„ØµØ­ÙŠØ­Ø©ØŸ
        session = self.admin_handler.user_sessions[user_id]
        if session.get("step") != "waiting_price":
            return False

        # âœ… ÙƒÙ„ Ø§Ù„Ø´Ø±ÙˆØ· ØªÙ…Ø§Ù… - Ù‚Ø¨ÙˆÙ„!
        print(f"âœ… [ADMIN-FILTER] Admin {user_id} session active â†’ ACCEPT")
        return True


class SellSessionFilter(filters.MessageFilter):
    """
    ÙÙ„ØªØ± Ø§Ù„Ø¨ÙŠØ¹ - ÙŠÙ‚Ø¨Ù„ ÙÙ‚Ø·:
    - Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø¹Ù†Ø¯Ù‡Ù… sell session Ù†Ø´Ø·
    - Ø§Ù„Ù€ session ÙÙŠ Ø®Ø·ÙˆØ© Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„ÙƒÙ…ÙŠØ©
    """

    def __init__(self, sell_handler):
        """
        Args:
            sell_handler: Ù…Ø±Ø¬Ø¹ Ù„Ù€ SellCoinsHandler instance
        """
        self.sell_handler = sell_handler
        super().__init__()

    def filter(self, message):
        """
        Returns:
            True: Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¹ sell session Ù†Ø´Ø·
            False: Ø£ÙŠ Ø­Ø§Ù„Ø© ØªØ§Ù†ÙŠØ© (silent rejection)
        """
        user_id = message.from_user.id

        # 1. Ù‡Ù„ Ø¹Ù†Ø¯Ù‡ sell sessionØŸ
        if user_id not in self.sell_handler.user_sessions:
            return False

        # 2. Ù‡Ù„ Ø§Ù„Ù€ session ÙÙŠ Ø®Ø·ÙˆØ© Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„ÙƒÙ…ÙŠØ©ØŸ
        session = self.sell_handler.user_sessions[user_id]
        step = session.get("step")

        valid_steps = ["amount_input", "custom_amount_input"]
        if step not in valid_steps:
            return False

        # âœ… Ø¹Ù†Ø¯Ù‡ session Ù†Ø´Ø· - Ù‚Ø¨ÙˆÙ„!
        print(
            f"âœ… [SELL-FILTER] User {user_id} sell session active (step: {step}) â†’ ACCEPT"
        )
        return True


class RegistrationFilter(filters.MessageFilter):
    """
    ÙÙ„ØªØ± Ø§Ù„ØªØ³Ø¬ÙŠÙ„ - ÙŠÙ‚Ø¨Ù„ ÙÙ‚Ø·:
    - Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø¨Ø¯ÙˆÙ† Ø£ÙŠ sessions Ø£Ø®Ø±Ù‰ (admin/sell)
    - Ù„Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¹Ø§Ø¯ÙŠ ÙÙ‚Ø·
    """

    def __init__(self, admin_handler, sell_handler):
        """
        Args:
            admin_handler: Ù…Ø±Ø¬Ø¹ Ù„Ù€ AdminHandler instance
            sell_handler: Ù…Ø±Ø¬Ø¹ Ù„Ù€ SellCoinsHandler instance
        """
        self.admin_handler = admin_handler
        self.sell_handler = sell_handler
        super().__init__()

    def filter(self, message):
        """
        Returns:
            True: Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø¯ÙˆÙ† Ø£ÙŠ sessions Ù†Ø´Ø·Ø©
            False: Ø¹Ù†Ø¯Ù‡ session ÙÙŠ Ø®Ø¯Ù…Ø© ØªØ§Ù†ÙŠØ©
        """
        user_id = message.from_user.id

        # 1. ØªØ­Ù‚Ù‚ Ù…Ù† admin session
        if self.admin_handler and user_id in self.admin_handler.user_sessions:
            print(f"â­ï¸ [REG-FILTER] User {user_id} has admin session â†’ REJECT")
            return False

        # 2. ØªØ­Ù‚Ù‚ Ù…Ù† sell session
        if user_id in self.sell_handler.user_sessions:
            print(f"â­ï¸ [REG-FILTER] User {user_id} has sell session â†’ REJECT")
            return False

        # âœ… Ù…Ø§ÙÙŠØ´ sessions ØªØ§Ù†ÙŠØ© - Ù‚Ø¨ÙˆÙ„!
        print(f"âœ… [REG-FILTER] User {user_id} clean (no sessions) â†’ ACCEPT")
        return True


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FACTORY FUNCTIONS - Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙÙ„Ø§ØªØ± Ø¨Ø³Ù‡ÙˆÙ„Ø©
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


class HandlerFilters:
    """Factory class Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙÙ„Ø§ØªØ± Ø§Ù„Ø°ÙƒÙŠØ©"""

    @staticmethod
    def create_admin_filter(admin_handler):
        """Ø¥Ù†Ø´Ø§Ø¡ ÙÙ„ØªØ± Ø§Ù„Ø£Ø¯Ù…Ù†"""
        return AdminSessionFilter(admin_handler)

    @staticmethod
    def create_sell_filter(sell_handler):
        """Ø¥Ù†Ø´Ø§Ø¡ ÙÙ„ØªØ± Ø§Ù„Ø¨ÙŠØ¹"""
        return SellSessionFilter(sell_handler)

    @staticmethod
    def create_registration_filter(admin_handler, sell_handler):
        """Ø¥Ù†Ø´Ø§Ø¡ ÙÙ„ØªØ± Ø§Ù„ØªØ³Ø¬ÙŠÙ„"""
        return RegistrationFilter(admin_handler, sell_handler)


--- FC26_sale_coins_Bot/utils/locks.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ”’ FC26 LOCKS - Ù†Ø¸Ø§Ù… Ø§Ù„Ø£Ù‚ÙØ§Ù„ ÙˆØ§Ù„Ø­Ù…Ø§ÙŠØ© Ù…Ù† Ø§Ù„ØªØ¶Ø§Ø±Ø¨             â•‘
# â•‘                      Anti-Conflict Lock System                          â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import asyncio
import time
import logging
from typing import Dict, Any, Optional
from contextlib import asynccontextmanager
from collections import defaultdict

logger = logging.getLogger(__name__)

class UserLockManager:
    """User-specific lock manager to prevent conflicts"""
    
    def __init__(self):
        self.user_locks: Dict[int, asyncio.Lock] = {}
        self.lock_times: Dict[int, float] = {}
        self.lock_counts: Dict[int, int] = defaultdict(int)
        self.active_operations: Dict[int, str] = {}
    
    async def get_user_lock(self, user_id: int) -> asyncio.Lock:
        """Get or create user-specific lock"""
        if user_id not in self.user_locks:
            self.user_locks[user_id] = asyncio.Lock()
            logger.debug(f"ğŸ”’ Created new lock for user {user_id}")
        
        return self.user_locks[user_id]
    
    @asynccontextmanager
    async def acquire_user_lock(self, user_id: int, operation: str = "unknown"):
        """Context manager for acquiring user locks"""
        lock = await self.get_user_lock(user_id)
        
        # Check if user is already performing an operation
        if user_id in self.active_operations:
            current_op = self.active_operations[user_id]
            logger.warning(f"âš ï¸ User {user_id} attempted {operation} while {current_op} is active")
            raise UserBusyException(f"User is currently performing: {current_op}")
        
        start_time = time.time()
        
        try:
            # Acquire lock with timeout
            await asyncio.wait_for(lock.acquire(), timeout=30.0)
            
            # Record operation start
            self.lock_times[user_id] = start_time
            self.lock_counts[user_id] += 1
            self.active_operations[user_id] = operation
            
            logger.debug(f"ğŸ”“ Lock acquired for user {user_id} - operation: {operation}")
            
            yield lock
            
        except asyncio.TimeoutError:
            logger.error(f"â° Lock acquisition timeout for user {user_id}")
            raise LockTimeoutException(f"Could not acquire lock for user {user_id}")
        
        finally:
            # Release lock and clean up
            if lock.locked():
                lock.release()
            
            # Record operation end
            if user_id in self.active_operations:
                del self.active_operations[user_id]
            
            end_time = time.time()
            duration = end_time - start_time
            
            logger.debug(f"ğŸ”’ Lock released for user {user_id} - duration: {duration:.2f}s")
    
    def is_user_busy(self, user_id: int) -> bool:
        """Check if user is currently performing an operation"""
        return user_id in self.active_operations
    
    def get_user_operation(self, user_id: int) -> Optional[str]:
        """Get current operation for user"""
        return self.active_operations.get(user_id)
    
    def cleanup_user_locks(self, inactive_minutes: int = 30):
        """Clean up inactive user locks"""
        current_time = time.time()
        inactive_threshold = inactive_minutes * 60
        
        users_to_cleanup = []
        
        for user_id, lock_time in self.lock_times.items():
            if current_time - lock_time > inactive_threshold:
                if user_id not in self.active_operations:
                    users_to_cleanup.append(user_id)
        
        for user_id in users_to_cleanup:
            if user_id in self.user_locks:
                del self.user_locks[user_id]
            if user_id in self.lock_times:
                del self.lock_times[user_id]
            if user_id in self.lock_counts:
                del self.lock_counts[user_id]
            
            logger.info(f"ğŸ§¹ Cleaned up inactive lock for user {user_id}")
        
        return len(users_to_cleanup)
    
    def get_lock_statistics(self) -> Dict[str, Any]:
        """Get lock usage statistics"""
        return {
            'active_locks': len(self.active_operations),
            'total_locks_created': len(self.user_locks),
            'lock_usage_counts': dict(self.lock_counts),
            'active_operations': dict(self.active_operations)
        }

class MessageLockManager:
    """Message-specific lock manager for preventing message conflicts"""
    
    def __init__(self):
        self.active_messages: Dict[int, int] = {}  # user_id -> message_id
        self.message_locks: Dict[int, asyncio.Lock] = {}
    
    async def set_active_message(self, user_id: int, message_id: int):
        """Set active message for user"""
        async with await self._get_message_lock(user_id):
            old_message_id = self.active_messages.get(user_id)
            self.active_messages[user_id] = message_id
            
            logger.debug(f"ğŸ“± Active message updated for user {user_id}: {old_message_id} -> {message_id}")
            
            return old_message_id
    
    async def get_active_message(self, user_id: int) -> Optional[int]:
        """Get active message ID for user"""
        return self.active_messages.get(user_id)
    
    async def clear_active_message(self, user_id: int) -> Optional[int]:
        """Clear active message for user"""
        async with await self._get_message_lock(user_id):
            old_message_id = self.active_messages.pop(user_id, None)
            logger.debug(f"ğŸ—‘ï¸ Cleared active message for user {user_id}: {old_message_id}")
            return old_message_id
    
    async def _get_message_lock(self, user_id: int) -> asyncio.Lock:
        """Get message lock for user"""
        if user_id not in self.message_locks:
            self.message_locks[user_id] = asyncio.Lock()
        return self.message_locks[user_id]

class RateLimitManager:
    """Rate limiting manager to prevent spam and abuse"""
    
    def __init__(self, max_requests: int = 10, time_window: int = 60):
        self.max_requests = max_requests
        self.time_window = time_window
        self.user_requests: Dict[int, list] = defaultdict(list)
    
    def is_rate_limited(self, user_id: int) -> bool:
        """Check if user is rate limited"""
        current_time = time.time()
        
        # Clean old requests
        self.user_requests[user_id] = [
            req_time for req_time in self.user_requests[user_id]
            if current_time - req_time < self.time_window
        ]
        
        # Check rate limit
        if len(self.user_requests[user_id]) >= self.max_requests:
            logger.warning(f"ğŸš« Rate limit exceeded for user {user_id}")
            return True
        
        # Record new request
        self.user_requests[user_id].append(current_time)
        return False
    
    def get_remaining_requests(self, user_id: int) -> int:
        """Get remaining requests for user"""
        current_requests = len(self.user_requests[user_id])
        return max(0, self.max_requests - current_requests)

# Custom Exceptions
class UserBusyException(Exception):
    """Raised when user is busy with another operation"""
    pass

class LockTimeoutException(Exception):
    """Raised when lock acquisition times out"""
    pass

# Global instances
user_lock_manager = UserLockManager()
message_lock_manager = MessageLockManager()
rate_limit_manager = RateLimitManager()

# Convenience functions
async def get_user_lock(user_id: int) -> asyncio.Lock:
    """Get user lock - backwards compatibility"""
    return await user_lock_manager.get_user_lock(user_id)

async def acquire_user_lock(user_id: int, operation: str = "unknown"):
    """Acquire user lock with context manager"""
    return user_lock_manager.acquire_user_lock(user_id, operation)

def is_user_busy(user_id: int) -> bool:
    """Check if user is busy"""
    return user_lock_manager.is_user_busy(user_id)

def is_rate_limited(user_id: int) -> bool:
    """Check rate limit"""
    return rate_limit_manager.is_rate_limited(user_id)

--- FC26_sale_coins_Bot/utils/logger.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ“ FC26 LOGGER - Ù†Ø¸Ø§Ù… Ø§Ù„Ø³Ø¬Ù„Ø§Øª                               â•‘
# â•‘                         Logging System                                  â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import logging
import os
from logging.handlers import RotatingFileHandler, TimedRotatingFileHandler
from datetime import datetime
from config import LOGGING_CONFIG

class FC26Logger:
    """Enhanced logging system for FC26 Bot"""
    
    def __init__(self):
        self.logger = None
        self.setup_logger()
    
    def setup_logger(self):
        """Setup comprehensive logging system"""
        
        # Create logs directory if it doesn't exist
        log_dir = os.path.dirname(LOGGING_CONFIG['file'])
        os.makedirs(log_dir, exist_ok=True)
        
        # Create logger
        self.logger = logging.getLogger('FC26_Bot')
        self.logger.setLevel(getattr(logging, LOGGING_CONFIG['level']))
        
        # Clear existing handlers
        self.logger.handlers.clear()
        
        # Console handler only (no file logging)
        console_handler = logging.StreamHandler()
        console_handler.setLevel(logging.INFO)
        
        # Formatter
        formatter = logging.Formatter(
            LOGGING_CONFIG['format'],
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        
        # Set formatters
        console_handler.setFormatter(formatter)
        
        # Add handlers
        self.logger.addHandler(console_handler)
        
        # Initial log
        self.logger.info("ğŸš€ FC26 Bot Logger initialized successfully")
    
    def log_user_action(self, user_id: int, action: str, details: str = None):
        """Log user actions"""
        log_message = f"ğŸ‘¤ User {user_id}: {action}"
        if details:
            log_message += f" | Details: {details}"
        self.logger.info(log_message)
    
    def log_registration_step(self, user_id: int, step: str, success: bool = True):
        """Log registration steps"""
        status = "âœ…" if success else "âŒ"
        self.logger.info(f"{status} User {user_id} registration step: {step}")
    
    def log_validation_error(self, user_id: int, field: str, error: str):
        """Log validation errors"""
        self.logger.warning(f"âš ï¸ Validation error - User {user_id}, Field: {field}, Error: {error}")
    
    def log_database_operation(self, operation: str, user_id: int = None, success: bool = True):
        """Log database operations"""
        status = "âœ…" if success else "âŒ"
        user_info = f"User {user_id}" if user_id else "System"
        self.logger.info(f"{status} DB Operation: {operation} | {user_info}")
    
    def log_security_event(self, user_id: int, event: str, details: str = None):
        """Log security-related events"""
        log_message = f"ğŸ›¡ï¸ SECURITY: User {user_id} - {event}"
        if details:
            log_message += f" | Details: {details}"
        self.logger.warning(log_message)
    
    def log_performance_metric(self, operation: str, duration: float, user_id: int = None):
        """Log performance metrics"""
        user_info = f"User {user_id}" if user_id else "System"
        self.logger.info(f"ğŸ“Š Performance: {operation} took {duration:.2f}s | {user_info}")
    
    def log_bot_start(self):
        """Log bot startup"""
        self.logger.info("="*60)
        self.logger.info("ğŸ® FC26 Gaming Bot Starting...")
        self.logger.info(f"â° Start Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        self.logger.info("="*60)
    
    def log_bot_stop(self):
        """Log bot shutdown"""
        self.logger.info("="*60)
        self.logger.info("ğŸ”´ FC26 Gaming Bot Shutting Down...")
        self.logger.info(f"â° Stop Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        self.logger.info("="*60)
    
    def log_error_with_context(self, error: Exception, context: str, user_id: int = None):
        """Log errors with context"""
        user_info = f" | User {user_id}" if user_id else ""
        self.logger.error(f"âŒ Error in {context}: {str(error)}{user_info}", exc_info=True)
    
    def get_logger(self):
        """Get the logger instance"""
        return self.logger

# Global logger instance
fc26_logger = FC26Logger()
logger = fc26_logger.get_logger()

# Convenience functions for easy logging
def log_user_action(user_id: int, action: str, details: str = None):
    fc26_logger.log_user_action(user_id, action, details)

def log_registration_step(user_id: int, step: str, success: bool = True):
    fc26_logger.log_registration_step(user_id, step, success)

def log_validation_error(user_id: int, field: str, error: str):
    fc26_logger.log_validation_error(user_id, field, error)

def log_database_operation(operation: str, user_id: int = None, success: bool = True):
    fc26_logger.log_database_operation(operation, user_id, success)

def log_security_event(user_id: int, event: str, details: str = None):
    fc26_logger.log_security_event(user_id, event, details)

def log_performance_metric(operation: str, duration: float, user_id: int = None):
    fc26_logger.log_performance_metric(operation, duration, user_id)

def log_error_with_context(error: Exception, context: str, user_id: int = None):
    fc26_logger.log_error_with_context(error, context, user_id)

--- FC26_sale_coins_Bot/utils/message_tagger.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘                    ğŸ·ï¸ MESSAGE TAGGING SYSTEM                            â•‘
# â•‘                  Ù†Ø¸Ø§Ù… ÙˆØ³Ù… Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…ÙˆØ­Ø¯                                â•‘
# â•‘            Ù…Ù†Ø¹ Ø§Ù„Ø±Ø¯ÙˆØ¯ Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬Ø© - Zero Duplicate Responses              â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
ğŸ·ï¸ Ù†Ø¸Ø§Ù… ÙˆØ³Ù… Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…ÙˆØ­Ø¯
Unified Message Tagging System

Ø§Ù„Ù‡Ø¯Ù:
-------
Ù…Ù†Ø¹ Ø§Ù„Ø±Ø¯ÙˆØ¯ Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬Ø© Ø¹Ù† Ø·Ø±ÙŠÙ‚ ÙˆØ³Ù… Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ØªÙŠ ØªÙ…Øª Ù…Ø¹Ø§Ù„Ø¬ØªÙ‡Ø§ Ø¯Ø§Ø®Ù„ ConversationHandler
Ø­ØªÙ‰ Ù„Ø§ ÙŠØªØ¯Ø®Ù„ global_recovery_router ÙˆÙŠØ±Ø³Ù„ Ø±Ø¯Ø§Ù‹ Ø«Ø§Ù†ÙŠØ§Ù‹.

Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:
----------
ÙÙŠ Ø¨Ø¯Ø§ÙŠØ© ÙƒÙ„ handler:
    MessageTagger.mark_as_handled(context)

ÙÙŠ global_recovery_router:
    if MessageTagger.check_and_clear(context):
        return  # Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…Ø³Ø¨Ù‚Ø§Ù‹ - ØªØ¬Ø§Ù‡Ù„Ù‡Ø§

Ø§Ù„Ù…ÙŠØ²Ø§Øª:
--------
âœ… ÙƒÙˆØ¯ Ù…ÙˆØ­Ø¯ ÙÙŠ Ù…ÙƒØ§Ù† ÙˆØ§Ø­Ø¯
âœ… Ø³Ù‡Ù„ Ø§Ù„ØµÙŠØ§Ù†Ø©
âœ… ØªÙ†Ø¸ÙŠÙ ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„Ø°Ø§ÙƒØ±Ø©
âœ… Ø·Ø¨Ø§Ø¹Ø© ØªØªØ¨Ø¹ ÙˆØ§Ø¶Ø­Ø©
"""

from functools import wraps


class MessageTagger:
    """
    Ù†Ø¸Ø§Ù… ÙˆØ³Ù… Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ù„Ù…Ù†Ø¹ Ø§Ù„Ø±Ø¯ÙˆØ¯ Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬Ø©

    ÙŠØ³ØªØ®Ø¯Ù… chat_data Ù„ØªØ®Ø²ÙŠÙ† Ø¹Ù„Ø§Ù…Ø© "_update_handled"
    Ø§Ù„ØªÙŠ ØªØ´ÙŠØ± Ø¥Ù„Ù‰ Ø£Ù† Ø§Ù„Ø±Ø³Ø§Ù„Ø© ØªÙ…Øª Ù…Ø¹Ø§Ù„Ø¬ØªÙ‡Ø§ Ù…Ù† Ù‚Ø¨Ù„ handler Ù…Ø¹ÙŠÙ†
    """

    TAG_KEY = "_update_handled"

    @staticmethod
    def mark_as_handled(context) -> None:
        """
        ÙˆØ¶Ø¹ Ø¹Ù„Ø§Ù…Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø£Ù†Ù‡Ø§ ØªÙ…Øª Ù…Ø¹Ø§Ù„Ø¬ØªÙ‡Ø§

        Args:
            context: telegram.ext.ContextTypes.DEFAULT_TYPE

        Usage:
            @handler
            async def my_handler(update, context):
                MessageTagger.mark_as_handled(context)
                # ... Ø¨Ø§Ù‚ÙŠ Ø§Ù„ÙƒÙˆØ¯
        """
        context.chat_data[MessageTagger.TAG_KEY] = True
        print(f"   ğŸ·ï¸ [TAGGER] Message marked as handled")

    @staticmethod
    def is_handled(context) -> bool:
        """
        Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø¹Ù„Ø§Ù…Ø© Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©

        Args:
            context: telegram.ext.ContextTypes.DEFAULT_TYPE

        Returns:
            bool: True Ø¥Ø°Ø§ ØªÙ…Øª Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù…Ø³Ø¨Ù‚Ø§Ù‹

        Usage:
            if MessageTagger.is_handled(context):
                return  # ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©
        """
        return context.chat_data.get(MessageTagger.TAG_KEY, False)

    @staticmethod
    def clear_tag(context) -> None:
        """
        Ù…Ø³Ø­ Ø¹Ù„Ø§Ù…Ø© Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© (ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø©)

        Args:
            context: telegram.ext.ContextTypes.DEFAULT_TYPE

        Usage:
            MessageTagger.clear_tag(context)
        """
        if MessageTagger.TAG_KEY in context.chat_data:
            context.chat_data.pop(MessageTagger.TAG_KEY)
            print(f"   ğŸ§¹ [TAGGER] Tag cleared")

    @staticmethod
    def check_and_clear(context) -> bool:
        """
        ÙØ­Øµ ÙˆÙ…Ø³Ø­ Ø§Ù„Ø¹Ù„Ø§Ù…Ø© ÙÙŠ Ø®Ø·ÙˆØ© ÙˆØ§Ø­Ø¯Ø© (Ù„Ù„Ø£Ø¯Ø§Ø¡)

        Args:
            context: telegram.ext.ContextTypes.DEFAULT_TYPE

        Returns:
            bool: True Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù…Ø¹Ø§Ù„Ø¬Ø© Ø³Ø§Ø¨Ù‚Ø§Ù‹

        Usage:
            ÙÙŠ global_recovery_router:

            if MessageTagger.check_and_clear(context):
                print("Ø±Ø³Ø§Ù„Ø© Ù…Ø¹Ø§Ù„Ø¬Ø© - ØªØ¬Ø§Ù‡Ù„")
                return
        """
        is_handled = MessageTagger.is_handled(context)

        if is_handled:
            MessageTagger.clear_tag(context)
            print(f"   ğŸ·ï¸ [TAGGER] Message already handled")
            print(f"   â­ï¸ [TAGGER] Skipping to prevent duplicate response")
            print(f"   ğŸ§¹ [TAGGER] Tag cleared - ready for next message")
            return True

        return False


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ BONUS: AUTO-TAG DECORATOR (Ø§Ø®ØªÙŠØ§Ø±ÙŠ - Ù„Ù„Ù…Ø·ÙˆØ±ÙŠÙ† Ø§Ù„Ù…ØªÙ‚Ø¯Ù…ÙŠÙ†)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


def auto_tag_handler(func):
    """
    Decorator Ù„ÙˆØ³Ù… Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹

    ÙŠÙˆÙØ± Ø¹Ù„ÙŠÙƒ Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ MessageTagger.mark_as_handled() ÙŠØ¯ÙˆÙŠØ§Ù‹

    Usage:
    ------
    @auto_tag_handler
    async def my_handler(update, context):
        # Ø§Ù„ÙˆØ³Ù… ÙŠØ­Ø¯Ø« ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹!
        user_id = update.effective_user.id
        # ... Ø¨Ø§Ù‚ÙŠ Ø§Ù„ÙƒÙˆØ¯

    âš ï¸ Ù…Ù„Ø§Ø­Ø¸Ø©:
    ----------
    Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù€ decorator Ø§Ø®ØªÙŠØ§Ø±ÙŠ.
    Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„ÙŠØ¯ÙˆÙŠØ© (mark_as_handled) Ø£ÙˆØ¶Ø­ ÙˆØ£Ø³Ù‡Ù„ Ù„Ù„Ù…Ø¨ØªØ¯Ø¦ÙŠÙ†.
    """

    @wraps(func)
    async def wrapper(update, context, *args, **kwargs):
        # ÙˆØ³Ù… ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù‚Ø¨Ù„ ØªÙ†ÙÙŠØ° Ø§Ù„Ù€ handler
        MessageTagger.mark_as_handled(context)

        # ØªÙ†ÙÙŠØ° Ø§Ù„Ù€ handler Ø§Ù„Ø£ØµÙ„ÙŠ
        return await func(update, context, *args, **kwargs)

    return wrapper


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“Š STATISTICS & DEBUGGING (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


class MessageTaggerStats:
    """
    Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù†Ø¸Ø§Ù… Ø§Ù„ÙˆØ³Ù… (Ù„Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© ÙˆØ§Ù„ØªØ·ÙˆÙŠØ±)

    ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡Ø§ Ù„ØªØªØ¨Ø¹ Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù†Ø¸Ø§Ù… ÙˆÙƒØ´Ù Ø§Ù„Ù…Ø´Ø§ÙƒÙ„
    """

    _tags_created = 0
    _tags_checked = 0
    _duplicates_prevented = 0

    @classmethod
    def increment_created(cls):
        """Ø¹Ø¯Ø§Ø¯ Ø§Ù„ÙˆØ³ÙˆÙ… Ø§Ù„Ù…Ù†Ø´Ø£Ø©"""
        cls._tags_created += 1

    @classmethod
    def increment_checked(cls):
        """Ø¹Ø¯Ø§Ø¯ Ø§Ù„ÙØ­ÙˆØµØ§Øª"""
        cls._tags_checked += 1

    @classmethod
    def increment_prevented(cls):
        """Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø±Ø¯ÙˆØ¯ Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬Ø© Ø§Ù„Ù…Ù†Ø¹Ø©"""
        cls._duplicates_prevented += 1

    @classmethod
    def get_stats(cls) -> dict:
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª"""
        return {
            "tags_created": cls._tags_created,
            "tags_checked": cls._tags_checked,
            "duplicates_prevented": cls._duplicates_prevented,
            "efficiency": (
                f"{(cls._duplicates_prevented / cls._tags_checked * 100):.2f}%"
                if cls._tags_checked > 0
                else "0%"
            ),
        }

    @classmethod
    def print_stats(cls):
        """Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª"""
        stats = cls.get_stats()
        print("\n" + "=" * 80)
        print("ğŸ“Š [MESSAGE TAGGER STATISTICS]")
        print("=" * 80)
        print(f"   ğŸ·ï¸ Tags Created: {stats['tags_created']}")
        print(f"   ğŸ” Tags Checked: {stats['tags_checked']}")
        print(f"   ğŸ›¡ï¸ Duplicates Prevented: {stats['duplicates_prevented']}")
        print(f"   ğŸ“ˆ Efficiency: {stats['efficiency']}")
        print("=" * 80 + "\n")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ù†Ø³Ø®Ø© Ù…Ø­Ø³Ù‘Ù†Ø© Ù…Ø¹ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


class MessageTaggerWithStats(MessageTagger):
    """
    Ù†Ø³Ø®Ø© Ù…Ø­Ø³Ù‘Ù†Ø© Ù…Ù† MessageTagger Ù…Ø¹ ØªØªØ¨Ø¹ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª

    Ø§Ø³ØªØ®Ø¯Ù…Ù‡Ø§ Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† MessageTagger Ø¥Ø°Ø§ Ø£Ø±Ø¯Øª Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø£Ø¯Ø§Ø¡:

    from utils.message_tagger import MessageTaggerWithStats as MessageTagger
    """

    @staticmethod
    def mark_as_handled(context) -> None:
        MessageTagger.mark_as_handled(context)
        MessageTaggerStats.increment_created()

    @staticmethod
    def check_and_clear(context) -> bool:
        MessageTaggerStats.increment_checked()
        result = MessageTagger.check_and_clear(context)
        if result:
            MessageTaggerStats.increment_prevented()
        return result


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ§ª TESTING (Ù„Ù„ØªØ·ÙˆÙŠØ± ÙÙ‚Ø·)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if __name__ == "__main__":
    print("ğŸ§ª Testing MessageTagger...\n")

    # Ù…Ø­Ø§ÙƒØ§Ø© context
    class MockContext:
        def __init__(self):
            self.chat_data = {}

    context = MockContext()

    # Ø§Ø®ØªØ¨Ø§Ø± 1: ÙˆØ³Ù… Ø§Ù„Ø±Ø³Ø§Ù„Ø©
    print("Test 1: Marking message...")
    MessageTagger.mark_as_handled(context)
    assert MessageTagger.is_handled(context) == True
    print("âœ… Passed\n")

    # Ø§Ø®ØªØ¨Ø§Ø± 2: ÙØ­Øµ ÙˆÙ…Ø³Ø­
    print("Test 2: Check and clear...")
    result = MessageTagger.check_and_clear(context)
    assert result == True
    assert MessageTagger.is_handled(context) == False
    print("âœ… Passed\n")

    # Ø§Ø®ØªØ¨Ø§Ø± 3: Ø±Ø³Ø§Ù„Ø© ØºÙŠØ± Ù…ÙˆØ³ÙˆÙ…Ø©
    print("Test 3: Untagged message...")
    context2 = MockContext()
    assert MessageTagger.is_handled(context2) == False
    assert MessageTagger.check_and_clear(context2) == False
    print("âœ… Passed\n")

    print("ğŸ‰ All tests passed!")
    print("\nğŸ“ MessageTagger is ready for production!")


--- FC26_sale_coins_Bot/utils/session_bucket.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘                    ğŸ—‚ï¸ SESSION BUCKET SYSTEM                             â•‘
# â•‘                  Ù†Ø¸Ø§Ù… Ø¹Ø²Ù„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¬Ù„Ø³Ø§Øª                               â•‘
# â•‘            Ù…Ù†Ø¹ ØªØ¯Ø§Ø®Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨ÙŠÙ† Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ù…Ø®ØªÙ„ÙØ©                     â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
ğŸ—‚ï¸ Ù†Ø¸Ø§Ù… Ù…Ø³Ø§Ø­Ø§Øª Ø§Ù„Ø¹Ù…Ù„ Ø§Ù„Ù…Ø¹Ø²ÙˆÙ„Ø© (Session Buckets)

Ø§Ù„Ù‡Ø¯Ù:
-------
Ù…Ù†Ø¹ ØªØ¯Ø§Ø®Ù„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ù…Ø®ØªÙ„ÙØ© Ø¯Ø§Ø®Ù„ context.user_data.
Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø­Ø°Ù ÙƒÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù†Ø¯ Ø¥Ù†Ù‡Ø§Ø¡ Ù…Ø­Ø§Ø¯Ø«Ø©ØŒ Ù†Ø­Ø°Ù ÙÙ‚Ø· Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©.

Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:
----------
Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù†:
    context.user_data['platform'] = 'pc'
    context.user_data.clear()

Ø§Ø³ØªØ®Ø¯Ù…:
    bucket(context, 'reg')['platform'] = 'pc'
    clear_bucket(context, 'reg')

Ø§Ù„ÙÙˆØ§Ø¦Ø¯:
--------
âœ… Ø¹Ø²Ù„ ÙƒØ§Ù…Ù„ Ø¨ÙŠÙ† Ø§Ù„Ø®Ø¯Ù…Ø§Øª (reg, sell, admin)
âœ… Ø¥Ù†Ù‡Ø§Ø¡ Ù…Ø­Ø§Ø¯Ø«Ø© Ù„Ø§ ÙŠØ¤Ø«Ø± Ø¹Ù„Ù‰ Ù…Ø­Ø§Ø¯Ø«Ø© Ø£Ø®Ø±Ù‰
âœ… Ø£Ù…Ø§Ù† Ø£Ø¹Ù„Ù‰ Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª
âœ… Ù…ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Persistence
"""


def bucket(context, name: str) -> dict:
    """
    Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø³Ø§Ø­Ø© Ø¹Ù…Ù„ Ù…Ø¹Ø²ÙˆÙ„Ø© Ø¯Ø§Ø®Ù„ context.user_data

    Args:
        context: telegram.ext.ContextTypes.DEFAULT_TYPE
        name: Ø§Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ø­Ø© (Ù…Ø«Ù„ 'reg', 'sell', 'admin')

    Returns:
        dict: Ù‚Ø§Ù…ÙˆØ³ Ø®Ø§Øµ Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø³Ø§Ø­Ø© ÙÙ‚Ø·

    Example:
        # ÙÙŠ handlers Ø§Ù„ØªØ³Ø¬ÙŠÙ„:
        bucket(context, 'reg')['platform'] = 'playstation'

        # ÙÙŠ handlers Ø§Ù„Ø¨ÙŠØ¹:
        bucket(context, 'sell')['amount'] = 5000

        # Ù„Ø§ ÙŠØªØ¯Ø§Ø®Ù„Ø§Ù†!
    """
    # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø©
    if '_buckets' not in context.user_data:
        context.user_data['_buckets'] = {}

    # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³Ø§Ø­Ø© Ø§Ù„ÙØ±Ø¹ÙŠØ© Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø©
    if name not in context.user_data['_buckets']:
        context.user_data['_buckets'][name] = {}

    return context.user_data['_buckets'][name]


def clear_bucket(context, name: str) -> None:
    """
    Ù…Ø³Ø­ Ù…Ø³Ø§Ø­Ø© Ø¹Ù…Ù„ Ù…Ø­Ø¯Ø¯Ø© ÙÙ‚Ø· (Ø¨Ø¯ÙˆÙ† Ø§Ù„ØªØ£Ø«ÙŠØ± Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³Ø§Ø­Ø§Øª Ø§Ù„Ø£Ø®Ø±Ù‰)

    Args:
        context: telegram.ext.ContextTypes.DEFAULT_TYPE
        name: Ø§Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ù…Ø±Ø§Ø¯ Ù…Ø³Ø­Ù‡Ø§

    Example:
        # Ù…Ø³Ø­ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ³Ø¬ÙŠÙ„ ÙÙ‚Ø·
        clear_bucket(context, 'reg')

        # Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨ÙŠØ¹ ØªØ¨Ù‚Ù‰ ÙƒÙ…Ø§ Ù‡ÙŠ!
        bucket(context, 'sell').get('amount')  # âœ… Ù…ÙˆØ¬ÙˆØ¯Ø©
    """
    if '_buckets' in context.user_data:
        if name in context.user_data['_buckets']:
            context.user_data['_buckets'][name].clear()
            print(f"   ğŸ§¹ [BUCKET] Cleared bucket: {name}")


def get_all_buckets(context) -> dict:
    """
    Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³Ø§Ø­Ø§Øª (Ù„Ù„ÙØ­Øµ ÙˆØ§Ù„ØªØ·ÙˆÙŠØ±)

    Args:
        context: telegram.ext.ContextTypes.DEFAULT_TYPE

    Returns:
        dict: Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³Ø§Ø­Ø§Øª Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©
    """
    return context.user_data.get('_buckets', {})


def has_bucket(context, name: str) -> bool:
    """
    Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù…Ø³Ø§Ø­Ø© Ø¹Ù…Ù„

    Args:
        context: telegram.ext.ContextTypes.DEFAULT_TYPE
        name: Ø§Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ø­Ø©

    Returns:
        bool: True Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…Ø³Ø§Ø­Ø© Ù…ÙˆØ¬ÙˆØ¯Ø© ÙˆØºÙŠØ± ÙØ§Ø±ØºØ©
    """
    if '_buckets' not in context.user_data:
        return False
    return name in context.user_data['_buckets'] and bool(context.user_data['_buckets'][name])


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ§ª TESTING (Ù„Ù„ØªØ·ÙˆÙŠØ± ÙÙ‚Ø·)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if __name__ == "__main__":
    print("ğŸ§ª Testing Session Bucket System...\n")

    # Ù…Ø­Ø§ÙƒØ§Ø© context
    class MockContext:
        def __init__(self):
            self.user_data = {}

    context = MockContext()

    # Ø§Ø®ØªØ¨Ø§Ø± 1: Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø­Ø§Øª Ù…Ù†ÙØµÙ„Ø©
    print("Test 1: Creating separate buckets...")
    bucket(context, 'reg')['platform'] = 'playstation'
    bucket(context, 'sell')['amount'] = 5000

    assert bucket(context, 'reg')['platform'] == 'playstation'
    assert bucket(context, 'sell')['amount'] == 5000
    print("âœ… Passed\n")

    # Ø§Ø®ØªØ¨Ø§Ø± 2: Ø¹Ø²Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    print("Test 2: Data isolation...")
    clear_bucket(context, 'reg')

    assert 'platform' not in bucket(context, 'reg')
    assert bucket(context, 'sell')['amount'] == 5000  # Ù„Ù… ØªØªØ£Ø«Ø±!
    print("âœ… Passed\n")

    # Ø§Ø®ØªØ¨Ø§Ø± 3: has_bucket
    print("Test 3: has_bucket check...")
    assert has_bucket(context, 'sell') == True
    assert has_bucket(context, 'reg') == False
    print("âœ… Passed\n")

    print("ğŸ‰ All tests passed!")
    print("\nğŸ“ Session Bucket System is ready for production!")


--- FC26_sale_coins_Bot/utils/session_monitor.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘                    ğŸ“Š SESSION MONITOR SYSTEM                             â•‘
# â•‘                  Ù†Ø¸Ø§Ù… Ù…Ø±Ø§Ù‚Ø¨Ø© ØµØ­Ø© Ø§Ù„Ø¬Ù„Ø³Ø§Øª                                â•‘
# â•‘            ÙØ­Øµ Ø¯ÙˆØ±ÙŠ Ù„Ù…Ù„Ù Ø§Ù„Ø¬Ù„Ø³Ø§Øª ÙˆØ§Ù„ØªÙ†Ø¨ÙŠÙ‡ Ø¨Ø§Ù„Ù…Ø´Ø§ÙƒÙ„                      â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
ğŸ“Š Ù†Ø¸Ø§Ù… Ù…Ø±Ø§Ù‚Ø¨Ø© ØµØ­Ø© Ø§Ù„Ø¬Ù„Ø³Ø§Øª

Ø§Ù„Ù‡Ø¯Ù:
-------
ÙØ­Øµ Ø¯ÙˆØ±ÙŠ Ù„Ù…Ù„Ù Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ù„Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ù…Ø´Ø§ÙƒÙ„ Ù…Ø¨ÙƒØ±Ø§Ù‹.

Ø§Ù„Ù…ÙŠØ²Ø§Øª:
--------
âœ… ÙØ­Øµ ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù…Ù„Ù
âœ… ÙØ­Øµ Ø­Ø¬Ù… Ø§Ù„Ù…Ù„Ù (ØªØ­Ø°ÙŠØ± Ø¥Ø°Ø§ ØªØ¬Ø§ÙˆØ² 50 MB)
âœ… ØªÙ‚Ø¯ÙŠØ± Ø¹Ø¯Ø¯ Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø©
âœ… ØªØ­Ø°ÙŠØ±Ø§Øª ÙÙŠ Ø§Ù„Ù€ logs
âœ… ÙØ­Øµ ÙƒÙ„ 6 Ø³Ø§Ø¹Ø§Øª
"""

import pickle
from pathlib import Path


async def session_health_check(context):
    """
    ÙØ­Øµ ØµØ­Ø© Ù…Ù„Ù Ø§Ù„Ø¬Ù„Ø³Ø§Øª

    ÙŠÙ‚ÙˆÙ… Ø¨Ù€:
    1. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù…Ù„Ù
    2. ÙØ­Øµ Ø­Ø¬Ù… Ø§Ù„Ù…Ù„Ù
    3. ØªÙ‚Ø¯ÙŠØ± Ø¹Ø¯Ø¯ Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø©
    4. Ø·Ø¨Ø§Ø¹Ø© ØªÙ‚Ø±ÙŠØ± ÙÙŠ Ø§Ù„Ù€ logs

    Args:
        context: telegram.ext.ContextTypes.DEFAULT_TYPE
    """
    print(f"\n{'='*80}")
    print(f"ğŸ“Š [SESSION-MONITOR] Health check started...")
    print(f"{'='*80}")

    session_file = Path("data/sessions.pkl")

    # ÙØ­Øµ 1: ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù…Ù„Ù
    if not session_file.exists():
        print(f"   âš ï¸ [SESSION-MONITOR] Session file not found!")
        print(f"   ğŸ“ This is normal for first run")
        print(f"{'='*80}\n")
        return

    # ÙØ­Øµ 2: Ø­Ø¬Ù… Ø§Ù„Ù…Ù„Ù
    try:
        size_bytes = session_file.stat().st_size
        size_mb = size_bytes / (1024 * 1024)

        print(f"   ğŸ“ [SESSION-MONITOR] File size: {size_mb:.2f} MB")

        if size_mb > 50:
            print(f"   âš ï¸ [SESSION-MONITOR] WARNING: Large session file!")
            print(f"   ğŸ’¡ Consider clearing old sessions or optimizing")
        elif size_mb > 100:
            print(f"   ğŸš¨ [SESSION-MONITOR] CRITICAL: Very large session file!")
            print(f"   ğŸ”§ Immediate action required")
    except Exception as e:
        print(f"   âŒ [SESSION-MONITOR] Error checking file size: {e}")

    # ÙØ­Øµ 3: Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…Ù„Ù
    try:
        with open(session_file, "rb") as f:
            data = pickle.load(f)

        # ØªÙ‚Ø¯ÙŠØ± Ø¹Ø¯Ø¯ Ø§Ù„Ø¬Ù„Ø³Ø§Øª
        if isinstance(data, dict):
            user_count = len(data.get("user_data", {}))
            chat_count = len(data.get("chat_data", {}))
            bot_data_exists = "bot_data" in data

            print(f"   ğŸ‘¥ [SESSION-MONITOR] Active users: {user_count}")
            print(f"   ğŸ’¬ [SESSION-MONITOR] Active chats: {chat_count}")
            print(
                f"   ğŸ¤– [SESSION-MONITOR] Bot data: {'Yes' if bot_data_exists else 'No'}"
            )

            # ØªØ­Ø°ÙŠØ± Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø¹Ø¯Ø¯ ÙƒØ¨ÙŠØ± Ø¬Ø¯Ø§Ù‹
            if user_count > 10000:
                print(f"   âš ï¸ [SESSION-MONITOR] Very high user count!")
        else:
            print(f"   âš ï¸ [SESSION-MONITOR] Unexpected data format")

    except Exception as e:
        print(f"   âŒ [SESSION-MONITOR] Error reading session data: {e}")
        print(f"   ğŸ’¡ File might be corrupted or locked")

    print(f"{'='*80}")
    print(f"âœ… [SESSION-MONITOR] Health check completed")
    print(f"{'='*80}\n")


def register_monitoring(app):
    """
    ØªØ³Ø¬ÙŠÙ„ ÙˆØ¸ÙŠÙØ© Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© ÙÙŠ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø²Ù…Ù†ÙŠ

    ÙŠÙ‚ÙˆÙ… Ø¨ØªØ³Ø¬ÙŠÙ„ ÙØ­Øµ ØµØ­Ø© ÙƒÙ„ 6 Ø³Ø§Ø¹Ø§Øª

    Args:
        app: telegram.ext.Application
    """
    print("\nğŸ“Š [SESSION-MONITOR] Registering monitoring jobs...")

    # ÙØ­Øµ ØµØ­Ø© ÙƒÙ„ 6 Ø³Ø§Ø¹Ø§Øª
    app.job_queue.run_repeating(
        session_health_check,
        interval=21600,  # 6 Ø³Ø§Ø¹Ø§Øª Ø¨Ø§Ù„Ø«ÙˆØ§Ù†ÙŠ
        first=60,  # Ø£ÙˆÙ„ ÙØ­Øµ Ø¨Ø¹Ø¯ Ø¯Ù‚ÙŠÙ‚Ø© Ù…Ù† Ø§Ù„Ø¨Ø¯Ø¡
        name="session_monitoring",
    )
    print("   âœ… Health check scheduled: Every 6 hours")
    print("   âœ… First check: 1 minute after start")

    print("ğŸ“Š [SESSION-MONITOR] Monitoring jobs registered successfully\n")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ› ï¸ UTILITY FUNCTIONS (Ø¥Ø¶Ø§ÙÙŠØ©)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


def get_session_stats() -> dict:
    """
    Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¬Ù„Ø³Ø§Øª

    Returns:
        dict: Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù…ÙØµÙ„Ø©
    """
    session_file = Path("data/sessions.pkl")

    if not session_file.exists():
        return {
            "exists": False,
            "size_mb": 0,
            "user_count": 0,
            "chat_count": 0,
        }

    stats = {
        "exists": True,
        "size_mb": round(session_file.stat().st_size / (1024 * 1024), 2),
    }

    try:
        with open(session_file, "rb") as f:
            data = pickle.load(f)

        if isinstance(data, dict):
            stats["user_count"] = len(data.get("user_data", {}))
            stats["chat_count"] = len(data.get("chat_data", {}))
            stats["has_bot_data"] = "bot_data" in data
        else:
            stats["user_count"] = 0
            stats["chat_count"] = 0
            stats["has_bot_data"] = False

    except:
        stats["user_count"] = 0
        stats["chat_count"] = 0
        stats["error"] = True

    return stats


def print_session_report():
    """
    Ø·Ø¨Ø§Ø¹Ø© ØªÙ‚Ø±ÙŠØ± Ù…ÙØµÙ„ Ø¹Ù† Ø§Ù„Ø¬Ù„Ø³Ø§Øª (Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙŠØ¯ÙˆÙŠ)
    """
    stats = get_session_stats()

    print("\n" + "=" * 80)
    print("ğŸ“Š SESSION REPORT")
    print("=" * 80)

    if not stats["exists"]:
        print("âŒ No session file found")
    else:
        print(f"âœ… File exists: data/sessions.pkl")
        print(f"ğŸ“ Size: {stats['size_mb']} MB")
        print(f"ğŸ‘¥ Users: {stats.get('user_count', 'N/A')}")
        print(f"ğŸ’¬ Chats: {stats.get('chat_count', 'N/A')}")
        print(f"ğŸ¤– Bot Data: {'Yes' if stats.get('has_bot_data') else 'No'}")

        if stats.get("error"):
            print("âš ï¸ Warning: Could not read session data")

    print("=" * 80 + "\n")


--- FC26_sale_coins_Bot/validators/__init__.py ---



--- FC26_sale_coins_Bot/validators/payment_validator.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ’³ FC26 PAYMENT VALIDATOR - Ù…Ø¯Ù‚Ù‚ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯ÙØ¹             â•‘
# â•‘                     Payment Details Validation                           â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import logging
import re
from typing import Any, Dict

logger = logging.getLogger(__name__)


class PaymentValidator:
    """Payment methods validation"""

    @classmethod
    def validate_payment_details(
        cls, payment_method: str, details: str
    ) -> Dict[str, Any]:
        """
        Validate payment details based on payment method

        Args:
            payment_method (str): Payment method type
            details (str): Payment details to validate

        Returns:
            Dict[str, Any]: Validation result with formatted data
        """
        try:
            # Ù„Ù„Ù…Ø­Ø§ÙØ¸ Ø§Ù„Ù…Ø­Ù…ÙˆÙ„Ø© ÙˆØªÙŠÙ„Ø¯Ø§ - ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø±ÙˆÙ ÙˆØ§Ù„Ø±Ù…ÙˆØ² Ø£ÙˆÙ„Ø§Ù‹
            if payment_method in [
                "vodafone_cash",
                "etisalat_cash",
                "orange_cash",
                "we_cash",
                "bank_wallet",
                "telda",
            ]:
                # ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø­Ø±ÙˆÙ Ø£Ùˆ Ø±Ù…ÙˆØ² ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­Ø©
                if re.search(r"[^\d\s\-]", details):  # Ø£ÙŠ Ø­Ø§Ø¬Ø© ØºÙŠØ± Ø±Ù‚Ù… Ø£Ùˆ Ù…Ø³Ø§ÙØ© Ø£Ùˆ Ø´Ø±Ø·Ø©
                    return {
                        "valid": False,
                        "error": "âŒ ÙŠÙØ³Ù…Ø­ Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·! Ù„Ø§ ØªØ³ØªØ®Ø¯Ù… Ø­Ø±ÙˆÙ Ø£Ùˆ Ø±Ù…ÙˆØ²",
                    }

                # ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù…Ø³Ø§ÙØ§Øª Ø£Ùˆ Ø´Ø±Ø·Ø§Øª ÙƒØªÙŠØ±
                special_chars_count = details.count(" ") + details.count("-")
                if special_chars_count > 5:
                    return {
                        "valid": False,
                        "error": "âŒ Ù…Ø³Ø§ÙØ§Øª Ø£Ùˆ Ø´Ø±Ø·Ø§Øª ÙƒØªÙŠØ±Ø©! Ø§ÙƒØªØ¨ Ø§Ù„Ø±Ù‚Ù… Ø¨Ø´ÙƒÙ„ Ø¨Ø³ÙŠØ·",
                    }

            # Clean input for mobile wallets and Telda
            cleaned = (
                re.sub(r"[^\d]", "", details)
                if payment_method != "instapay"
                else details.strip()
            )

            # Route to specific validator
            if payment_method in [
                "vodafone_cash",
                "etisalat_cash",
                "orange_cash",
                "we_cash",
                "bank_wallet",
            ]:
                return cls._validate_mobile_wallet(cleaned, payment_method)
            elif payment_method == "telda":
                return cls._validate_telda_card(cleaned)
            elif payment_method == "instapay":
                return cls._validate_instapay(details)
            else:
                return {"valid": False, "error": "âŒ Ø·Ø±ÙŠÙ‚Ø© Ø¯ÙØ¹ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙØ©"}

        except Exception as e:
            logger.error(f"Payment validation error: {e}")
            return {"valid": False, "error": "âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯ÙØ¹"}

    @classmethod
    def _validate_mobile_wallet(
        cls, cleaned: str, payment_method: str
    ) -> Dict[str, Any]:
        """Validate mobile wallet phone number"""

        # ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø£Ø±Ù‚Ø§Ù… Ø£ØµÙ„Ø§Ù‹
        if not cleaned:
            return {
                "valid": False,
                "error": "âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£Ø±Ù‚Ø§Ù…! Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­",
            }

        if not re.match(r"^01[0125][0-9]{8}$", cleaned):
            return {
                "valid": False,
                "error": "âŒ Ø±Ù‚Ù… ØºÙŠØ± ØµØ­ÙŠØ­. ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ¨Ø¯Ø£ Ø¨Ù€ 010/011/012/015 ÙˆÙŠØªÙƒÙˆÙ† Ù…Ù† 11 Ø±Ù‚Ù…Ø§Ù‹",
            }

        # Check if number matches payment method (optional validation)
        provider_map = {
            "vodafone_cash": "010",
            "etisalat_cash": "011",
            "orange_cash": "012",
            "we_cash": "015",
        }

        expected_prefix = provider_map.get(payment_method)
        if expected_prefix and not cleaned.startswith(expected_prefix):
            warning = f"âš ï¸ ØªØ­Ø°ÙŠØ±: Ø§Ù„Ø±Ù‚Ù… Ù„Ø§ ÙŠØ·Ø§Ø¨Ù‚ Ø´Ø¨ÙƒØ© {payment_method.replace('_cash', '').title()}"
        else:
            warning = None

        return {
            "valid": True,
            "cleaned": cleaned,
            "formatted": f"+20{cleaned}",
            "display": cleaned,
            "clickable": cleaned,
            "warning": warning,
        }

    @classmethod
    def _validate_telda_card(cls, cleaned: str) -> Dict[str, Any]:
        """Validate Telda card number"""

        # ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø£Ø±Ù‚Ø§Ù… Ø£ØµÙ„Ø§Ù‹
        if not cleaned:
            return {
                "valid": False,
                "error": "âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£Ø±Ù‚Ø§Ù…! Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… ÙƒØ§Ø±Øª ØµØ­ÙŠØ­",
            }

        if len(cleaned) != 16 or not cleaned.isdigit():
            return {
                "valid": False,
                "error": "âŒ Ø±Ù‚Ù… ÙƒØ§Ø±Øª ØªÙŠÙ„Ø¯Ø§ ØºÙŠØ± ØµØ­ÙŠØ­. ÙŠØ¬Ø¨ Ø£Ù† ÙŠØªÙƒÙˆÙ† Ù…Ù† 16 Ø±Ù‚Ù…Ø§Ù‹ Ø¨Ø§Ù„Ø¶Ø¨Ø·",
            }

        # Format card number for display (Ø¨Ø¯ÙˆÙ† ØªØ´ÙÙŠØ±)
        formatted = f"{cleaned[:4]}-{cleaned[4:8]}-{cleaned[8:12]}-{cleaned[12:16]}"

        return {
            "valid": True,
            "cleaned": cleaned,
            "formatted": formatted,
            "display": cleaned,
            "formatted_display": formatted,
            "clickable": cleaned,
        }

    @classmethod
    def _validate_instapay(cls, details: str) -> Dict[str, Any]:
        """Validate InstaPay URL and extract clean URL from any text"""
        details = details.strip()

        # Extract clean InstaPay URL from text using advanced regex patterns
        url_patterns = [
            # Pattern 1: Full URLs with https/http
            r"https?://[^\s]*(?:instapay\.com\.eg|ipn\.eg)[^\s]*",
            # Pattern 2: URLs without protocol
            r"(?:instapay\.com\.eg|ipn\.eg)[^\s]*",
            # Pattern 3: Find URLs within Arabic/English text
            r"(?:https?://)?(?:www\.)?(?:instapay\.com\.eg|ipn\.eg)[^\s\u0600-\u06FF]*",
            # Pattern 4: Extract from any position in text
            r"(?:https?://)?[^\s]*(?:instapay\.com\.eg|ipn\.eg)[^\s]*",
        ]

        clean_url = None

        # Try each pattern to extract URL
        for pattern in url_patterns:
            matches = re.findall(pattern, details, re.IGNORECASE)
            if matches:
                # Get the first match and clean it
                potential_url = matches[0].strip()

                # Clean URL from any trailing characters
                potential_url = re.sub(r"[^\w\-\.\/\:\?=&%]+$", "", potential_url)

                # Verify it contains the domain
                if any(
                    domain in potential_url.lower()
                    for domain in ["instapay.com.eg", "ipn.eg"]
                ):
                    clean_url = potential_url
                    break

        # If no URL found, check if text contains domain
        if not clean_url:
            if any(
                domain in details.lower() for domain in ["instapay.com.eg", "ipn.eg"]
            ):
                return {
                    "valid": False,
                    "error": "âŒ ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù†Ø·Ø§Ù‚ Ø¥Ù†Ø³ØªØ§Ø¨Ø§ÙŠ ÙˆÙ„ÙƒÙ† Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø±Ø§Ø¨Ø· ØµØ­ÙŠØ­. Ø£Ø±Ø³Ù„ Ø§Ù„Ø±Ø§Ø¨Ø· ÙƒØ§Ù…Ù„Ø§Ù‹",
                }
            else:
                return {
                    "valid": False,
                    "error": "âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø±Ø§Ø¨Ø· Ø¥Ù†Ø³ØªØ§Ø¨Ø§ÙŠ. ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ instapay.com.eg Ø£Ùˆ ipn.eg",
                }

        # Add https if missing
        if not clean_url.startswith(("http://", "https://")):
            clean_url = "https://" + clean_url

        # Final validation
        if not any(
            domain in clean_url.lower() for domain in ["instapay.com.eg", "ipn.eg"]
        ):
            return {
                "valid": False,
                "error": "âŒ Ø±Ø§Ø¨Ø· Ø¥Ù†Ø³ØªØ§Ø¨Ø§ÙŠ ØºÙŠØ± ØµØ­ÙŠØ­. ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ instapay.com.eg Ø£Ùˆ ipn.eg",
            }

        # Additional URL cleanup - remove any duplicate protocols
        clean_url = re.sub(r"https?://(https?://)+", "https://", clean_url)

        return {
            "valid": True,
            "cleaned": clean_url,
            "formatted": clean_url,
            "display": clean_url,
            "clickable": clean_url,
        }

    @classmethod
    def validate_whatsapp(cls, phone: str) -> Dict[str, Any]:
        """Validate WhatsApp phone number - 11 digits only starting with 010/011/012/015"""
        try:
            # ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø­Ø±ÙˆÙ Ø£Ùˆ Ø±Ù…ÙˆØ² Ù‚Ø¨Ù„ Ø§Ù„ØªÙ†Ø¸ÙŠÙ
            if re.search(r"[^\d\s]", phone):  # Ø£ÙŠ Ø­Ø§Ø¬Ø© ØºÙŠØ± Ø±Ù‚Ù… Ø£Ùˆ Ù…Ø³Ø§ÙØ©
                return {
                    "valid": False,
                    "error": "âŒ ÙŠÙØ³Ù…Ø­ Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·! Ù„Ø§ ØªØ³ØªØ®Ø¯Ù… Ø­Ø±ÙˆÙ Ø£Ùˆ Ø±Ù…ÙˆØ²",
                }

            # ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù…Ø³Ø§ÙØ§Øª ÙƒØªÙŠØ±
            if phone.count(" ") > 3:  # Ù„Ùˆ Ø§Ù„Ù…Ø³Ø§ÙØ§Øª ÙƒØªÙŠØ± Ø£ÙˆÙŠ
                return {
                    "valid": False,
                    "error": "âŒ Ù…Ø³Ø§ÙØ§Øª ÙƒØªÙŠØ±Ø©! Ø§ÙƒØªØ¨ Ø§Ù„Ø±Ù‚Ù… Ø¨Ø¯ÙˆÙ† Ù…Ø³Ø§ÙØ§Øª Ø£Ùˆ Ø¨Ù…Ø³Ø§ÙØ§Øª Ù‚Ù„ÙŠÙ„Ø©",
                }

            # Clean input - remove all non-digits
            cleaned = re.sub(r"[^\d]", "", phone)

            # ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø£Ø±Ù‚Ø§Ù… Ø£ØµÙ„Ø§Ù‹
            if not cleaned:
                return {
                    "valid": False,
                    "error": "âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£Ø±Ù‚Ø§Ù…! Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… ÙˆØ§ØªØ³Ø§Ø¨ ØµØ­ÙŠØ­",
                }

            # Check exact length
            if len(cleaned) != 11:
                return {
                    "valid": False,
                    "error": "âŒ Ø±Ù‚Ù… ØºÙŠØ± ØµØ­ÙŠØ­. ÙŠØ¬Ø¨ Ø£Ù† ÙŠØªÙƒÙˆÙ† Ù…Ù† 11 Ø±Ù‚Ù…Ø§Ù‹ Ø¨Ø§Ù„Ø¶Ø¨Ø·",
                }

            # Check if starts with valid Egyptian prefixes
            if not re.match(r"^01[0125][0-9]{8}$", cleaned):
                return {
                    "valid": False,
                    "error": "âŒ Ø±Ù‚Ù… ØºÙŠØ± ØµØ­ÙŠØ­. ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ¨Ø¯Ø£ Ø¨Ù€ 010/011/012/015 ÙˆÙŠØªÙƒÙˆÙ† Ù…Ù† 11 Ø±Ù‚Ù…Ø§Ù‹",
                }

            return {
                "valid": True,
                "cleaned": cleaned,
                "formatted": f"+20{cleaned}",
                "display": cleaned,
                "clickable": cleaned,
            }

        except Exception as e:
            logger.error(f"WhatsApp validation error: {e}")
            return {"valid": False, "error": "âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø±Ù‚Ù… Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨"}

    @classmethod
    def get_payment_instructions(cls, payment_method: str) -> str:
        """Get specific instructions for payment method"""
        instructions = {
            "vodafone_cash": "Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… ÙÙˆØ¯Ø§ÙÙˆÙ† ÙƒØ§Ø´ (11 Ø±Ù‚Ù…Ø§Ù‹ ÙŠØ¨Ø¯Ø£ Ø¨Ù€ 010) - Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·!",
            "etisalat_cash": "Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… Ø§ØªØµØ§Ù„Ø§Øª ÙƒØ§Ø´ (11 Ø±Ù‚Ù…Ø§Ù‹ ÙŠØ¨Ø¯Ø£ Ø¨Ù€ 011) - Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·!",
            "orange_cash": "Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… Ø£ÙˆØ±Ø§Ù†Ø¬ ÙƒØ§Ø´ (11 Ø±Ù‚Ù…Ø§Ù‹ ÙŠØ¨Ø¯Ø£ Ø¨Ù€ 012) - Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·!",
            "we_cash": "Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… ÙˆÙŠ ÙƒØ§Ø´ (11 Ø±Ù‚Ù…Ø§Ù‹ ÙŠØ¨Ø¯Ø£ Ø¨Ù€ 015) - Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·!",
            "bank_wallet": "Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… Ø§Ù„Ù…Ø­ÙØ¸Ø© Ø§Ù„Ø¨Ù†ÙƒÙŠØ© (11 Ø±Ù‚Ù…Ø§Ù‹ Ù„Ø£ÙŠ Ø´Ø¨ÙƒØ© Ù…ØµØ±ÙŠØ©) - Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·!",
            "telda": "Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… ÙƒØ§Ø±Øª ØªÙŠÙ„Ø¯Ø§ (16 Ø±Ù‚Ù…Ø§Ù‹ Ø¨Ø¯ÙˆÙ† Ù…Ø³Ø§ÙØ§Øª) - Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·!",
            "instapay": "Ø£Ø¯Ø®Ù„ Ø±Ø§Ø¨Ø· Ø¥Ù†Ø³ØªØ§Ø¨Ø§ÙŠ Ø§Ù„ÙƒØ§Ù…Ù„\n<b>Ù…Ø«Ø§Ù„:</b> https://instapay.com.eg/abc123",
        }

        return instructions.get(payment_method, "Ø£Ø¯Ø®Ù„ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¯ÙØ¹")

    @classmethod
    def get_payment_examples(cls, payment_method: str) -> str:
        """Get examples for payment method"""
        examples = {
            "vodafone_cash": "<b>Ù…Ø«Ø§Ù„:</b> 01012345678 (Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·)",
            "etisalat_cash": "<b>Ù…Ø«Ø§Ù„:</b> 01112345678 (Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·)",
            "orange_cash": "<b>Ù…Ø«Ø§Ù„:</b> 01212345678 (Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·)",
            "we_cash": "<b>Ù…Ø«Ø§Ù„:</b> 01512345678 (Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·)",
            "bank_wallet": "<b>Ù…Ø«Ø§Ù„:</b> 01012345678 (Ø£ÙŠ Ø´Ø¨ÙƒØ© - Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·)",
            "telda": "<b>Ù…Ø«Ø§Ù„:</b> 1234567890123456 (16 Ø±Ù‚Ù… - Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·)",
            "instapay": "<b>Ù…Ø«Ø§Ù„:</b> https://instapay.com.eg/abc123",
        }

        return examples.get(payment_method, "")


--- FC26_sale_coins_Bot/validators/phone_validator.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ“± FC26 PHONE VALIDATOR - Ù…Ø¯Ù‚Ù‚ Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ù‡Ø§ØªÙ              â•‘
# â•‘                     Phone Number Validation                              â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import logging
import re
from typing import Any, Dict

logger = logging.getLogger(__name__)


class PhoneValidator:
    """Egyptian phone number validation"""

    # Egyptian mobile patterns
    EGYPTIAN_PATTERNS = {
        "vodafone": r"^010[0-9]{8}$",
        "etisalat": r"^011[0-9]{8}$",
        "orange": r"^012[0-9]{8}$",
        "we": r"^015[0-9]{8}$",
        "general": r"^01[0125][0-9]{8}$",
    }

    @classmethod
    def validate_whatsapp(cls, phone: str) -> Dict[str, Any]:
        """
        Validate Egyptian WhatsApp phone number - Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·

        Args:
            phone (str): Phone number to validate

        Returns:
            Dict[str, Any]: Validation result with formatted data
        """
        try:
            # ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø­Ø±ÙˆÙ Ø£Ùˆ Ø±Ù…ÙˆØ² Ù‚Ø¨Ù„ Ø§Ù„ØªÙ†Ø¸ÙŠÙ
            if re.search(r"[^\d\s]", phone):  # Ø£ÙŠ Ø­Ø§Ø¬Ø© ØºÙŠØ± Ø±Ù‚Ù… Ø£Ùˆ Ù…Ø³Ø§ÙØ©
                return {
                    "valid": False,
                    "error": "âŒ ÙŠÙØ³Ù…Ø­ Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·! Ù„Ø§ ØªØ³ØªØ®Ø¯Ù… Ø­Ø±ÙˆÙ Ø£Ùˆ Ø±Ù…ÙˆØ²",
                }

            # ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù…Ø³Ø§ÙØ§Øª ÙƒØªÙŠØ±
            if phone.count(" ") > 3:  # Ù„Ùˆ Ø§Ù„Ù…Ø³Ø§ÙØ§Øª ÙƒØªÙŠØ± Ø£ÙˆÙŠ
                return {
                    "valid": False,
                    "error": "âŒ Ù…Ø³Ø§ÙØ§Øª ÙƒØªÙŠØ±Ø©! Ø§ÙƒØªØ¨ Ø§Ù„Ø±Ù‚Ù… Ø¨Ø¯ÙˆÙ† Ù…Ø³Ø§ÙØ§Øª Ø£Ùˆ Ø¨Ù…Ø³Ø§ÙØ§Øª Ù‚Ù„ÙŠÙ„Ø©",
                }

            # Clean input - remove all non-digits
            cleaned = re.sub(r"[^\d]", "", phone)

            # ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø£Ø±Ù‚Ø§Ù… Ø£ØµÙ„Ø§Ù‹
            if not cleaned:
                return {
                    "valid": False,
                    "error": "âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£Ø±Ù‚Ø§Ù…! Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… ÙˆØ§ØªØ³Ø§Ø¨ ØµØ­ÙŠØ­",
                }

            # Validate Egyptian mobile pattern
            if not re.match(cls.EGYPTIAN_PATTERNS["general"], cleaned):
                return {
                    "valid": False,
                    "error": "âŒ Ø±Ù‚Ù… ØºÙŠØ± ØµØ­ÙŠØ­. ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ¨Ø¯Ø£ Ø¨Ù€ 010/011/012/015 ÙˆÙŠØªÙƒÙˆÙ† Ù…Ù† 11 Ø±Ù‚Ù…Ø§Ù‹",
                }

            # Determine network provider
            provider = cls._get_network_provider(cleaned)

            return {
                "valid": True,
                "cleaned": cleaned,
                "formatted": f"+20{cleaned}",
                "display": cleaned,  # Enhanced UX: Display without country code
                "provider": provider,
                "clickable": f"<code>{cleaned}</code>",  # For Telegram click-to-copy
            }

        except Exception as e:
            logger.error(f"Phone validation error: {e}")
            return {"valid": False, "error": "âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø±Ù‚Ù…"}

    @classmethod
    def _get_network_provider(cls, phone: str) -> str:
        """Get network provider from phone number"""
        if phone.startswith("010"):
            return "vodafone"
        elif phone.startswith("011"):
            return "etisalat"
        elif phone.startswith("012"):
            return "orange"
        elif phone.startswith("015"):
            return "we"
        else:
            return "unknown"

    @classmethod
    def format_for_display(cls, phone: str, include_country_code: bool = False) -> str:
        """Format phone number for display"""
        cleaned = re.sub(r"[^\d]", "", phone)

        if include_country_code:
            return f"+20 {cleaned[:3]} {cleaned[3:6]} {cleaned[6:]}"
        else:
            return f"{cleaned[:3]} {cleaned[3:6]} {cleaned[6:]}"

    @classmethod
    def is_valid_egyptian_mobile(cls, phone: str) -> bool:
        """Quick check if phone is valid Egyptian mobile"""
        cleaned = re.sub(r"[^\d]", "", phone)
        return bool(re.match(cls.EGYPTIAN_PATTERNS["general"], cleaned))

    @classmethod
    def get_validation_tips(cls) -> str:
        """Get validation tips message"""
        return """ğŸ’¡ <b>Ù‚ÙˆØ§Ø¹Ø¯ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨:</b>

âœ… <b>Ø§Ù„Ù…Ø³Ù…ÙˆØ­:</b>
   â€¢ Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·: 01012345678
   â€¢ Ù…Ø³Ø§ÙØ§Øª Ù‚Ù„ÙŠÙ„Ø©: 010 123 456 78

âŒ <b>ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­:</b>
   â€¢ Ø­Ø±ÙˆÙ: 010abc45678
   â€¢ Ø±Ù…ÙˆØ²: 010-123-4567
   â€¢ Ø£Ù‚ÙˆØ§Ø³: (010) 1234567

ğŸ”¢ <b>Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„ØµØ­ÙŠØ­:</b>
   â€¢ ÙŠØ¨Ø¯Ø£ Ø¨Ù€: 010, 011, 012, 015
   â€¢ Ø§Ù„Ø¹Ø¯Ø¯: 11 Ø±Ù‚Ù… Ø¨Ø§Ù„Ø¶Ø¨Ø·

ğŸ”¹ <b>Ø£Ù…Ø«Ù„Ø© ØµØ­ÙŠØ­Ø©:</b>
   â€¢ 01012345678
   â€¢ 01112345678
   â€¢ 01212345678
   â€¢ 01512345678

âŒ <b>Ø£Ù…Ø«Ù„Ø© Ø®Ø§Ø·Ø¦Ø©:</b>
   â€¢ +201012345678 (Ù„Ø§ ØªØ¶Ø¹ ÙƒÙˆØ¯ Ø§Ù„Ø¯ÙˆÙ„Ø©)
   â€¢ 1012345678 (Ù†Ø§Ù‚Øµ ØµÙØ± ÙÙŠ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©)
   â€¢ 010123456 (Ø£Ù‚Ù„ Ù…Ù† 11 Ø±Ù‚Ù…)"""


--- FC26_sale_coins_Bot/validators/url_validator.py ---

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              ğŸ”— FC26 URL VALIDATOR - Ù…Ø¯Ù‚Ù‚ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·                       â•‘
# â•‘                        URL Validation                                    â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import re
import logging
from typing import Dict, Any, List
from urllib.parse import urlparse

logger = logging.getLogger(__name__)

class URLValidator:
    """URL validation for InstaPay and other links"""
    
    INSTAPAY_DOMAINS = [
        'instapay.com.eg',
        'ipn.eg',
        'instapay.eg'
    ]
    
    @classmethod
    def validate_instapay_url(cls, url: str) -> Dict[str, Any]:
        """
        Validate InstaPay URL
        
        Args:
            url (str): URL to validate
            
        Returns:
            Dict[str, Any]: Validation result
        """
        try:
            # Clean and normalize URL
            cleaned_url = url.strip()
            
            # Add protocol if missing
            if not cleaned_url.startswith(('http://', 'https://')):
                cleaned_url = 'https://' + cleaned_url
            
            # Parse URL
            parsed = urlparse(cleaned_url)
            
            # Check if it's a valid URL structure
            if not parsed.netloc:
                return {
                    "valid": False,
                    "error": "âŒ Ø±Ø§Ø¨Ø· ØºÙŠØ± ØµØ­ÙŠØ­. ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¯Ø®Ø§Ù„ Ø±Ø§Ø¨Ø· ÙƒØ§Ù…Ù„",
                }
            
            # Check InstaPay domains
            domain_valid = any(domain in parsed.netloc.lower() for domain in cls.INSTAPAY_DOMAINS)
            
            if not domain_valid:
                return {
                    "valid": False,
                    "error": f"âŒ Ø±Ø§Ø¨Ø· Ø¥Ù†Ø³ØªØ§Ø¨Ø§ÙŠ ØºÙŠØ± ØµØ­ÙŠØ­. ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø£Ø­Ø¯ Ø§Ù„Ù†Ø·Ø§Ù‚Ø§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©:\n" +
                            "\n".join([f"â€¢ {domain}" for domain in cls.INSTAPAY_DOMAINS]),
                }
            
            # Additional security checks
            security_check = cls._security_validate_url(cleaned_url)
            if not security_check["valid"]:
                return security_check
            
            return {
                "valid": True,
                "cleaned": cleaned_url,
                "formatted": cleaned_url,
                "display": cleaned_url,
                "clickable": f"<code>{cleaned_url}</code>",
                "domain": parsed.netloc,
                "path": parsed.path
            }
            
        except Exception as e:
            logger.error(f"URL validation error: {e}")
            return {
                "valid": False,
                "error": "âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø±Ø§Ø¨Ø·"
            }
    
    @classmethod
    def _security_validate_url(cls, url: str) -> Dict[str, Any]:
        """Security validation for URLs"""
        
        # Check for suspicious patterns
        suspicious_patterns = [
            r'javascript:',
            r'data:',
            r'file:',
            r'ftp:',
            r'<script',
            r'onclick',
            r'onload'
        ]
        
        url_lower = url.lower()
        for pattern in suspicious_patterns:
            if re.search(pattern, url_lower):
                return {
                    "valid": False,
                    "error": "âŒ Ø§Ù„Ø±Ø§Ø¨Ø· ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù…Ø­ØªÙˆÙ‰ Ù…Ø´Ø¨ÙˆÙ‡"
                }
        
        # Check URL length (reasonable limit)
        if len(url) > 500:
            return {
                "valid": False,
                "error": "âŒ Ø§Ù„Ø±Ø§Ø¨Ø· Ø·ÙˆÙŠÙ„ Ø¬Ø¯Ø§Ù‹"
            }
        
        return {"valid": True}
    
    @classmethod
    def extract_instapay_from_text(cls, text: str) -> List[str]:
        """Extract InstaPay URLs from text"""
        try:
            # Pattern to match URLs containing InstaPay domains
            patterns = []
            for domain in cls.INSTAPAY_DOMAINS:
                patterns.append(rf'https?://[^\s]*{re.escape(domain)}[^\s]*')
            
            found_urls = []
            for pattern in patterns:
                matches = re.findall(pattern, text, re.IGNORECASE)
                found_urls.extend(matches)
            
            return list(set(found_urls))  # Remove duplicates
            
        except Exception as e:
            logger.error(f"Error extracting URLs: {e}")
            return []
    
    @classmethod
    def is_valid_url_format(cls, url: str) -> bool:
        """Quick check if URL has valid format"""
        try:
            parsed = urlparse(url)
            return bool(parsed.netloc and parsed.scheme in ['http', 'https'])
        except:
            return False
    
    @classmethod
    def get_instapay_help_message(cls) -> str:
        """Get help message for InstaPay URL format"""
        return f"""ğŸ’¡ <b>ÙƒÙŠÙÙŠØ© Ø¥Ø¯Ø®Ø§Ù„ Ø±Ø§Ø¨Ø· Ø¥Ù†Ø³ØªØ§Ø¨Ø§ÙŠ:</b>

ğŸ”¹ <b>Ø§Ù„Ù†Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ù…Ù‚Ø¨ÙˆÙ„Ø©:</b>
{chr(10).join([f"   â€¢ {domain}" for domain in cls.INSTAPAY_DOMAINS])}

ğŸ”¹ <b>Ø£Ù…Ø«Ù„Ø© ØµØ­ÙŠØ­Ø©:</b>
   â€¢ https://instapay.com.eg/abc123
   â€¢ https://ipn.eg/xyz789
   â€¢ instapay.com.eg/payment/456 (Ø³ÙŠØªÙ… Ø¥Ø¶Ø§ÙØ© https ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹)

ğŸ”¹ <b>Ù†ØµØ§Ø¦Ø­:</b>
   â€¢ Ø§Ù†Ø³Ø® Ø§Ù„Ø±Ø§Ø¨Ø· ÙƒØ§Ù…Ù„Ø§Ù‹ Ù…Ù† Ø¥Ù†Ø³ØªØ§Ø¨Ø§ÙŠ
   â€¢ ØªØ£ÙƒØ¯ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø±Ø§Ø¨Ø· Ù‚Ø¨Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„
   â€¢ Ù„Ø§ ØªØ­ØªØ§Ø¬ Ù„Ø¥Ø¶Ø§ÙØ© https:// (Ø³ÙŠØªÙ… Ø¥Ø¶Ø§ÙØªÙ‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹)

âŒ <b>Ø£Ù…Ø«Ù„Ø© Ø®Ø§Ø·Ø¦Ø©:</b>
   â€¢ Ø±ÙˆØ§Ø¨Ø· Ù…Ù† Ù…ÙˆØ§Ù‚Ø¹ Ø£Ø®Ø±Ù‰
   â€¢ Ø±ÙˆØ§Ø¨Ø· ØºÙŠØ± Ù…ÙƒØªÙ…Ù„Ø©
   â€¢ Ù†ØµÙˆØµ Ø¨Ø¯ÙˆÙ† Ø±Ø§Ø¨Ø·"""
