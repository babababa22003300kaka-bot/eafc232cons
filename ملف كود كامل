Selected Files Directory Structure:

└── ./
    └── FC26_sale_coins_Bot
        ├── core
        │   └── bot_app.py
        ├── database
        │   ├── __init__.py
        │   ├── admin_operations.py
        │   ├── connection.py
        │   ├── models.py
        │   └── operations.py
        ├── handlers
        │   ├── commands
        │   │   └── basic_commands.py
        │   ├── recovery
        │   │   └── global_router.py
        │   ├── registration
        │   │   ├── conversation.py
        │   │   ├── handlers.py
        │   │   ├── helpers.py
        │   │   └── states.py
        │   ├── __init__.py
        │   ├── continue_handler.py
        │   ├── profile_delete_handler.py
        │   └── start_handler.py
        ├── keyboards
        │   ├── __init__.py
        │   ├── payment_keyboard.py
        │   └── platform_keyboard.py
        ├── messages
        │   ├── __init__.py
        │   ├── confirmation_msgs.py
        │   ├── error_messages.py
        │   ├── summary_messages.py
        │   └── welcome_messages.py
        ├── services
        │   ├── admin
        │   │   ├── __init__.py
        │   │   ├── admin_conversation_handler.py
        │   │   ├── admin_handler.py
        │   │   ├── admin_keyboards.py
        │   │   ├── admin_messages.py
        │   │   └── price_management.py
        │   ├── sell_coins
        │   │   ├── __init__.py
        │   │   ├── sell_callbacks.py
        │   │   ├── sell_conversation_functions.py
        │   │   ├── sell_conversation_handler.py
        │   │   ├── sell_handler.py
        │   │   ├── sell_keyboards.py
        │   │   ├── sell_messages.py
        │   │   └── sell_pricing.py
        │   ├── __init__.py
        │   └── service_template.py
        ├── states
        │   ├── __init__.py
        │   └── sell_states.py
        ├── utils
        │   ├── __init__.py
        │   ├── backup_job.py
        │   ├── handler_filters.py
        │   ├── locks.py
        │   ├── logger.py
        │   ├── message_tagger.py
        │   ├── session_bucket.py
        │   └── session_monitor.py
        ├── validators
        │   ├── __init__.py
        │   ├── payment_validator.py
        │   ├── phone_validator.py
        │   └── url_validator.py
        ├── config.py
        └── main.py



--- FC26_sale_coins_Bot/config.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║                🎮 FC26 GAMING BOT - CONFIGURATION                        ║
# ║                     بوت FC26 للألعاب - الإعدادات                       ║
# ╚══════════════════════════════════════════════════════════════════════════╝

import os
from typing import Dict

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║ 🔧 [ BOT CONFIGURATION ]                                                ║
# ║ 🔐 الإعدادات الأساسية والتوكن                                            ║
# ╚══════════════════════════════════════════════════════════════════════════╝

# Bot Token - يفضل استخدام متغير البيئة
BOT_TOKEN = os.getenv('BOT_TOKEN', '7607085569:AAHKE8SNOTYycRRzOCCddmm8QPDTOnEx144')

# Database Configuration
DATABASE_CONFIG = {
    'name': 'fc26_bot.db',
    'path': './database/',
    'backup_path': './database/backups/'
}

# ┌──────────────────────────────────────────────────────────────────────┐
# │ 🎮 GAMING PLATFORMS - منصات الألعاب                                 │
# └──────────────────────────────────────────────────────────────────────┘

GAMING_PLATFORMS = {
    "playstation": {"name": "🎮 PlayStation (PS4/PS5)", "emoji": "🎮"},
    "xbox": {"name": "❎ Xbox (One/Series)", "emoji": "❎"},
    "pc": {"name": "💻 PC (Origin/Steam)", "emoji": "💻"},
}

# ────────────────────────────────────────────────────────────────────────
# 💳 PAYMENT METHODS - طرق الدفع الكاملة
# ────────────────────────────────────────────────────────────────────────

PAYMENT_METHODS = {
    "vodafone_cash": "⭕️ فودافون كاش",
    "etisalat_cash": "🟢 اتصالات كاش",
    "orange_cash": "🍊 أورانج كاش",
    "we_cash": "🟣 وي كاش",
    "bank_wallet": "🏦 محفظة بنكية",
    "telda": "💳 تيلدا",
    "instapay": "🔗 إنستا باي",
}

# ────────────────────────────────────────────────────────────────────────
# 📝 LOGGING CONFIGURATION - إعداد السجلات
# ────────────────────────────────────────────────────────────────────────

LOGGING_CONFIG = {
    'level': 'INFO',
    'format': '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    'file': './logs/fc26_bot.log',
    'max_bytes': 5 * 1024 * 1024,  # 5MB
    'backup_count': 5,
    'encoding': 'utf-8'
}

# ────────────────────────────────────────────────────────────────────────
# 🛡️ SECURITY SETTINGS - إعدادات الأمان
# ────────────────────────────────────────────────────────────────────────

SECURITY_CONFIG = {
    'max_input_length': 500,
    'allowed_phone_patterns': [r'^01[0125][0-9]{8}$'],
    'blocked_chars': ['<', '>', '"', "'", '&', 'script', 'javascript'],
    'rate_limit': {
        'messages_per_minute': 10,
        'registration_attempts': 3
    }
}

# ────────────────────────────────────────────────────────────────────────
# 🎨 UI CONFIGURATION - إعدادات واجهة المستخدم
# ────────────────────────────────────────────────────────────────────────

UI_CONFIG = {
    'messages': {
        'timeout': 300,  # 5 minutes
        'auto_delete': True,
        'max_buttons_per_row': 2
    },
    'emojis': {
        'success': '✅',
        'error': '❌',
        'warning': '⚠️',
        'info': 'ℹ️',
        'loading': '⏳'
    }
}

# ────────────────────────────────────────────────────────────────────────
# 📊 STATISTICS CONFIGURATION - إعدادات الإحصائيات
# ────────────────────────────────────────────────────────────────────────

STATS_CONFIG = {
    'enabled': True,
    'daily_reports': True,
    'metrics': ['users', 'registrations', 'errors', 'response_times']
}

# ────────────────────────────────────────────────────────────────────────
# 🔄 BACKUP CONFIGURATION - إعدادات النسخ الاحتياطية
# ────────────────────────────────────────────────────────────────────────

BACKUP_CONFIG = {
    'enabled': True,
    'interval_hours': 6,
    'max_backups': 10,
    'compress': True
}

# ────────────────────────────────────────────────────────────────────────
# 🌐 ENVIRONMENT SETTINGS - إعدادات البيئة
# ────────────────────────────────────────────────────────────────────────

ENVIRONMENT = os.getenv('ENVIRONMENT', 'development')
DEBUG = os.getenv('DEBUG', 'False').lower() == 'true'

# Development/Production specific settings
if ENVIRONMENT == 'production':
    LOGGING_CONFIG['level'] = 'WARNING'
    DEBUG = False
    SECURITY_CONFIG['rate_limit']['messages_per_minute'] = 5
else:
    LOGGING_CONFIG['level'] = 'DEBUG'
    DEBUG = True

# ┌────────────────────────────────────────────────────────────────────────────┐
# │                           🎉 END OF CONFIGURATION 🎉                      │
# │                      ✨ إعدادات شاملة ومنظمة ✨                            │
# └────────────────────────────────────────────────────────────────────────────┘

--- FC26_sale_coins_Bot/core/bot_app.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              🤖 BOT APPLICATION FACTORY                                  ║
# ║              مصنع تطبيق البوت - مع Persistence                          ║
# ╚══════════════════════════════════════════════════════════════════════════╝

"""
مصنع تطبيق البوت
- تفعيل PicklePersistence
- إدارة الجلسات الدائمة
"""

from pathlib import Path

from telegram.ext import Application, PicklePersistence

from config import BOT_TOKEN


class FC26BotApp:
    """مصنع تطبيق البوت"""

    def create_application(self):
        """
        إنشاء تطبيق البوت مع تفعيل Persistence

        Returns:
            Application: تطبيق البوت جاهز
        """
        print("\n🤖 [BOT-APP] Creating application with persistence...")

        # ═══════════════════════════════════════════════════════════════════
        # 1️⃣ إنشاء مجلد data/ إذا لم يكن موجوداً
        # ═══════════════════════════════════════════════════════════════════
        data_dir = Path("data")
        data_dir.mkdir(parents=True, exist_ok=True)
        print(f"   📁 Data directory ready: {data_dir}")

        # ═══════════════════════════════════════════════════════════════════
        # 2️⃣ إنشاء كائن PicklePersistence
        # ═══════════════════════════════════════════════════════════════════
        session_file = data_dir / "sessions.pkl"

        persistence = PicklePersistence(
            filepath=str(session_file),
            update_interval=60,  # حفظ كل 60 ثانية
        )
        print(f"   💾 Persistence configured: {session_file}")
        print(f"   ⏱️ Update interval: 60 seconds")

        # ═══════════════════════════════════════════════════════════════════
        # 3️⃣ بناء التطبيق مع Persistence
        # ═══════════════════════════════════════════════════════════════════
        app = (
            Application.builder()
            .token(BOT_TOKEN)
            .persistence(persistence)  # 🔥 تفعيل Persistence
            .build()
        )

        print(f"   ✅ Application created successfully")
        print(f"   🔥 Persistence ENABLED")
        print()

        return app


--- FC26_sale_coins_Bot/database/__init__.py ---



--- FC26_sale_coins_Bot/database/admin_operations.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              🎯 FC26 ADMIN DATABASE OPERATIONS - عمليات قاعدة بيانات الادمن  ║
# ║                     Admin Database Management                            ║
# ╚══════════════════════════════════════════════════════════════════════════╝

import sqlite3
import logging
from typing import Dict, List, Optional, Tuple
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
import asyncio

logger = logging.getLogger(__name__)

class AdminOperations:
    """عمليات قاعدة البيانات للادمن"""
    
    DB_NAME = "fc26_admin.db"
    
    # 🔥 Thread-safe database executor - ONLY ONE worker to prevent locks
    # This ensures all database operations are serialized (one at a time)
    _db_executor = ThreadPoolExecutor(max_workers=1, thread_name_prefix="AdminDB")
    
    @classmethod
    def init_admin_db(cls):
        """تهيئة قاعدة بيانات الادمن"""
        conn = sqlite3.connect(cls.DB_NAME)
        cursor = conn.cursor()
        
        # جدول أسعار بيع الكوينز
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS coin_prices (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                platform TEXT NOT NULL,
                transfer_type TEXT NOT NULL,
                amount INTEGER NOT NULL,
                price INTEGER NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(platform, transfer_type, amount)
            )
        ''')
        
        # جدول سجل تعديلات الادمن
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS admin_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                admin_id INTEGER NOT NULL,
                action TEXT NOT NULL,
                details TEXT,
                timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # إدراج الأسعار الافتراضية
        cls._insert_default_prices(cursor)
        
        conn.commit()
        conn.close()
        
        logger.info("✅ Admin database initialized successfully")
    
    @classmethod
    def _insert_default_prices(cls, cursor):
        """إدراج الأسعار الافتراضية"""
        default_prices = [
            # PlayStation - Normal
            ('playstation', 'normal', 1000000, 5600),
            # PlayStation - Instant  
            ('playstation', 'instant', 1000000, 5300),
            # Xbox - Normal
            ('xbox', 'normal', 1000000, 5600),
            # Xbox - Instant
            ('xbox', 'instant', 1000000, 5300),
            # PC - Normal
            ('pc', 'normal', 1000000, 6100),
            # PC - Instant
            ('pc', 'instant', 1000000, 5800),
        ]
        
        for platform, transfer_type, amount, price in default_prices:
            cursor.execute('''
                INSERT OR IGNORE INTO coin_prices 
                (platform, transfer_type, amount, price) 
                VALUES (?, ?, ?, ?)
            ''', (platform, transfer_type, amount, price))
    
    @classmethod
    def get_price(cls, platform: str, transfer_type: str, amount: int) -> Optional[int]:
        """جلب السعر من قاعدة البيانات"""
        conn = sqlite3.connect(cls.DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT price FROM coin_prices 
            WHERE platform = ? AND transfer_type = ? AND amount = ?
        ''', (platform, transfer_type, amount))
        
        result = cursor.fetchone()
        conn.close()
        
        return result[0] if result else None
    
    @classmethod
    def _update_price_sync(cls, platform: str, transfer_type: str, amount: int, new_price: int, admin_id: int) -> bool:
        """تحديث السعر في قاعدة البيانات - النسخة المتزامنة الداخلية"""
        conn = None
        try:
            # Enable WAL mode for better concurrency
            conn = sqlite3.connect(cls.DB_NAME, timeout=30.0)
            conn.execute('PRAGMA journal_mode=WAL')
            cursor = conn.cursor()
            
            print(f"🔄 [DB] Starting price update: {platform} {transfer_type} -> {new_price}")
            
            # جلب السعر القديم
            cursor.execute('''
                SELECT price FROM coin_prices 
                WHERE platform = ? AND transfer_type = ? AND amount = ?
            ''', (platform, transfer_type, amount))
            result = cursor.fetchone()
            old_price = result[0] if result else None
            
            print(f"💰 [DB] Old price: {old_price}, New price: {new_price}")
            
            # تحديث السعر
            cursor.execute('''
                INSERT OR REPLACE INTO coin_prices 
                (platform, transfer_type, amount, price, updated_at) 
                VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)
            ''', (platform, transfer_type, amount, new_price))
            
            # تسجيل العملية في السجل
            details = f"Platform: {platform}, Type: {transfer_type}, Amount: {amount}, Old: {old_price}, New: {new_price}"
            cursor.execute('''
                INSERT INTO admin_logs (admin_id, action, details) 
                VALUES (?, ?, ?)
            ''', (admin_id, "UPDATE_PRICE", details))
            
            conn.commit()
            print(f"✅ [DB] Price updated successfully: {platform} {transfer_type} {amount} -> {new_price}")
            logger.info(f"✅ Price updated: {platform} {transfer_type} {amount} -> {new_price}")
            return True
            
        except Exception as e:
            print(f"❌ [DB] Failed to update price: {e}")
            logger.error(f"❌ Failed to update price: {e}")
            if conn:
                conn.rollback()
            return False
        finally:
            if conn:
                conn.close()
                print(f"🔒 [DB] Connection closed")
    
    @classmethod
    async def update_price(cls, platform: str, transfer_type: str, amount: int, new_price: int, admin_id: int) -> bool:
        """تحديث السعر في قاعدة البيانات - Thread-safe version"""
        print(f"📝 [DB-EXECUTOR] Submitting price update task to database executor")
        loop = asyncio.get_event_loop()
        
        # Run database operation in dedicated thread pool
        result = await loop.run_in_executor(
            cls._db_executor,
            cls._update_price_sync,
            platform, transfer_type, amount, new_price, admin_id
        )
        
        print(f"✅ [DB-EXECUTOR] Price update task completed: {result}")
        return result
    
    @classmethod
    def get_all_prices(cls) -> List[Dict]:
        """جلب جميع الأسعار"""
        conn = sqlite3.connect(cls.DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT platform, transfer_type, amount, price, updated_at 
            FROM coin_prices 
            ORDER BY platform, transfer_type, amount
        ''')
        
        results = cursor.fetchall()
        conn.close()
        
        prices = []
        for row in results:
            prices.append({
                'platform': row[0],
                'transfer_type': row[1], 
                'amount': row[2],
                'price': row[3],
                'updated_at': row[4]
            })
        
        return prices
    
    @classmethod
    def log_admin_action(cls, admin_id: int, action: str, details: str = ""):
        """تسجيل عمل الادمن"""
        conn = sqlite3.connect(cls.DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO admin_logs (admin_id, action, details) 
            VALUES (?, ?, ?)
        ''', (admin_id, action, details))
        
        conn.commit()
        conn.close()
    
    @classmethod
    def get_admin_logs(cls, limit: int = 50) -> List[Dict]:
        """جلب سجل أعمال الادمن"""
        conn = sqlite3.connect(cls.DB_NAME)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT admin_id, action, details, timestamp 
            FROM admin_logs 
            ORDER BY timestamp DESC 
            LIMIT ?
        ''', (limit,))
        
        results = cursor.fetchall()
        conn.close()
        
        logs = []
        for row in results:
            logs.append({
                'admin_id': row[0],
                'action': row[1],
                'details': row[2],
                'timestamp': row[3]
            })
        
        return logs
    
    @classmethod
    def get_current_timestamp(cls) -> str:
        """جلب الوقت الحالي"""
        return datetime.now().strftime('%Y-%m-%d %H:%M:%S')

--- FC26_sale_coins_Bot/database/connection.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              💾 FC26 DATABASE CONNECTION - اتصال قاعدة البيانات          ║
# ║                     Database Connection Management                       ║
# ╚══════════════════════════════════════════════════════════════════════════╝

import sqlite3
import logging
import os
from typing import Optional
from contextlib import contextmanager
from config import DATABASE_CONFIG

logger = logging.getLogger(__name__)

class DatabaseConnection:
    """Database connection manager with proper error handling"""
    
    def __init__(self):
        self.db_path = os.path.join(DATABASE_CONFIG['path'], DATABASE_CONFIG['name'])
        self._ensure_database_directory()
    
    def _ensure_database_directory(self):
        """Ensure database directory exists"""
        os.makedirs(DATABASE_CONFIG['path'], exist_ok=True)
        if DATABASE_CONFIG.get('backup_path'):
            os.makedirs(DATABASE_CONFIG['backup_path'], exist_ok=True)
    
    @contextmanager
    def get_connection(self):
        """Context manager for database connections"""
        conn = None
        try:
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row  # Enable dict-like access
            yield conn
        except Exception as e:
            if conn:
                conn.rollback()
            logger.error(f"Database error: {e}")
            raise
        finally:
            if conn:
                conn.close()
    
    def execute_query(self, query: str, params: tuple = ()) -> Optional[list]:
        """Execute a SELECT query and return results"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(query, params)
            return cursor.fetchall()
    
    def execute_update(self, query: str, params: tuple = ()) -> int:
        """Execute an INSERT/UPDATE/DELETE query and return affected rows"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(query, params)
            conn.commit()
            return cursor.rowcount
    
    def execute_script(self, script: str):
        """Execute multiple SQL statements"""
        with self.get_connection() as conn:
            conn.executescript(script)
            conn.commit()

# Global database instance
db = DatabaseConnection()

--- FC26_sale_coins_Bot/database/models.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              📋 FC26 DATABASE MODELS - نماذج قاعدة البيانات             ║
# ║                        Database Table Schemas                           ║
# ╚══════════════════════════════════════════════════════════════════════════╝

from database.connection import db
import logging

logger = logging.getLogger(__name__)

class DatabaseModels:
    """Database table creation and schema management"""
    
    @staticmethod
    def create_all_tables():
        """Create all required database tables"""
        try:
            # Create users table
            db.execute_update("""
                CREATE TABLE IF NOT EXISTS users (
                    telegram_id INTEGER PRIMARY KEY,
                    platform TEXT,
                    whatsapp TEXT,
                    payment_method TEXT,
                    payment_details TEXT,
                    registration_step TEXT DEFAULT 'start',
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            # Create registration_log table for tracking
            db.execute_update("""
                CREATE TABLE IF NOT EXISTS registration_log (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    telegram_id INTEGER,
                    step TEXT,
                    data TEXT,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (telegram_id) REFERENCES users (telegram_id)
                )
            """)
            
            # Create error_log table
            db.execute_update("""
                CREATE TABLE IF NOT EXISTS error_log (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    telegram_id INTEGER,
                    error_type TEXT,
                    error_message TEXT,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            # Create statistics table
            db.execute_update("""
                CREATE TABLE IF NOT EXISTS statistics (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    date DATE DEFAULT CURRENT_DATE,
                    metric_name TEXT,
                    metric_value INTEGER DEFAULT 0,
                    UNIQUE(date, metric_name)
                )
            """)
            
            logger.info("✅ All database tables created successfully")
            return True
            
        except Exception as e:
            logger.error(f"❌ Error creating database tables: {e}")
            return False
    
    @staticmethod
    def drop_all_tables():
        """Drop all tables (use with caution!)"""
        tables = ['users', 'registration_log', 'error_log', 'statistics']
        try:
            for table in tables:
                db.execute_update(f"DROP TABLE IF EXISTS {table}")
            logger.info("⚠️ All database tables dropped")
            return True
        except Exception as e:
            logger.error(f"❌ Error dropping tables: {e}")
            return False
    
    @staticmethod
    def get_table_info():
        """Get information about all tables"""
        try:
            tables_info = {}
            
            # Get all tables
            tables = db.execute_query("""
                SELECT name FROM sqlite_master 
                WHERE type='table' AND name NOT LIKE 'sqlite_%'
            """)
            
            for table in tables:
                table_name = table[0]
                
                # Get table schema
                schema = db.execute_query(f"PRAGMA table_info({table_name})")
                
                # Get row count
                count = db.execute_query(f"SELECT COUNT(*) FROM {table_name}")[0][0]
                
                tables_info[table_name] = {
                    'columns': [col[1] for col in schema],
                    'row_count': count
                }
            
            return tables_info
            
        except Exception as e:
            logger.error(f"❌ Error getting table info: {e}")
            return {}

# Initialize database on import
if __name__ != "__main__":
    DatabaseModels.create_all_tables()

--- FC26_sale_coins_Bot/database/operations.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              🔧 FC26 DATABASE OPERATIONS - عمليات قاعدة البيانات        ║
# ║                     Database CRUD Operations                             ║
# ╚══════════════════════════════════════════════════════════════════════════╝

import logging
from typing import Dict, Optional, List
from datetime import datetime
from database.connection import db

logger = logging.getLogger(__name__)

class UserOperations:
    """User-related database operations"""
    
    @staticmethod
    def save_user_step(user_id: int, step: str, data: Dict = None) -> bool:
        """Save user registration step and data"""
        try:
            # Check if user exists
            existing = db.execute_query(
                "SELECT telegram_id FROM users WHERE telegram_id = ?", (user_id,)
            )
            
            if existing:
                # Update existing user
                query = "UPDATE users SET registration_step = ?, updated_at = CURRENT_TIMESTAMP"
                params = [step, user_id]
                
                if data:
                    for key, value in data.items():
                        if key in ['platform', 'whatsapp', 'payment_method', 'payment_details']:
                            query += f", {key} = ?"
                            params.insert(-1, value)
                
                query += " WHERE telegram_id = ?"
                db.execute_update(query, tuple(params))
                
            else:
                # Insert new user
                platform = data.get('platform') if data else None
                whatsapp = data.get('whatsapp') if data else None
                payment_method = data.get('payment_method') if data else None
                payment_details = data.get('payment_details') if data else None
                
                db.execute_update("""
                    INSERT INTO users (telegram_id, platform, whatsapp, payment_method, payment_details, registration_step)
                    VALUES (?, ?, ?, ?, ?, ?)
                """, (user_id, platform, whatsapp, payment_method, payment_details, step))
            
            # Log the step
            RegistrationOperations.log_step(user_id, step, str(data) if data else None)
            
            logger.info(f"✅ Step saved for user {user_id}: {step}")
            return True
            
        except Exception as e:
            logger.error(f"❌ Error saving user step: {e}")
            return False
    
    @staticmethod
    def get_user_data(user_id: int) -> Optional[Dict]:
        """Get user data from database"""
        try:
            result = db.execute_query("""
                SELECT telegram_id, platform, whatsapp, payment_method, 
                       payment_details, registration_step, created_at, updated_at
                FROM users WHERE telegram_id = ?
            """, (user_id,))
            
            if result:
                row = result[0]
                return {
                    "telegram_id": row[0],
                    "platform": row[1],
                    "whatsapp": row[2],
                    "payment_method": row[3],
                    "payment_details": row[4],
                    "registration_step": row[5],
                    "created_at": row[6],
                    "updated_at": row[7]
                }
            return None
            
        except Exception as e:
            logger.error(f"❌ Error getting user data: {e}")
            return None
    
    @staticmethod
    def user_exists(user_id: int) -> bool:
        """Check if user exists in database"""
        try:
            result = db.execute_query(
                "SELECT telegram_id FROM users WHERE telegram_id = ?", (user_id,)
            )
            return len(result) > 0
        except Exception as e:
            logger.error(f"❌ Error checking user existence: {e}")
            return False
    
    @staticmethod
    def delete_user(user_id: int) -> bool:
        """Delete user and related data"""
        try:
            # Delete user data
            affected = db.execute_update("DELETE FROM users WHERE telegram_id = ?", (user_id,))
            
            # Delete registration logs
            db.execute_update("DELETE FROM registration_log WHERE telegram_id = ?", (user_id,))
            
            if affected > 0:
                logger.info(f"✅ User {user_id} deleted successfully")
                return True
            else:
                logger.warning(f"⚠️ User {user_id} not found for deletion")
                return False
                
        except Exception as e:
            logger.error(f"❌ Error deleting user: {e}")
            return False
    
    @staticmethod
    def update_user_field(user_id: int, field: str, value: str) -> bool:
        """Update specific field for user"""
        allowed_fields = {'platform', 'whatsapp', 'payment_method', 'payment_details', 'registration_step'}
        
        if field not in allowed_fields:
            logger.error(f"❌ Invalid field name: {field}")
            return False
        
        try:
            affected = db.execute_update(
                f"UPDATE users SET {field} = ?, updated_at = CURRENT_TIMESTAMP WHERE telegram_id = ?",
                (value, user_id)
            )
            
            if affected > 0:
                logger.info(f"✅ Field {field} updated for user {user_id}")
                return True
            else:
                logger.warning(f"⚠️ User {user_id} not found for field update")
                return False
                
        except Exception as e:
            logger.error(f"❌ Error updating user field: {e}")
            return False

class RegistrationOperations:
    """Registration tracking operations"""
    
    @staticmethod
    def log_step(user_id: int, step: str, data: str = None) -> bool:
        """Log registration step"""
        try:
            db.execute_update("""
                INSERT INTO registration_log (telegram_id, step, data)
                VALUES (?, ?, ?)
            """, (user_id, step, data))
            return True
        except Exception as e:
            logger.error(f"❌ Error logging registration step: {e}")
            return False
    
    @staticmethod
    def get_user_registration_history(user_id: int) -> List[Dict]:
        """Get user's registration history"""
        try:
            result = db.execute_query("""
                SELECT step, data, timestamp 
                FROM registration_log 
                WHERE telegram_id = ? 
                ORDER BY timestamp DESC
            """, (user_id,))
            
            return [{"step": row[0], "data": row[1], "timestamp": row[2]} for row in result]
        except Exception as e:
            logger.error(f"❌ Error getting registration history: {e}")
            return []

class StatisticsOperations:
    """Statistics and analytics operations"""
    
    @staticmethod
    def get_users_count() -> int:
        """Get total number of users"""
        try:
            result = db.execute_query("SELECT COUNT(*) FROM users")
            return result[0][0] if result else 0
        except Exception as e:
            logger.error(f"❌ Error getting users count: {e}")
            return 0
    
    @staticmethod
    def get_completed_registrations() -> int:
        """Get number of completed registrations"""
        try:
            result = db.execute_query(
                "SELECT COUNT(*) FROM users WHERE registration_step = 'completed'"
            )
            return result[0][0] if result else 0
        except Exception as e:
            logger.error(f"❌ Error getting completed registrations: {e}")
            return 0
    
    @staticmethod
    def update_daily_metric(metric_name: str, value: int = 1) -> bool:
        """Update daily metric"""
        try:
            # Try to update existing record
            affected = db.execute_update("""
                UPDATE statistics 
                SET metric_value = metric_value + ? 
                WHERE date = CURRENT_DATE AND metric_name = ?
            """, (value, metric_name))
            
            # If no record exists, create new one
            if affected == 0:
                db.execute_update("""
                    INSERT INTO statistics (metric_name, metric_value)
                    VALUES (?, ?)
                """, (metric_name, value))
            
            return True
        except Exception as e:
            logger.error(f"❌ Error updating daily metric: {e}")
            return False

class ErrorOperations:
    """Error logging operations"""
    
    @staticmethod
    def log_error(user_id: int, error_type: str, error_message: str) -> bool:
        """Log error to database"""
        try:
            db.execute_update("""
                INSERT INTO error_log (telegram_id, error_type, error_message)
                VALUES (?, ?, ?)
            """, (user_id, error_type, error_message))
            return True
        except Exception as e:
            logger.error(f"❌ Error logging error: {e}")
            return False

--- FC26_sale_coins_Bot/handlers/__init__.py ---



--- FC26_sale_coins_Bot/handlers/commands/basic_commands.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              🔧 BASIC COMMANDS                                           ║
# ║              الأوامر الأساسية                                           ║
# ╚══════════════════════════════════════════════════════════════════════════╝

"""
الأوامر الأساسية
- /help
- /profile
- /delete
"""

from telegram.ext import CommandHandler

from database.operations import UserOperations
from handlers.profile_delete_handler import ProfileDeleteHandler
from messages.error_messages import ErrorMessages
from messages.summary_messages import SummaryMessages
from messages.welcome_messages import WelcomeMessages
from utils.logger import log_user_action


async def handle_help(update, context):
    """أمر /help"""
    user_id = update.effective_user.id
    log_user_action(user_id, "Help")

    await update.message.reply_text(
        WelcomeMessages.get_help_message(), parse_mode="HTML"
    )


async def handle_profile(update, context):
    """أمر /profile"""
    user_id = update.effective_user.id
    log_user_action(user_id, "Profile")

    user_data = UserOperations.get_user_data(user_id)

    if not user_data:
        await update.message.reply_text(ErrorMessages.get_start_required_error())
        return

    profile_text = SummaryMessages.create_user_profile_summary(user_data)
    keyboard = ProfileDeleteHandler.create_profile_management_keyboard()

    await update.message.reply_text(
        profile_text, reply_markup=keyboard, parse_mode="HTML"
    )


async def handle_delete(update, context):
    """أمر /delete"""
    user_id = update.effective_user.id
    log_user_action(user_id, "Delete request")

    user_data = UserOperations.get_user_data(user_id)

    if not user_data:
        await update.message.reply_text(
            "❌ <b>لا يوجد ملف شخصي!</b>\n\n🚀 /start للتسجيل",
            parse_mode="HTML",
        )
        return

    username = update.effective_user.username or "غير محدد"

    confirmation_text = f"""⚠️ <b>تحذير!</b>

🗑️ <b>مسح نهائي للملف الشخصي</b>

<b>📋 البيانات:</b>
• 🎮 {user_data.get('platform', 'غير محدد')}
• 📱 {user_data.get('whatsapp', 'غير محدد')}

<b>👤 المستخدم:</b> @{username}

<b>❓ متأكد؟</b>"""

    keyboard = ProfileDeleteHandler.create_delete_confirmation_keyboard()

    await update.message.reply_text(
        confirmation_text, reply_markup=keyboard, parse_mode="HTML"
    )


def get_command_handlers():
    """الحصول على جميع handlers الأوامر الأساسية"""
    handlers = [
        CommandHandler("help", handle_help),
        CommandHandler("profile", handle_profile),
        CommandHandler("delete", handle_delete),
    ]

    # إضافة handlers من ProfileDeleteHandler
    handlers.extend(ProfileDeleteHandler.get_handlers())

    return handlers


--- FC26_sale_coins_Bot/handlers/continue_handler.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              🔄 FC26 CONTINUE HANDLER - معالج الاستكمال                 ║
# ║                    Continue Registration Handler                         ║
# ╚══════════════════════════════════════════════════════════════════════════╝

from telegram import Update
from telegram.ext import ContextTypes
from messages.welcome_messages import WelcomeMessages
from keyboards.platform_keyboard import PlatformKeyboard
from keyboards.payment_keyboard import PaymentKeyboard
from utils.logger import log_user_action

async def handle_continue_registration(update: Update, context: ContextTypes.DEFAULT_TYPE, user_data: dict):
    """Handle continuing registration from where user left off"""
    user_id = update.effective_user.id
    step = user_data.get("registration_step", "start")
    
    log_user_action(user_id, f"Continue registration from step: {step}")
    
    try:
        # Get continuation message
        continue_text = WelcomeMessages.get_continue_registration_message(step, user_data)
        
        if step == "choosing_platform":
            # Show platform selection keyboard
            keyboard = PlatformKeyboard.create_platform_selection_keyboard()
            await update.message.reply_text(
                continue_text, 
                reply_markup=keyboard, 
                parse_mode="HTML"
            )
            
        elif step == "choosing_payment":
            # Show payment selection keyboard
            keyboard = PaymentKeyboard.create_payment_selection_keyboard()
            await update.message.reply_text(
                continue_text, 
                reply_markup=keyboard, 
                parse_mode="HTML"
            )
            
        elif step == "entering_whatsapp":
            # Just show the message for WhatsApp input
            await update.message.reply_text(continue_text, parse_mode="Markdown")
            
        elif step == "entering_payment_details":
            # Just show the message for payment details input
            await update.message.reply_text(continue_text, parse_mode="Markdown")
            
        else:
            # Default case - show basic continue message
            await update.message.reply_text(continue_text, parse_mode="Markdown")
            
    except Exception as e:
        from utils.logger import fc26_logger
        logger = fc26_logger.get_logger()
        logger.error(f"❌ Error in continue registration for user {user_id}: {e}")
        
        from messages.error_messages import ErrorMessages
        await update.message.reply_text(ErrorMessages.get_general_error(), parse_mode="HTML")

--- FC26_sale_coins_Bot/handlers/profile_delete_handler.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              🗑️ FC26 PROFILE DELETE HANDLER - معالج مسح الملف الشخصي      ║
# ║                     Profile Management & Deletion                        ║
# ╚══════════════════════════════════════════════════════════════════════════╝

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, CallbackQueryHandler
from typing import List

# Import database operations
from database.operations import UserOperations

# Import logging utilities
from utils.logger import log_user_action, fc26_logger

# Import messages
from messages.error_messages import ErrorMessages

class ProfileDeleteHandler:
    """Handle profile management and deletion functionality"""
    
    @staticmethod
    def create_profile_management_keyboard():
        """Create keyboard for profile management with delete option"""
        keyboard = [
            [InlineKeyboardButton("🗑️ مسح الملف الشخصي", callback_data="delete_profile_confirm")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def create_delete_confirmation_keyboard():
        """Create confirmation keyboard for profile deletion"""
        keyboard = [
            [
                InlineKeyboardButton("❌ نعم، امسح كل شيء", callback_data="delete_profile_execute"),
                InlineKeyboardButton("✅ لا، راجع تاني", callback_data="delete_profile_cancel")
            ]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    async def handle_delete_confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle delete profile confirmation dialog"""
        query = update.callback_query
        user_id = query.from_user.id
        username = query.from_user.username or "غير محدد"
        
        logger = fc26_logger.get_logger()
        logger.info(f"🗑️ User {user_id} requested profile deletion confirmation")
        
        try:
            await query.answer()
            
            # Check if user exists
            user_data = UserOperations.get_user_data(user_id)
            if not user_data:
                await query.edit_message_text(
                    "❌ لم يتم العثور على ملف شخصي لحذفه!\n\n🚀 اكتب /start لبدء التسجيل",
                    parse_mode="HTML"
                )
                return
            
            # Create confirmation message
            confirmation_text = f"""⚠️ <b>تحذير هام!</b>

🗑️ <b>أنت على وشك مسح ملفك الشخصي نهائياً</b>

<b>📋 سيتم مسح البيانات التالية:</b>
• 🎮 المنصة: {user_data.get('platform', 'غير محدد')}
• 📱 رقم الواتساب: {user_data.get('whatsapp', 'غير محدد')}  
• 💳 طريقة الدفع: {user_data.get('payment_method', 'غير محدد')}
• 📊 سجل التسجيل والإحصائيات
• 🗂️ جميع البيانات المرتبطة بحسابك

<b>⚠️ هذا الإجراء لا يمكن التراجع عنه!</b>

<b>🔄 بعد المسح:</b>
• ستحتاج للتسجيل من البداية
• ستفقد جميع بياناتك المحفوظة
• لن نتمكن من استرداد أي معلومات

<b>👤 المستخدم:</b> @{username}
<b>🆔 معرف التليجرام:</b> {user_id}

<b>❓ هل أنت متأكد من رغبتك في المتابعة؟</b>"""
            
            keyboard = ProfileDeleteHandler.create_delete_confirmation_keyboard()
            
            await query.edit_message_text(
                confirmation_text,
                reply_markup=keyboard,
                parse_mode="HTML"
            )
            
            log_user_action(user_id, f"Profile deletion confirmation shown", f"@{username}")
            
        except Exception as e:
            logger.error(f"❌ Error showing deletion confirmation for user {user_id}: {e}")
            await query.edit_message_text(
                ErrorMessages.get_general_error(),
                parse_mode="HTML"
            )
    
    @staticmethod
    async def handle_delete_execution(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Execute profile deletion"""
        query = update.callback_query
        user_id = query.from_user.id
        username = query.from_user.username or "غير محدد"
        
        logger = fc26_logger.get_logger()
        logger.info(f"🗑️ User {user_id} confirmed profile deletion - executing...")
        
        try:
            await query.answer()
            
            # Check if user exists before deletion
            user_data = UserOperations.get_user_data(user_id)
            if not user_data:
                await query.edit_message_text(
                    "❌ <b>الملف الشخصي غير موجود!</b>\n\n🚀 اكتب /start لبدء التسجيل من جديد",
                    parse_mode="HTML"
                )
                return
            
            # Execute deletion
            deletion_success = UserOperations.delete_user(user_id)
            
            if deletion_success:
                # Success message
                success_message = f"""✅ <b>تم مسح الملف الشخصي بنجاح!</b>

🗑️ <b>البيانات الممسوحة:</b>
• جميع معلومات التسجيل
• سجل الأنشطة والإحصائيات  
• البيانات الشخصية والدفع
• سجل الأخطاء المرتبط بالحساب

<b>🎮 أهلاً بك من جديد في FC26!</b>

🚀 <b>للتسجيل مرة أخرى:</b>
اكتب /start وابدأ رحلتك من جديد

<b>👋 شكراً لاستخدامك بوت FC26</b>"""
                
                await query.edit_message_text(success_message, parse_mode="HTML")
                
                log_user_action(user_id, f"Profile deletion completed successfully", f"@{username}")
                logger.info(f"✅ User {user_id} profile deleted successfully")
                
            else:
                # Failure message
                await query.edit_message_text(
                    "❌ <b>حدث خطأ أثناء مسح الملف الشخصي!</b>\n\n🔄 الرجاء المحاولة مرة أخرى أو التواصل مع الدعم الفني",
                    parse_mode="HTML"
                )
                logger.error(f"❌ Failed to delete user {user_id} profile")
        
        except Exception as e:
            logger.error(f"❌ Error executing profile deletion for user {user_id}: {e}")
            await query.edit_message_text(
                ErrorMessages.get_general_error(),
                parse_mode="HTML"
            )
    
    @staticmethod
    async def handle_delete_cancellation(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle profile deletion cancellation"""
        query = update.callback_query
        user_id = query.from_user.id
        username = query.from_user.username or "غير محدد"
        
        logger = fc26_logger.get_logger()
        logger.info(f"🚫 User {user_id} cancelled profile deletion")
        
        try:
            await query.answer("تم الإلغاء - لم يحدث أي تغيير")
            
            cancellation_message = """✅ <b>تم إلغاء العملية بنجاح!</b>

🛡️ <b>لم يتم مسح أي بيانات</b>
📊 ملفك الشخصي آمن ولم يتأثر

<b>🎮 يمكنك الآن:</b>
• 👤 اكتب /profile لعرض ملفك الشخصي
• 📞 اكتب /help للمساعدة والدعم  
• 🏠 اكتب /start للقائمة الرئيسية

<b>💚 شكراً لك على الحذر!</b>"""

            await query.edit_message_text(cancellation_message, parse_mode="HTML")
            
            log_user_action(user_id, f"Profile deletion cancelled", f"@{username}")
            
        except Exception as e:
            logger = fc26_logger.get_logger()
            logger.error(f"❌ Error handling deletion cancellation for user {user_id}: {e}")
            await query.edit_message_text(
                ErrorMessages.get_general_error(),
                parse_mode="HTML"
            )
    
    @staticmethod
    def get_handlers() -> List[CallbackQueryHandler]:
        """Get all callback handlers for profile deletion"""
        return [
            CallbackQueryHandler(ProfileDeleteHandler.handle_delete_confirmation, pattern="^delete_profile_confirm$"),
            CallbackQueryHandler(ProfileDeleteHandler.handle_delete_execution, pattern="^delete_profile_execute$"),
            CallbackQueryHandler(ProfileDeleteHandler.handle_delete_cancellation, pattern="^delete_profile_cancel$")
        ]

--- FC26_sale_coins_Bot/handlers/recovery/global_router.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              🛡️ GLOBAL RECOVERY ROUTER                                  ║
# ║              الموجه العالمي للاسترداد                                   ║
# ╚══════════════════════════════════════════════════════════════════════════╝

"""
الموجه العالمي للاسترداد
- يلتقط الرسائل التي لم تُعالج
- يتحقق من الوسم أولاً
- يساعد المستخدمين الضائعين
"""

from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import MessageHandler, filters

from database.operations import UserOperations
from utils.message_tagger import MessageTagger


async def global_recovery_router(update, context):
    """
    الموجه العالمي للاسترداد - مع فحص الوسم
    """
    user_id = update.effective_user.id

    print(f"\n{'='*80}")
    print(f"🛡️ [GLOBAL-RECOVERY] Triggered by user {user_id}")
    print(f"{'='*80}")

    # ═══════════════════════════════════════════════════════════════════════
    # 🔥 STEP 1: CHECK FOR HANDLED TAG (CRITICAL!)
    # ═══════════════════════════════════════════════════════════════════════

    if MessageTagger.check_and_clear(context):
        print(f"   🏷️ Message already handled by ConversationHandler")
        print(f"{'='*80}\n")
        return

    print(f"   ✅ [TAG-CHECK] No tag found - checking status...")

    # ═══════════════════════════════════════════════════════════════════════
    # STEP 2: NORMAL RECOVERY LOGIC
    # ═══════════════════════════════════════════════════════════════════════

    text = update.message.text

    if text.startswith("/"):
        print(f"   ⏭️ Skipping: Is a command")
        print(f"{'='*80}\n")
        return

    if context.user_data.get("_buckets"):
        print(f"   ⏭️ Skipping: Active conversation exists")
        print(f"   📝 Buckets: {list(context.user_data['_buckets'].keys())}")
        print(f"{'='*80}\n")
        return

    print(f"   🔍 No active conversation - checking database...")

    user_data = UserOperations.get_user_data(user_id)

    if not user_data:
        print(f"   🆕 New user detected")

        await update.message.reply_text(
            "👋 <b>مرحباً!</b>\n\n"
            "يبدو أنك جديد هنا.\n\n"
            "🚀 اكتب <code>/start</code> لبدء التسجيل\n"
            "❓ اكتب <code>/help</code> للمساعدة",
            parse_mode="HTML",
        )

        print(f"   ✅ New user message sent")
        print(f"{'='*80}\n")
        return

    current_step = user_data.get("registration_step", "unknown")

    if current_step == "completed":
        print(f"   ✅ Completed registration detected")

        await update.message.reply_text(
            "✅ <b>أنت مسجل بالفعل!</b>\n\n"
            "📋 <b>الأوامر المتاحة:</b>\n"
            "🔹 <code>/profile</code> - ملفك الشخصي\n"
            "🔹 <code>/sell</code> - بيع الكوينز\n"
            "🔹 <code>/help</code> - المساعدة\n"
            "🔹 <code>/start</code> - القائمة الرئيسية",
            parse_mode="HTML",
        )

        print(f"   ✅ Completed user message sent")
        print(f"{'='*80}\n")
        return

    else:
        print(f"   ⚠️ Interrupted registration detected: {current_step}")

        platform = user_data.get("platform", "غير محدد")
        whatsapp = user_data.get("whatsapp", "لم يُدخل بعد")

        question_text = f"""🔄 <b>لاحظت أن تسجيلك لم يكتمل!</b>

📋 <b>بياناتك:</b>
• 🎮 المنصة: {platform}
• 📱 الواتساب: {whatsapp}

<b>❓ تحب تكمل ولا تبدأ من جديد؟</b>"""

        keyboard = [
            [InlineKeyboardButton("✅ متابعة", callback_data="reg_continue")],
            [InlineKeyboardButton("🔄 بدء من جديد", callback_data="reg_restart")],
        ]

        await update.message.reply_text(
            question_text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="HTML",
        )

        print(f"   ✅ Recovery question sent")
        print(f"{'='*80}\n")
        return


def get_recovery_handler():
    """إنشاء handler الاسترداد العالمي"""
    return MessageHandler(filters.TEXT & ~filters.COMMAND, global_recovery_router)


--- FC26_sale_coins_Bot/handlers/registration/conversation.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              📝 REGISTRATION CONVERSATION                                ║
# ║                  محادثة التسجيل - ConversationHandler                  ║
# ╚══════════════════════════════════════════════════════════════════════════╝

"""
محادثة التسجيل الكاملة
- مع Persistence
- مع Message Tagging
- مع Session Buckets
"""

from telegram.ext import (
    CallbackQueryHandler,
    CommandHandler,
    ConversationHandler,
    MessageHandler,
    filters,
)

from .handlers import RegistrationHandlers
from .states import REG_INTERRUPTED, REG_PAYMENT, REG_PLATFORM, REG_WHATSAPP


def get_registration_handler():
    """إنشاء ConversationHandler للتسجيل"""

    return ConversationHandler(
        entry_points=[
            CommandHandler("start", RegistrationHandlers.start_registration),
            CallbackQueryHandler(
                RegistrationHandlers.handle_interrupted_choice,
                pattern="^reg_(continue|restart)$",
            ),
        ],
        states={
            REG_PLATFORM: [
                CallbackQueryHandler(
                    RegistrationHandlers.handle_platform_callback,
                    pattern="^platform_",
                ),
                MessageHandler(
                    filters.TEXT & ~filters.COMMAND,
                    RegistrationHandlers.nudge_platform,
                ),
            ],
            REG_WHATSAPP: [
                MessageHandler(
                    filters.TEXT & ~filters.COMMAND,
                    RegistrationHandlers.handle_whatsapp,
                ),
            ],
            REG_PAYMENT: [
                CallbackQueryHandler(
                    RegistrationHandlers.handle_payment_callback,
                    pattern="^payment_",
                ),
                MessageHandler(
                    filters.TEXT & ~filters.COMMAND,
                    RegistrationHandlers.handle_payment_details,
                ),
            ],
            REG_INTERRUPTED: [
                CallbackQueryHandler(
                    RegistrationHandlers.handle_interrupted_choice,
                    pattern="^reg_(continue|restart)$",
                ),
                MessageHandler(
                    filters.TEXT & ~filters.COMMAND,
                    RegistrationHandlers.nudge_interrupted,
                ),
            ],
        },
        fallbacks=[CommandHandler("cancel", RegistrationHandlers.cancel_registration)],
        name="registration",
        persistent=True,  # 🔥 تفعيل Persistence
        per_user=True,
        allow_reentry=True,
        block=True,
    )


--- FC26_sale_coins_Bot/handlers/registration/handlers.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              📝 REGISTRATION HANDLERS                                    ║
# ║                  معالجات التسجيل - مع نظام الوسم والعزل                ║
# ╚══════════════════════════════════════════════════════════════════════════╝

"""
معالجات خدمة التسجيل
- مع نظام وسم الرسائل (MessageTagger)
- مع نظام عزل البيانات (Session Buckets)
"""

from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ConversationHandler

from database.operations import StatisticsOperations, UserOperations
from keyboards.payment_keyboard import PaymentKeyboard
from keyboards.platform_keyboard import PlatformKeyboard
from messages.confirmation_msgs import ConfirmationMessages
from messages.error_messages import ErrorMessages
from messages.welcome_messages import WelcomeMessages
from utils.locks import is_rate_limited
from utils.logger import log_user_action
from utils.message_tagger import MessageTagger
from utils.session_bucket import bucket, clear_bucket
from validators.payment_validator import PaymentValidator
from validators.phone_validator import PhoneValidator


class RegistrationHandlers:
    """معالجات التسجيل مع نظام الوسم والعزل"""

    @staticmethod
    async def start_registration(update, context):
        """الموجه الذكي - Smart Router"""
        MessageTagger.mark_as_handled(context)

        user_id = update.effective_user.id
        username = update.effective_user.username or "Unknown"

        print(f"\n{'='*80}")
        print(f"🧠 [SMART-ROUTER] /start from user {user_id} (@{username})")
        print(f"{'='*80}")

        if is_rate_limited(user_id):
            print(f"🚫 [SMART-ROUTER] Rate limited")
            await update.message.reply_text(ErrorMessages.get_rate_limit_error())
            return ConversationHandler.END

        log_user_action(user_id, "Started bot", f"@{username}")

        print(f"🔍 [SMART-ROUTER] Checking for interrupted registration...")

        reg_bucket = bucket(context, "reg")
        has_memory_data = bool(reg_bucket.get("platform")) or bool(
            reg_bucket.get("interrupted_platform")
        )
        print(f"   📝 Memory check: {has_memory_data}")

        user_data = UserOperations.get_user_data(user_id)
        current_step = (
            user_data.get("registration_step", "unknown") if user_data else "unknown"
        )
        print(f"   💾 Database step: {current_step}")

        is_interrupted = False
        interrupted_data = None

        if current_step == "completed":
            print(f"✅ [SMART-ROUTER] User completed - showing menu")
            await RegistrationHandlers._show_main_menu(update, user_data)
            return ConversationHandler.END

        elif current_step in [
            "entering_whatsapp",
            "choosing_payment",
            "entering_payment_details",
        ]:
            print(f"⚠️ [SMART-ROUTER] Interrupted in DATABASE at: {current_step}")
            is_interrupted = True
            interrupted_data = user_data

        elif has_memory_data:
            print(f"⚠️ [SMART-ROUTER] Interrupted in MEMORY")
            is_interrupted = True
            interrupted_data = reg_bucket

        if is_interrupted:
            print(f"🤔 [SMART-ROUTER] Asking user for decision...")

            reg_bucket["interrupted_platform"] = interrupted_data.get(
                "platform", "غير محدد"
            )
            reg_bucket["interrupted_whatsapp"] = interrupted_data.get("whatsapp")
            reg_bucket["interrupted_payment"] = interrupted_data.get("payment_method")
            reg_bucket["interrupted_step"] = current_step

            platform = reg_bucket["interrupted_platform"]
            whatsapp = reg_bucket["interrupted_whatsapp"] or "لم يُدخل بعد"

            question_text = f"""🤔 <b>لاحظت أنك لم تكمل تسجيلك!</b>

📋 <b>البيانات الحالية:</b>
• 🎮 المنصة: {platform}
• 📱 الواتساب: {whatsapp}

<b>❓ ماذا تريد أن تفعل؟</b>"""

            keyboard = [
                [
                    InlineKeyboardButton(
                        "✅ متابعة من حيث توقفت", callback_data="reg_continue"
                    )
                ],
                [InlineKeyboardButton("🔄 البدء من جديد", callback_data="reg_restart")],
            ]

            await update.message.reply_text(
                question_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="HTML",
            )

            print(f"➡️ [SMART-ROUTER] → REG_INTERRUPTED state")
            print(f"{'='*80}\n")
            from .states import REG_INTERRUPTED

            return REG_INTERRUPTED

        print(f"🆕 [SMART-ROUTER] Fresh start")
        clear_bucket(context, "reg")

        keyboard = PlatformKeyboard.create_platform_selection_keyboard()
        await update.message.reply_text(
            WelcomeMessages.get_start_message(),
            reply_markup=keyboard,
            parse_mode="HTML",
        )

        print(f"➡️ [SMART-ROUTER] → REG_PLATFORM state")
        print(f"{'='*80}\n")
        from .states import REG_PLATFORM

        return REG_PLATFORM

    @staticmethod
    async def handle_interrupted_choice(update, context):
        """معالج قرار المستخدم"""
        MessageTagger.mark_as_handled(context)

        query = update.callback_query
        await query.answer()

        user_id = query.from_user.id
        choice = query.data

        print(f"\n{'='*80}")
        print(f"🎯 [INTERRUPTED-CHOICE] User {user_id}: {choice}")
        print(f"{'='*80}")

        reg_bucket = bucket(context, "reg")

        if choice == "reg_restart":
            print(f"🔄 [INTERRUPTED-CHOICE] RESTART chosen")

            clear_bucket(context, "reg")

            keyboard = PlatformKeyboard.create_platform_selection_keyboard()
            await query.edit_message_text(
                "🔄 <b>حسناً، لنبدأ من جديد!</b>\n\n"
                + WelcomeMessages.get_start_message(),
                reply_markup=keyboard,
                parse_mode="HTML",
            )

            print(f"➡️ [INTERRUPTED-CHOICE] → REG_PLATFORM")
            print(f"{'='*80}\n")
            from .states import REG_PLATFORM

            return REG_PLATFORM

        elif choice == "reg_continue":
            print(f"✅ [INTERRUPTED-CHOICE] CONTINUE chosen")

            interrupted_step = reg_bucket.get("interrupted_step")
            platform = reg_bucket.get("interrupted_platform")
            whatsapp = reg_bucket.get("interrupted_whatsapp")

            print(f"   📍 Step: {interrupted_step}")
            print(f"   📝 Data: platform={platform}, whatsapp={whatsapp}")

            if not platform:
                print(f"   ⚠️ [EDGE-CASE] Data lost - auto restart")

                await query.edit_message_text(
                    "😔 <b>عذراً، حدث خطأ في استرجاع بياناتك.</b>\n\n🔄 لنبدأ من جديد...",
                    parse_mode="HTML",
                )

                clear_bucket(context, "reg")

                keyboard = PlatformKeyboard.create_platform_selection_keyboard()
                await query.message.reply_text(
                    WelcomeMessages.get_start_message(),
                    reply_markup=keyboard,
                    parse_mode="HTML",
                )

                print(f"➡️ [INTERRUPTED-CHOICE] → REG_PLATFORM (data loss)")
                print(f"{'='*80}\n")
                from .states import REG_PLATFORM

                return REG_PLATFORM

            if interrupted_step == "entering_whatsapp" or not whatsapp:
                print(f"   ➡️ Continuing at: WHATSAPP")

                platform_name = PlatformKeyboard.get_platform_name(platform)
                await query.edit_message_text(
                    f"✅ <b>رائع! لنكمل من حيث توقفنا</b>\n\n"
                    f"🎮 المنصة: {platform_name}\n\n"
                    f"📱 أدخل رقم الواتساب:\n"
                    f"📝 مثال: 01012345678",
                    parse_mode="HTML",
                )

                print(f"➡️ [INTERRUPTED-CHOICE] → REG_WHATSAPP")
                print(f"{'='*80}\n")
                from .states import REG_WHATSAPP

                return REG_WHATSAPP

            elif interrupted_step in ["choosing_payment", "entering_payment_details"]:
                print(f"   ➡️ Continuing at: PAYMENT")

                keyboard = PaymentKeyboard.create_payment_selection_keyboard()
                await query.edit_message_text(
                    f"✅ <b>رائع! لنكمل من حيث توقفنا</b>\n\n"
                    f"📱 الواتساب: {whatsapp}\n\n"
                    f"💳 اختر طريقة الدفع:",
                    reply_markup=keyboard,
                    parse_mode="HTML",
                )

                print(f"➡️ [INTERRUPTED-CHOICE] → REG_PAYMENT")
                print(f"{'='*80}\n")
                from .states import REG_PAYMENT

                return REG_PAYMENT

            else:
                print(f"   ⚠️ [EDGE-CASE] Unexpected step - auto restart")

                clear_bucket(context, "reg")

                keyboard = PlatformKeyboard.create_platform_selection_keyboard()
                await query.edit_message_text(
                    "🔄 <b>لنبدأ من جديد للتأكد من صحة البيانات</b>",
                    reply_markup=keyboard,
                    parse_mode="HTML",
                )

                print(f"➡️ [INTERRUPTED-CHOICE] → REG_PLATFORM (unexpected)")
                print(f"{'='*80}\n")
                from .states import REG_PLATFORM

                return REG_PLATFORM

    @staticmethod
    async def nudge_platform(update, context):
        """معالج التنبيه - حالة اختيار المنصة"""
        MessageTagger.mark_as_handled(context)

        user_id = update.effective_user.id
        text = update.message.text

        print(f"\n{'='*80}")
        print(f"🔔 [NUDGE-PLATFORM] User {user_id} typed: '{text}'")
        print(f"{'='*80}")

        keyboard = PlatformKeyboard.create_platform_selection_keyboard()

        await update.message.reply_text(
            "🎮 <b>من فضلك اختر منصتك من الأزرار أدناه</b>\n\n"
            "⬇️ اضغط على أحد الأزرار:",
            reply_markup=keyboard,
            parse_mode="HTML",
        )

        print(f"   ✅ Nudge sent - staying in REG_PLATFORM")
        print(f"{'='*80}\n")

        from .states import REG_PLATFORM

        return REG_PLATFORM

    @staticmethod
    async def nudge_interrupted(update, context):
        """معالج التنبيه - حالة المقاطعة"""
        MessageTagger.mark_as_handled(context)

        user_id = update.effective_user.id
        text = update.message.text

        print(f"\n{'='*80}")
        print(f"🔔 [NUDGE-INTERRUPTED] User {user_id} typed: '{text}'")
        print(f"{'='*80}")

        reg_bucket = bucket(context, "reg")
        platform = reg_bucket.get("interrupted_platform", "غير محدد")
        whatsapp = reg_bucket.get("interrupted_whatsapp", "لم يُدخل بعد")

        question_text = f"""🤔 <b>من فضلك اختر من الأزرار أدناه:</b>

📋 <b>بياناتك الحالية:</b>
• 🎮 المنصة: {platform}
• 📱 الواتساب: {whatsapp}

<b>❓ تريد المتابعة أم البدء من جديد؟</b>
⬇️ اضغط على أحد الأزرار:"""

        keyboard = [
            [
                InlineKeyboardButton(
                    "✅ متابعة من حيث توقفت", callback_data="reg_continue"
                )
            ],
            [InlineKeyboardButton("🔄 البدء من جديد", callback_data="reg_restart")],
        ]

        await update.message.reply_text(
            question_text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="HTML",
        )

        print(f"   ✅ Nudge sent - staying in REG_INTERRUPTED")
        print(f"{'='*80}\n")

        from .states import REG_INTERRUPTED

        return REG_INTERRUPTED

    @staticmethod
    async def handle_platform_callback(update, context):
        """معالج اختيار المنصة"""
        MessageTagger.mark_as_handled(context)

        query = update.callback_query
        await query.answer()

        user_id = query.from_user.id
        platform = query.data.replace("platform_", "")

        print(f"\n{'='*80}")
        print(f"🎮 [PLATFORM] User {user_id}: {platform}")
        print(f"{'='*80}")

        bucket(context, "reg")["platform"] = platform

        UserOperations.save_user_step(
            user_id, "entering_whatsapp", {"platform": platform}
        )

        platform_name = PlatformKeyboard.get_platform_name(platform)
        await query.edit_message_text(
            WelcomeMessages.get_platform_selected_message(platform_name),
            parse_mode="HTML",
        )

        log_user_action(user_id, f"Selected platform: {platform}")

        print(f"➡️ [PLATFORM] → REG_WHATSAPP")
        print(f"{'='*80}\n")
        from .states import REG_WHATSAPP

        return REG_WHATSAPP

    @staticmethod
    async def handle_whatsapp(update, context):
        """معالج إدخال الواتساب"""
        MessageTagger.mark_as_handled(context)

        user_id = update.effective_user.id
        phone = update.message.text.strip()

        print(f"\n{'='*80}")
        print(f"📱 [WHATSAPP] User {user_id} entered number")
        print(f"{'='*80}")

        validation = PhoneValidator.validate_whatsapp(phone)

        if not validation["valid"]:
            print(f"   ❌ Validation failed: {validation['error']}")
            await update.message.reply_text(
                ErrorMessages.get_phone_validation_error(validation["error"]),
                parse_mode="HTML",
            )
            print(f"   ⏸️ Staying in REG_WHATSAPP")
            print(f"{'='*80}\n")
            from .states import REG_WHATSAPP

            return REG_WHATSAPP

        print(f"   ✅ Validation OK")

        bucket(context, "reg")["whatsapp"] = validation["cleaned"]

        platform = bucket(context, "reg").get(
            "platform"
        ) or UserOperations.get_user_data(user_id).get("platform")
        UserOperations.save_user_step(
            user_id,
            "choosing_payment",
            {"platform": platform, "whatsapp": validation["cleaned"]},
        )

        keyboard = PaymentKeyboard.create_payment_selection_keyboard()
        await update.message.reply_text(
            WelcomeMessages.get_whatsapp_confirmed_message(validation["display"]),
            reply_markup=keyboard,
            parse_mode="HTML",
        )

        log_user_action(user_id, f"WhatsApp: {validation['display']}")

        print(f"➡️ [WHATSAPP] → REG_PAYMENT")
        print(f"{'='*80}\n")
        from .states import REG_PAYMENT

        return REG_PAYMENT

    @staticmethod
    async def handle_payment_callback(update, context):
        """معالج اختيار طريقة الدفع"""
        MessageTagger.mark_as_handled(context)

        query = update.callback_query
        await query.answer()

        user_id = query.from_user.id
        payment_key = query.data.replace("payment_", "")
        payment_name = PaymentKeyboard.get_payment_display_name(payment_key)

        print(f"\n{'='*80}")
        print(f"💳 [PAYMENT-CB] User {user_id}: {payment_name}")
        print(f"{'='*80}")

        bucket(context, "reg")["payment_method"] = payment_key

        user_data = UserOperations.get_user_data(user_id)
        UserOperations.save_user_step(
            user_id,
            "entering_payment_details",
            {
                "platform": user_data["platform"],
                "whatsapp": user_data["whatsapp"],
                "payment_method": payment_key,
            },
        )

        instruction = PaymentValidator.get_payment_instructions(payment_key)
        await query.edit_message_text(
            WelcomeMessages.get_payment_method_selected_message(
                payment_name, instruction
            ),
            parse_mode="HTML",
        )

        log_user_action(user_id, f"Payment: {payment_key}")

        print(f"   ⏸️ Staying in REG_PAYMENT (waiting for details)")
        print(f"{'='*80}\n")
        from .states import REG_PAYMENT

        return REG_PAYMENT

    @staticmethod
    async def handle_payment_details(update, context):
        """معالج إدخال تفاصيل الدفع"""
        MessageTagger.mark_as_handled(context)

        user_id = update.effective_user.id
        details = update.message.text.strip()

        print(f"\n{'='*80}")
        print(f"💰 [PAYMENT-TXT] User {user_id} entered details")
        print(f"{'='*80}")

        payment_method = bucket(context, "reg").get("payment_method")
        if not payment_method:
            print(f"   ⚠️ [PROTECTION] No payment method selected yet!")

            keyboard = PaymentKeyboard.create_payment_selection_keyboard()
            await update.message.reply_text(
                "⚠️ <b>يجب اختيار طريقة الدفع أولاً!</b>\n\n"
                "💳 اختر طريقة الدفع من الأزرار:",
                reply_markup=keyboard,
                parse_mode="HTML",
            )

            print(f"   ⏸️ Staying in REG_PAYMENT")
            print(f"{'='*80}\n")
            from .states import REG_PAYMENT

            return REG_PAYMENT

        user_data = UserOperations.get_user_data(user_id)
        validation = PaymentValidator.validate_payment_details(
            user_data["payment_method"], details
        )

        if not validation["valid"]:
            print(f"   ❌ Validation failed: {validation['error']}")
            await update.message.reply_text(
                ErrorMessages.get_payment_validation_error(
                    user_data["payment_method"], validation["error"]
                ),
                parse_mode="HTML",
            )
            print(f"   ⏸️ Staying in REG_PAYMENT")
            print(f"{'='*80}\n")
            from .states import REG_PAYMENT

            return REG_PAYMENT

        print(f"   ✅ Validation OK - completing registration")

        UserOperations.save_user_step(
            user_id,
            "completed",
            {
                "platform": user_data["platform"],
                "whatsapp": user_data["whatsapp"],
                "payment_method": user_data["payment_method"],
                "payment_details": validation["cleaned"],
            },
        )

        clear_bucket(context, "reg")

        payment_name = PaymentKeyboard.get_payment_display_name(
            user_data["payment_method"]
        )

        confirmation = ConfirmationMessages.create_payment_confirmation(
            user_data["payment_method"], validation, payment_name
        )
        await update.message.reply_text(confirmation)

        user_info = {
            "id": user_id,
            "username": update.effective_user.username or "غير متوفر",
        }

        final_summary = ConfirmationMessages.create_final_summary(
            user_data, payment_name, validation, user_info
        )
        await update.message.reply_text(final_summary, parse_mode="HTML")

        StatisticsOperations.update_daily_metric("completed_registrations")
        log_user_action(user_id, "Registration completed")

        print(f"🎉 [PAYMENT-TXT] Registration completed!")
        print(f"➡️ [PAYMENT-TXT] Ending conversation")
        print(f"{'='*80}\n")
        return ConversationHandler.END

    @staticmethod
    async def cancel_registration(update, context):
        """إلغاء التسجيل"""
        MessageTagger.mark_as_handled(context)

        user_id = update.effective_user.id

        print(f"\n{'='*80}")
        print(f"❌ [CANCEL] User {user_id}")
        print(f"{'='*80}\n")

        clear_bucket(context, "reg")

        await update.message.reply_text(
            "❌ تم إلغاء التسجيل\n\n🔹 /start للبدء من جديد"
        )
        return ConversationHandler.END

    @staticmethod
    async def _show_main_menu(update, user_data):
        """عرض القائمة الرئيسية"""
        user_id = update.effective_user.id
        username = update.effective_user.username or "Unknown"
        platform = user_data.get("platform", "غير محدد")
        whatsapp = user_data.get("whatsapp", "غير محدد")

        main_menu_text = f"""✅ <b>أهلاً وسهلاً بعودتك!</b>

👤 <b>المستخدم:</b> @{username}
🎮 <b>المنصة:</b> {platform}
📱 <b>الواتساب:</b> <code>{whatsapp}</code>

<b>🏠 القائمة الرئيسية:</b>

🔹 <code>/sell</code> - بيع الكوينز
🔹 <code>/profile</code> - عرض الملف الشخصي
🔹 <code>/help</code> - المساعدة والدعم

<b>🎯 خدماتنا:</b>
• شراء وبيع العملات
• تجارة اللاعبين
• خدمات التطوير
• دعم فني متخصص

💬 <b>للحصول على الخدمات تواصل مع الإدارة</b>"""

        await update.message.reply_text(main_menu_text, parse_mode="HTML")
        log_user_action(user_id, "Main menu", f"Platform: {platform}")


--- FC26_sale_coins_Bot/handlers/registration/helpers.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║           🛠️ REGISTRATION HELPERS - دوال مساعدة للتسجيل                ║
# ╚══════════════════════════════════════════════════════════════════════════╝

"""دوال مساعدة لخدمة التسجيل"""

from utils.logger import log_user_action


async def show_main_menu(update, user_data):
    """عرض القائمة الرئيسية"""
    user_id = update.effective_user.id
    username = update.effective_user.username or "Unknown"
    platform = user_data.get("platform", "غير محدد")
    whatsapp = user_data.get("whatsapp", "غير محدد")

    main_menu_text = f"""✅ <b>أهلاً وسهلاً بعودتك!</b>

👤 <b>المستخدم:</b> @{username}
🎮 <b>المنصة:</b> {platform}
📱 <b>الواتساب:</b> <code>{whatsapp}</code>

<b>🏠 القائمة الرئيسية:</b>

🔹 <code>/sell</code> - بيع الكوينز
🔹 <code>/profile</code> - عرض الملف الشخصي
🔹 <code>/help</code> - المساعدة والدعم

<b>🎯 خدماتنا:</b>
• شراء وبيع العملات
• تجارة اللاعبين
• خدمات التطوير
• دعم فني متخصص

💬 <b>للحصول على الخدمات تواصل مع الإدارة</b>"""

    await update.message.reply_text(main_menu_text, parse_mode="HTML")
    log_user_action(user_id, "Main menu", f"Platform: {platform}")


--- FC26_sale_coins_Bot/handlers/registration/states.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║                    📊 REGISTRATION STATES                                ║
# ║                       حالات التسجيل                                     ║
# ╚══════════════════════════════════════════════════════════════════════════╝

"""حالات محادثة التسجيل"""

REG_PLATFORM = 0
REG_WHATSAPP = 1
REG_PAYMENT = 2
REG_INTERRUPTED = 3


--- FC26_sale_coins_Bot/handlers/start_handler.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              🚀 FC26 START HANDLER - معالج البدء                        ║
# ║                        Start Command Handler                             ║
# ╚══════════════════════════════════════════════════════════════════════════╝

from telegram import Update
from telegram.ext import ContextTypes
from utils.logger import log_user_action, log_registration_step, logger
from utils.locks import user_lock_manager, is_rate_limited
from database.operations import UserOperations
from messages.welcome_messages import WelcomeMessages
from messages.error_messages import ErrorMessages
from keyboards.platform_keyboard import PlatformKeyboard
from handlers.continue_handler import handle_continue_registration

class StartHandler:
    """Handle /start command and user registration initialization"""
    
    @staticmethod
    async def handle_start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /start command"""
        user_id = update.effective_user.id
        username = update.effective_user.username or "Unknown"
        
        # Rate limiting check
        if is_rate_limited(user_id):
            await update.message.reply_text(ErrorMessages.get_rate_limit_error(), parse_mode="HTML")
            return
        
        log_user_action(user_id, "Started bot interaction", f"Username: @{username}")
        
        try:
            async with user_lock_manager.acquire_user_lock(user_id, "start_command"):
                await StartHandler._process_start_command(update, context)
                
        except Exception as e:
            logger.error(f"❌ Error in start handler for user {user_id}: {e}")
            await update.message.reply_text(ErrorMessages.get_general_error(), parse_mode="HTML")
    
    @staticmethod
    async def _process_start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Process start command with user checks"""
        user_id = update.effective_user.id
        
        # Check if user exists and their current step
        user_data = UserOperations.get_user_data(user_id)
        
        if user_data and user_data["registration_step"] != "start":
            # User exists and has started registration - continue from where they left
            log_registration_step(user_id, f"Continue from {user_data['registration_step']}")
            await handle_continue_registration(update, context, user_data)
            return
        
        # New user or user at start - show welcome and platform selection
        await StartHandler._show_welcome_and_platforms(update, context)
    
    @staticmethod
    async def _show_welcome_and_platforms(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Show welcome message and platform selection"""
        user_id = update.effective_user.id
        
        try:
            # Create platform selection keyboard
            keyboard = PlatformKeyboard.create_platform_selection_keyboard()
            
            # Get welcome message
            welcome_text = WelcomeMessages.get_start_message()
            
            # Send message
            message = await update.message.reply_text(
                welcome_text,
                reply_markup=keyboard,
                parse_mode="HTML"
            )
            
            # Save user step
            UserOperations.save_user_step(user_id, "choosing_platform")
            
            log_registration_step(user_id, "choosing_platform", True)
            log_user_action(user_id, "Shown platform selection", f"Message ID: {message.message_id}")
            
        except Exception as e:
            logger.error(f"❌ Error showing welcome to user {user_id}: {e}")
            await update.message.reply_text(ErrorMessages.get_general_error(), parse_mode="HTML")
    
    @staticmethod
    async def handle_help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /help command"""
        user_id = update.effective_user.id
        
        if is_rate_limited(user_id):
            await update.message.reply_text(ErrorMessages.get_rate_limit_error(), parse_mode="HTML")
            return
        
        log_user_action(user_id, "Requested help")
        
        try:
            help_text = WelcomeMessages.get_help_message()
            await update.message.reply_text(help_text, parse_mode="HTML")
            
        except Exception as e:
            logger.error(f"❌ Error in help handler for user {user_id}: {e}")
            await update.message.reply_text(ErrorMessages.get_general_error(), parse_mode="HTML")
    
    @staticmethod
    async def handle_about_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /about command"""
        user_id = update.effective_user.id
        
        if is_rate_limited(user_id):
            await update.message.reply_text(ErrorMessages.get_rate_limit_error(), parse_mode="HTML")
            return
        
        log_user_action(user_id, "Requested about info")
        
        try:
            about_text = WelcomeMessages.get_about_message()
            await update.message.reply_text(about_text, parse_mode="HTML")
            
        except Exception as e:
            logger.error(f"❌ Error in about handler for user {user_id}: {e}")
            await update.message.reply_text(ErrorMessages.get_general_error(), parse_mode="HTML")

--- FC26_sale_coins_Bot/keyboards/__init__.py ---



--- FC26_sale_coins_Bot/keyboards/payment_keyboard.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              💳 FC26 PAYMENT KEYBOARDS - لوحات مفاتيح الدفع             ║
# ║                       Payment Keyboards                                 ║
# ╚══════════════════════════════════════════════════════════════════════════╝

from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from typing import List, Dict
from config import PAYMENT_METHODS

class PaymentKeyboard:
    """Payment method selection keyboards"""
    
    @staticmethod
    def create_payment_selection_keyboard() -> InlineKeyboardMarkup:
        """Create payment method selection keyboard"""
        keyboard = []
        
        for payment_key, payment_name in PAYMENT_METHODS.items():
            keyboard.append([
                InlineKeyboardButton(
                    payment_name,
                    callback_data=f"payment_{payment_key}"
                )
            ])
        
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def create_payment_confirmation_keyboard(payment_key: str) -> InlineKeyboardMarkup:
        """Create payment method confirmation keyboard"""
        keyboard = [
            [
                InlineKeyboardButton("✅ تأكيد الطريقة", callback_data=f"confirm_payment_{payment_key}"),
                InlineKeyboardButton("🔄 تغيير", callback_data="change_payment")
            ],
            [
                InlineKeyboardButton("ℹ️ معلومات الطريقة", callback_data=f"payment_info_{payment_key}")
            ],
            [
                InlineKeyboardButton("🔙 العودة للمنصات", callback_data="back_to_platforms")
            ]
        ]
        
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def create_payment_help_keyboard() -> InlineKeyboardMarkup:
        """Create payment help keyboard"""
        keyboard = [
            [
                InlineKeyboardButton("📱 أرقام الهاتف", callback_data="phone_help"),
                InlineKeyboardButton("💳 الكروت", callback_data="card_help")
            ],
            [
                InlineKeyboardButton("🔗 إنستاباي", callback_data="instapay_help"),
                InlineKeyboardButton("🏦 المحافظ", callback_data="wallet_help")
            ],
            [
                InlineKeyboardButton("🔙 العودة", callback_data="payment_selection")
            ]
        ]
        
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def create_mobile_networks_keyboard() -> InlineKeyboardMarkup:
        """Create mobile networks information keyboard"""
        keyboard = [
            [
                InlineKeyboardButton("⭕️ فودافون (010)", callback_data="network_vodafone"),
                InlineKeyboardButton("🟢 اتصالات (011)", callback_data="network_etisalat")
            ],
            [
                InlineKeyboardButton("🍊 أورانج (012)", callback_data="network_orange"),
                InlineKeyboardButton("🟣 وي (015)", callback_data="network_we")
            ],
            [
                InlineKeyboardButton("🔙 العودة", callback_data="payment_help")
            ]
        ]
        
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def create_payment_examples_keyboard(payment_key: str) -> InlineKeyboardMarkup:
        """Create keyboard with payment examples"""
        keyboard = [
            [
                InlineKeyboardButton("📝 أمثلة", callback_data=f"examples_{payment_key}"),
                InlineKeyboardButton("⚠️ أخطاء شائعة", callback_data=f"common_errors_{payment_key}")
            ],
            [
                InlineKeyboardButton("✅ فهمت، أدخل البيانات", callback_data=f"understood_{payment_key}"),
            ],
            [
                InlineKeyboardButton("🔙 تغيير الطريقة", callback_data="payment_selection")
            ]
        ]
        
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def create_validation_retry_keyboard(payment_key: str) -> InlineKeyboardMarkup:
        """Create keyboard for validation retry options"""
        keyboard = [
            [
                InlineKeyboardButton("🔄 إعادة المحاولة", callback_data=f"retry_{payment_key}"),
                InlineKeyboardButton("❓ مساعدة", callback_data=f"help_{payment_key}")
            ],
            [
                InlineKeyboardButton("🔄 تغيير طريقة الدفع", callback_data="payment_selection")
            ],
            [
                InlineKeyboardButton("🏠 القائمة الرئيسية", callback_data="main_menu")
            ]
        ]
        
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def create_skip_optional_keyboard(step: str) -> InlineKeyboardMarkup:
        """Create keyboard to skip optional steps"""
        keyboard = [
            [
                InlineKeyboardButton("⏭️ تخطي هذه الخطوة", callback_data=f"skip_{step}"),
                InlineKeyboardButton("✅ متابعة", callback_data=f"continue_{step}")
            ]
        ]
        
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_payment_emoji(payment_key: str) -> str:
        """Get emoji for payment method"""
        emojis = {
            'vodafone_cash': '⭕️',
            'etisalat_cash': '🟢',
            'orange_cash': '🍊',
            'we_cash': '🟣',
            'bank_wallet': '🏦',
            'telda': '💳',
            'instapay': '🔗'
        }
        return emojis.get(payment_key, '💰')
    
    @staticmethod
    def get_payment_display_name(payment_key: str) -> str:
        """Get display name for payment method"""
        return PAYMENT_METHODS.get(payment_key, "طريقة غير معروفة")
    
    @staticmethod
    def create_final_confirmation_keyboard() -> InlineKeyboardMarkup:
        """Create final confirmation keyboard after all data is entered"""
        keyboard = [
            [
                InlineKeyboardButton("✅ تأكيد جميع البيانات", callback_data="final_confirm"),
                InlineKeyboardButton("✏️ تعديل البيانات", callback_data="edit_data")
            ],
            [
                InlineKeyboardButton("🔄 بدء من جديد", callback_data="restart_registration")
            ]
        ]
        
        return InlineKeyboardMarkup(keyboard)

--- FC26_sale_coins_Bot/keyboards/platform_keyboard.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              🎮 FC26 PLATFORM KEYBOARDS - لوحات مفاتيح المنصات          ║
# ║                       Platform Keyboards                                ║
# ╚══════════════════════════════════════════════════════════════════════════╝

from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from typing import List, Dict
from config import GAMING_PLATFORMS

class PlatformKeyboard:
    """Gaming platform selection keyboards"""
    
    @staticmethod
    def create_platform_selection_keyboard() -> InlineKeyboardMarkup:
        """Create platform selection keyboard"""
        keyboard = []
        
        for platform_key, platform_info in GAMING_PLATFORMS.items():
            keyboard.append([
                InlineKeyboardButton(
                    platform_info["name"],
                    callback_data=f"platform_{platform_key}"
                )
            ])
        
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def create_platform_confirmation_keyboard(platform_key: str) -> InlineKeyboardMarkup:
        """Create platform confirmation keyboard"""
        keyboard = [
            [
                InlineKeyboardButton("✅ تأكيد", callback_data=f"confirm_platform_{platform_key}"),
                InlineKeyboardButton("🔄 تغيير", callback_data="change_platform")
            ],
            [
                InlineKeyboardButton("🏠 القائمة الرئيسية", callback_data="main_menu")
            ]
        ]
        
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def create_platform_info_keyboard(platform_key: str) -> InlineKeyboardMarkup:
        """Create keyboard with platform information options"""
        keyboard = [
            [
                InlineKeyboardButton("ℹ️ معلومات المنصة", callback_data=f"platform_info_{platform_key}")
            ],
            [
                InlineKeyboardButton("✅ اختيار هذه المنصة", callback_data=f"platform_{platform_key}"),
                InlineKeyboardButton("🔙 العودة", callback_data="platform_selection")
            ]
        ]
        
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def create_navigation_keyboard() -> InlineKeyboardMarkup:
        """Create navigation keyboard for platform selection"""
        keyboard = [
            [
                InlineKeyboardButton("🔄 إعادة التحديد", callback_data="platform_selection")
            ],
            [
                InlineKeyboardButton("❓ مساعدة", callback_data="platform_help"),
                InlineKeyboardButton("🏠 الرئيسية", callback_data="main_menu")
            ]
        ]
        
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_platform_emoji(platform_key: str) -> str:
        """Get emoji for platform"""
        return GAMING_PLATFORMS.get(platform_key, {}).get("emoji", "🎮")
    
    @staticmethod
    def get_platform_name(platform_key: str) -> str:
        """Get display name for platform"""
        return GAMING_PLATFORMS.get(platform_key, {}).get("name", "منصة غير معروفة")

--- FC26_sale_coins_Bot/main.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              🎮 FC26 GAMING BOT - MAIN                                   ║
# ║              بوت FC26 - الملف الرئيسي (منسق فقط) 🔥                    ║
# ╚══════════════════════════════════════════════════════════════════════════╝

import asyncio
import platform as sys_platform

from core.bot_app import FC26BotApp
from database.models import DatabaseModels
from handlers.commands.basic_commands import get_command_handlers
from handlers.recovery.global_router import get_recovery_handler
from handlers.registration.conversation import get_registration_handler
from services.admin.admin_conversation_handler import AdminConversation
from services.sell_coins.sell_conversation_handler import SellCoinsConversation
from utils.backup_job import register_backup_job
from utils.logger import fc26_logger
from utils.session_monitor import register_monitoring


def setup_handlers(app):
    """
    🎯 تسجيل جميع الـ handlers
    """

    print("\n" + "=" * 80)
    print("🎯 [SYSTEM] REGISTERING HANDLERS")
    print("=" * 80)

    # 1️⃣ REGISTRATION
    print("\n🧠 [REGISTRATION] Registering...")
    app.add_handler(get_registration_handler())
    print("   ✅ Done")

    # 2️⃣ SELL SERVICE
    print("\n🔧 [SELL] Registering...")
    try:
        app.add_handler(SellCoinsConversation.get_conversation_handler())
        print("   ✅ Done")
    except Exception as e:
        print(f"   ❌ Failed: {e}")

    # 3️⃣ ADMIN SERVICE
    print("\n🔧 [ADMIN] Registering...")
    try:
        app.add_handler(AdminConversation.get_conversation_handler())
        print("   ✅ Done")
    except Exception as e:
        print(f"   ❌ Failed: {e}")

    # 4️⃣ SIMPLE COMMANDS
    print("\n🔧 [COMMANDS] Registering...")
    for handler in get_command_handlers():
        app.add_handler(handler)
    print("   ✅ Done")

    # 5️⃣ GLOBAL RECOVERY
    print("\n🛡️ [RECOVERY] Registering...")
    app.add_handler(get_recovery_handler(), group=99)
    print("   ✅ Done")

    print("\n" + "=" * 80)
    print("✅ [SYSTEM] ALL HANDLERS REGISTERED")
    print("=" * 80 + "\n")


def main():
    """🚀 نقطة البداية الرئيسية"""

    # Windows compatibility
    if sys_platform.system() == "Windows":
        try:
            asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())
        except:
            pass

    # تهيئة قاعدة البيانات
    fc26_logger.get_logger().info("💾 Initializing database...")
    if not DatabaseModels.create_all_tables():
        print("❌ Database initialization failed!")
        return

    # إنشاء تطبيق البوت (مع Persistence)
    bot_app = FC26BotApp()
    app = bot_app.create_application()

    # تسجيل الـ handlers
    setup_handlers(app)

    # 🔥 تسجيل وظائف الصيانة (النسخ الاحتياطي والمراقبة)
    register_backup_job(app)
    register_monitoring(app)

    # طباعة البانر
    fc26_logger.log_bot_start()
    print(
        """
╔══════════════════════════════════════════════════════════════════════════╗
║       🎮 FC26 GAMING BOT - COMPLETE SYSTEM 🎮                            ║
║         بوت FC26 - النظام الكامل مع Persistence 🔥                      ║
║                                                                          ║
║  🔥 FEATURES:                                                           ║
║  ✅ Modular architecture - هيكل معياري                                 ║
║  ✅ Session persistence - جلسات دائمة                                  ║
║  ✅ Session buckets - عزل البيانات                                    ║
║  ✅ Auto backup - نسخ احتياطي تلقائي                                   ║
║  ✅ Health monitoring - مراقبة الصحة                                   ║
║  ✅ Message tagging - نظام الوسم                                       ║
║  ✅ Zero duplicates - بدون تكرار                                       ║
║  ✅ Production ready - جاهز للإنتاج                                    ║
╚══════════════════════════════════════════════════════════════════════════╝
    """
    )

    # تشغيل البوت
    try:
        app.run_polling(drop_pending_updates=True)
    except KeyboardInterrupt:
        print("🔴 Bot stopped by user")
    except Exception as e:
        print(f"❌ Fatal error: {e}")
        import traceback

        traceback.print_exc()
    finally:
        fc26_logger.log_bot_stop()


if __name__ == "__main__":
    main()


--- FC26_sale_coins_Bot/messages/__init__.py ---



--- FC26_sale_coins_Bot/messages/confirmation_msgs.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              🎉 FC26 CONFIRMATION MESSAGES - رسائل التأكيد              ║
# ║                      Confirmation Messages                               ║
# ╚══════════════════════════════════════════════════════════════════════════╝

from typing import Any, Dict
from config import GAMING_PLATFORMS  # إضافة هذا الimport


class ConfirmationMessages:
    """Payment confirmation and success messages"""

    @staticmethod
    def create_payment_confirmation(
        payment_method: str, validation: Dict, payment_name: str
    ) -> str:
        """Create beautiful payment confirmation message"""

        # Mobile wallets confirmation
        if payment_method in [
            "vodafone_cash",
            "etisalat_cash",
            "orange_cash",
            "we_cash",
            "bank_wallet",
        ]:
            return f"""✅ تم حفظ {payment_name}!

📱 الرقم: {validation['display']}

━━━━━━━━━━━━━━━━"""

        # Telda card confirmation (بدون تشفير)
        elif payment_method == "telda":
            return f"""✅ تم حفظ كارت تيلدا!

💳 رقم الكارت: {validation['display']}

━━━━━━━━━━━━━━━━"""

        # InstaPay confirmation
        elif payment_method == "instapay":
            return f"""✅ تم حفظ رابط إنستاباي!

🔗 الرابط: {validation['display']}

━━━━━━━━━━━━━━━━"""

        # Fallback for unknown methods
        else:
            return f"""✅ تم حفظ {payment_name}!

💰 التفاصيل: {validation.get('display', 'غير محدد')}

━━━━━━━━━━━━━━━━"""

    @staticmethod
    def create_whatsapp_confirmation(validation: Dict) -> str:
        """Create WhatsApp confirmation message"""
        return f"""✅ تم حفظ رقم الواتساب!

📱 الرقم: {validation['display']}

━━━━━━━━━━━━━━━━"""

    @staticmethod
    def create_final_summary(
        user_data: Dict, payment_name: str, validation: Dict, user_info: Dict
    ) -> str:
        """Create enhanced final registration summary"""

        # الحصول على اسم المنصة من الconfig
        platform_key = user_data.get('platform', '')
        platform_name = GAMING_PLATFORMS.get(platform_key, {}).get('name', 'غير محدد')

        # Format payment details based on method
        if user_data["payment_method"] == "telda":
            # For Telda, show full card number (غير مشفر)
            payment_details_line = f"• رقم الكارت: {validation['display']}"

        elif user_data["payment_method"] == "instapay":
            # For InstaPay, show the clean URL
            payment_details_line = f"• الرابط: {validation['display']}"

        else:
            # For mobile wallets, show the phone number
            payment_details_line = f"• الرقم: {validation['display']}"

        return f"""
✅ تم تحديث بياناتك بنجاح!

📊 ملخص البيانات المحدثة:
━━━━━━━━━━━━━━━━
🎮 المنصة: {platform_name}
📱 واتساب: {user_data['whatsapp']}
💳 طريقة الدفع: {payment_name}
💰 بيانات الدفع:
{payment_details_line}
━━━━━━━━━━━━━━━━

👤 اسم المستخدم: @{user_info.get('username', 'غير متوفر')}
🆔 معرف التليجرام: {user_info['id']}

✨ تم تحديث ملفك الشخصي بنجاح!"""

    @staticmethod
    def create_registration_completed_message(
        user_data: Dict, display_format: Dict
    ) -> str:
        """Create message for already completed registration"""

        # الحصول على اسم المنصة من الconfig
        platform_key = user_data.get('platform', '')
        platform_name = GAMING_PLATFORMS.get(platform_key, {}).get('name', 'غير محدد')

        return f"""✅ <b>تسجيلك مكتمل بالفعل!</b>

📋 <b>ملخص بياناتك:</b>

🎮 <b>المنصة:</b> {platform_name}
📱 <b>الواتساب:</b> {display_format.get('whatsapp_display', user_data.get('whatsapp', 'غير محدد'))}
💳 <b>الدفع:</b> {user_data.get('payment_name', 'غير محدد')}
💰 <b>التفاصيل:</b> {display_format.get('payment_display', 'غير محدد')}

🚀 <b>مرحباً بك في عائلة FC26!</b>"""

    @staticmethod
    def create_data_updated_message() -> str:
        """Create data updated confirmation"""
        return """✅ <b>تم تحديث بياناتك بنجاح!</b>

🔄 <b>ماذا حدث:</b>
• تم حفظ جميع المعلومات
• تم تحديث ملفك الشخصي
• أصبحت جاهزاً لاستخدام الخدمات

🎮 <b>الخطوات التالية:</b>
• يمكنك الآن استخدام جميع خدمات FC26
• تواصل معنا للحصول على المساعدة
• راجع ملفك الشخصي للتأكد من البيانات

🚀 <b>مرحباً بك في FC26!</b>"""

    @staticmethod
    def create_step_completed_message(step_name: str, next_step: str = None) -> str:
        """Create step completion message"""
        base_message = f"✅ <b>تم إكمال: {step_name}</b>\n\n"

        if next_step:
            base_message += f"➡️ <b>الخطوة التالية:</b> {next_step}\n\n"

        base_message += "🎯 <b>أنت تتقدم بشكل ممتاز!</b>"

        return base_message

    @staticmethod
    def create_profile_summary(user_data: Dict, formatted_data: Dict = None) -> str:
        """Create complete profile summary"""

        formatted = formatted_data or {}
        
        # الحصول على اسم المنصة من الconfig
        platform_key = user_data.get('platform', '')
        platform_name = GAMING_PLATFORMS.get(platform_key, {}).get('name', 'غير محدد')

        return f"""👤 <b>ملفك الشخصي في FC26</b>

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
<b>📋 البيانات الأساسية:</b>

🎮 <b>المنصة:</b> {platform_name}
📱 <b>الواتساب:</b> {formatted.get('whatsapp_display', user_data.get('whatsapp', 'غير محدد'))}
💳 <b>طريقة الدفع:</b> {user_data.get('payment_name', 'غير محدد')}
💰 <b>بيانات الدفع:</b> {formatted.get('payment_display', 'غير محدد')}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
<b>⏰ معلومات التسجيل:</b>

📅 <b>تاريخ التسجيل:</b> {user_data.get('created_at', 'غير محدد')}
🔄 <b>آخر تحديث:</b> {user_data.get('updated_at', 'غير محدد')}
✅ <b>حالة التسجيل:</b> مكتمل

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎮 <b>مرحباً بك في عائلة FC26!</b>"""

    @staticmethod
    def create_success_animation() -> str:
        """Create animated success message"""
        return """🎉✨🎉✨🎉✨🎉✨🎉

      🏆 <b>نجح التسجيل!</b> 🏆

      🎮 FC26 Gaming Community 🎮

🎉✨🎉✨🎉✨🎉✨🎉

✅ <b>أهلاً بك في الفريق!</b>"""


--- FC26_sale_coins_Bot/messages/error_messages.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              ❌ FC26 ERROR MESSAGES - رسائل الأخطاء                     ║
# ║                         Error Messages                                   ║
# ╚══════════════════════════════════════════════════════════════════════════╝

from typing import Dict, Optional

class ErrorMessages:
    """Error and warning messages for the bot"""
    
    @staticmethod
    def get_general_error() -> str:
        """General error message"""
        return "❌ حدث خطأ، حاول مرة أخرى"
    
    @staticmethod
    def get_database_error() -> str:
        """Database error message"""
        return "❌ خطأ في قاعدة البيانات، حاول مرة أخرى"
    
    @staticmethod
    def get_validation_error(details: str = None) -> str:
        """Validation error with optional details"""
        base_message = "❌ البيانات المدخلة غير صحيحة"
        if details:
            return f"{base_message}\n\n📋 <b>التفاصيل:</b> {details}"
        return base_message
    
    @staticmethod
    def get_invalid_platform_error() -> str:
        """Invalid platform error"""
        return "❌ منصة غير صحيحة"
    
    @staticmethod
    def get_invalid_payment_error() -> str:
        """Invalid payment method error"""
        return "❌ طريقة دفع غير صحيحة"
    
    @staticmethod
    def get_start_required_error() -> str:
        """Start command required error"""
        return "🚀 اكتب /start للبدء!"
    
    @staticmethod
    def get_restart_required_error() -> str:
        """Restart required error"""
        return "🚀 اكتب /start للبدء من جديد!"
    
    @staticmethod
    def get_phone_validation_error(error_details: str = None) -> str:
        """Phone number validation error with tips"""
        base_error = error_details or "❌ رقم الهاتف غير صحيح"
        
        return f"""{base_error}

💡 <b>نصائح:</b>
• تأكد من البدء بـ 010, 011, 012, أو 015
• أدخل 11 رقماً بالضبط
• لا تضع كود الدولة (+20)

🔹 <b>أمثلة صحيحة:</b>
• 01012345678
• 01112345678
• 01212345678
• 01512345678"""
    
    @staticmethod
    def get_payment_validation_error(payment_method: str, error_details: str = None) -> str:
        """Payment validation error with method-specific tips"""
        base_error = error_details or "❌ بيانات الدفع غير صحيحة"
        
        tips = {
            'vodafone_cash': "💡 <b>فودافون كاش:</b> رقم 11 خانة يبدأ بـ 010",
            'etisalat_cash': "💡 <b>اتصالات كاش:</b> رقم 11 خانة يبدأ بـ 011", 
            'orange_cash': "💡 <b>أورانج كاش:</b> رقم 11 خانة يبدأ بـ 012",
            'we_cash': "💡 <b>وي كاش:</b> رقم 11 خانة يبدأ بـ 015",
            'bank_wallet': "💡 <b>محفظة بنكية:</b> رقم 11 خانة لأي شبكة",
            'telda': "💡 <b>تيلدا:</b> 16 رقماً بدون مسافات أو شرطات\n<b>مثال:</b> 1234567890123456",
            'instapay': "💡 <b>إنستاباي:</b> رابط كامل\n<b>مثال:</b> https://instapay.com.eg/abc123"
        }
        
        tip = tips.get(payment_method, "💡 تحقق من صحة البيانات المدخلة")
        
        return f"""{base_error}

{tip}"""
    
    @staticmethod
    def get_url_validation_error(error_details: str = None) -> str:
        """URL validation error for InstaPay"""
        base_error = error_details or "❌ رابط إنستاباي غير صحيح"
        
        return f"""{base_error}

💡 <b>نصائح لرابط إنستاباي:</b>
• يجب أن يحتوي على instapay.com.eg أو ipn.eg
• انسخ الرابط كاملاً من التطبيق
• تأكد من صحة الرابط

🔹 <b>مثال صحيح:</b>
https://instapay.com.eg/abc123"""
    
    @staticmethod
    def get_rate_limit_error() -> str:
        """Rate limiting error"""
        return """⏳ <b>تم تجاوز الحد المسموح</b>

🔹 <b>الرجاء الانتظار قليلاً ثم المحاولة مرة أخرى</b>
🔹 <b>هذا للحماية من الاستخدام المفرط</b>

⏰ <b>حاول مرة أخرى خلال دقيقة</b>"""
    
    @staticmethod
    def get_maintenance_error() -> str:
        """Maintenance mode error"""
        return """🔧 <b>البوت تحت الصيانة</b>

⏳ <b>نعتذر للإزعاج، نحن نعمل على تحسين الخدمة</b>

🔄 <b>سيعود البوت للعمل قريباً</b>
📞 <b>للضرورة القصوى، تواصل مع الدعم الفني</b>"""
    
    @staticmethod
    def get_user_not_found_error() -> str:
        """User not found error"""
        return """❌ <b>لم يتم العثور على بياناتك</b>

🚀 <b>اكتب /start لبدء التسجيل من جديد</b>"""
    
    @staticmethod
    def get_session_expired_error() -> str:
        """Session expired error"""
        return """⏰ <b>انتهت صلاحية الجلسة</b>

🔄 <b>الرجاء بدء التسجيل من جديد</b>
🚀 <b>اكتب /start للمتابعة</b>"""
    
    @staticmethod
    def get_security_error() -> str:
        """Security violation error"""
        return """🛡️ <b>تم اكتشاف نشاط مشبوه</b>

⚠️ <b>تم حظر العملية لأسباب أمنية</b>
📞 <b>تواصل مع الدعم الفني إذا كان هذا خطأ</b>"""
    
    @staticmethod
    def get_network_error() -> str:
        """Network/connection error"""
        return """🌐 <b>مشكلة في الاتصال</b>

🔄 <b>الرجاء المحاولة مرة أخرى</b>
📡 <b>تأكد من جودة الاتصال بالإنترنت</b>"""
    
    @staticmethod
    def get_file_error() -> str:
        """File operation error"""
        return """📁 <b>خطأ في العملية</b>

❌ <b>لم يتم حفظ البيانات بنجاح</b>
🔄 <b>الرجاء المحاولة مرة أخرى</b>"""
    
    @staticmethod
    def format_error_with_code(error_code: str, message: str) -> str:
        """Format error message with error code"""
        return f"""❌ <b>خطأ #{error_code}</b>

{message}

🔍 <b>كود الخطأ:</b> {error_code}
📞 <b>اذكر هذا الكود عند التواصل مع الدعم</b>"""
    
    @staticmethod
    def get_custom_error(title: str, message: str, suggestions: list = None) -> str:
        """Create custom error message"""
        error_msg = f"""❌ <b>{title}</b>

{message}"""
        
        if suggestions:
            error_msg += "\n\n💡 <b>اقتراحات:</b>"
            for suggestion in suggestions:
                error_msg += f"\n• {suggestion}"
        
        return error_msg

--- FC26_sale_coins_Bot/messages/summary_messages.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              📊 FC26 SUMMARY MESSAGES - رسائل الملخصات                 ║
# ║                        Summary Messages                                  ║
# ╚══════════════════════════════════════════════════════════════════════════╝

from typing import Dict, List, Any
from datetime import datetime

class SummaryMessages:
    """Summary and informational messages"""
    
    @staticmethod
    def create_user_profile_summary(user_data: Dict, formatted_data: Dict = None) -> str:
        """Create complete user profile summary"""
        
        formatted = formatted_data or {}
        
        # Process platform display
        platform = user_data.get('platform', 'غير محدد')
        platform_display = SummaryMessages._get_platform_display_name(platform)
        
        # Process payment display
        payment_method = user_data.get('payment_method', 'غير محدد')
        payment_display = SummaryMessages._get_payment_display_name(payment_method)
        
        # Process payment details display
        payment_details = user_data.get('payment_details', 'غير محدد')
        payment_details_display = formatted.get('payment_display', payment_details)
        
        return f"""👤 <b>ملفك الشخصي - FC26</b>

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
<b>📋 البيانات الأساسية</b>

🎮 <b>المنصة:</b> {platform_display}
📱 <b>رقم الواتساب:</b> {formatted.get('whatsapp_display', user_data.get('whatsapp', 'غير محدد'))}
💳 <b>طريقة الدفع:</b> {payment_display}
💰 <b>بيانات الدفع:</b> {payment_details_display}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
<b>📊 معلومات الحساب</b>

✅ <b>حالة التسجيل:</b> مكتمل
📅 <b>تاريخ التسجيل:</b> {user_data.get('created_at', 'غير محدد')}
🔄 <b>آخر تحديث:</b> {user_data.get('updated_at', 'غير محدد')}
🆔 <b>معرف المستخدم:</b> {user_data.get('telegram_id', 'غير محدد')}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎮 <b>مرحباً بك في مجتمع FC26!</b>"""
    
    @staticmethod
    def _get_platform_display_name(platform: str) -> str:
        """Convert platform code to display name"""
        platform_names = {
            'platform_ps': '🎮 PlayStation (PS4/PS5)',
            'platform_xbox': '🎮 Xbox (One/Series X|S)', 
            'platform_pc': '🖥️ PC (Origin/Steam/Epic)',
            'PlayStation': '🎮 PlayStation (PS4/PS5)',
            'Xbox': '🎮 Xbox (One/Series X|S)', 
            'PC': '🖥️ PC (Origin/Steam/Epic)'
        }
        return platform_names.get(platform, platform if platform else 'غير محدد')
    
    @staticmethod
    def _get_payment_display_name(payment_method: str) -> str:
        """Convert payment method code to display name"""
        payment_names = {
            'payment_vodafone': '📱 فودافون كاش (010)',
            'payment_etisalat': '📱 اتصالات كاش (011)',
            'payment_orange': '📱 أورانج كاش (012)',
            'payment_we': '📱 وي كاش (015)',
            'payment_bank': '🏦 محفظة بنكية',
            'payment_tilda': '💳 كارت تيلدا',
            'payment_instapay': '💰 إنستاباي',
            'فودافون كاش': '📱 فودافون كاش (010)',
            'اتصالات كاش': '📱 اتصالات كاش (011)',
            'أورانج كاش': '📱 أورانج كاش (012)',
            'وي كاش': '📱 وي كاش (015)',
            'محفظة بنكية': '🏦 محفظة بنكية',
            'كارت تيلدا': '💳 كارت تيلدا',
            'إنستاباي': '💰 إنستاباي'
        }
        return payment_names.get(payment_method, payment_method if payment_method else 'غير محدد')
    
    @staticmethod
    def create_registration_progress_summary(step: str, completed_steps: List[str]) -> str:
        """Create registration progress summary"""
        
        all_steps = [
            ('choosing_platform', '1️⃣ اختيار المنصة'),
            ('entering_whatsapp', '2️⃣ تأكيد رقم الواتساب'),
            ('choosing_payment', '3️⃣ اختيار طريقة الدفع'),
            ('entering_payment_details', '4️⃣ إدخال تفاصيل الدفع'),
            ('completed', '5️⃣ إتمام التسجيل')
        ]
        
        progress_text = "📊 <b>تقدم التسجيل</b>\n\n"
        
        for step_key, step_name in all_steps:
            if step_key in completed_steps:
                progress_text += f"✅ {step_name}\n"
            elif step_key == step:
                progress_text += f"🔄 {step_name} ← <b>جاري الآن</b>\n"
            else:
                progress_text += f"⏳ {step_name}\n"
        
        # Calculate percentage
        total_steps = len(all_steps)
        completed_count = len(completed_steps)
        percentage = int((completed_count / total_steps) * 100)
        
        progress_text += f"\n📈 <b>نسبة الإنجاز:</b> {percentage}%"
        
        return progress_text
    
    @staticmethod
    def create_statistics_summary(stats: Dict) -> str:
        """Create bot statistics summary"""
        return f"""📊 <b>إحصائيات FC26 Bot</b>

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
<b>👥 المستخدمون</b>

👤 <b>إجمالي المستخدمين:</b> {stats.get('total_users', 0):,}
✅ <b>المسجلين بالكامل:</b> {stats.get('completed_registrations', 0):,}
🔄 <b>قيد التسجيل:</b> {stats.get('pending_registrations', 0):,}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
<b>🎮 المنصات الأكثر شعبية</b>

🥇 <b>الأول:</b> {stats.get('top_platform', 'PlayStation')}
🥈 <b>الثاني:</b> {stats.get('second_platform', 'Xbox')}
🥉 <b>الثالث:</b> {stats.get('third_platform', 'PC')}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
<b>💳 طرق الدفع المفضلة</b>

🥇 <b>الأكثر استخداماً:</b> {stats.get('top_payment', 'فودافون كاش')}
📈 <b>النمو السريع:</b> {stats.get('trending_payment', 'إنستاباي')}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⏰ <b>آخر تحديث:</b> {datetime.now().strftime('%Y-%m-%d %H:%M')}"""
    
    @staticmethod
    def create_daily_report(date: str, metrics: Dict) -> str:
        """Create daily activity report"""
        return f"""📅 <b>تقرير يومي - {date}</b>

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
<b>📊 النشاط اليومي</b>

🆕 <b>تسجيلات جديدة:</b> {metrics.get('new_registrations', 0)}
✅ <b>تسجيلات مكتملة:</b> {metrics.get('completed_today', 0)}
📱 <b>رسائل مرسلة:</b> {metrics.get('messages_sent', 0)}
❌ <b>أخطاء:</b> {metrics.get('errors_count', 0)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
<b>🎯 معدل النجاح</b>

📈 <b>معدل إكمال التسجيل:</b> {metrics.get('completion_rate', 0):.1f}%
⚡ <b>متوسط وقت التسجيل:</b> {metrics.get('avg_registration_time', 'غير محدد')}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
<b>🔝 الذروات</b>

⏰ <b>أكثر الأوقات نشاطاً:</b> {metrics.get('peak_hour', 'غير محدد')}
🎮 <b>منصة اليوم:</b> {metrics.get('platform_of_day', 'غير محدد')}"""
    
    @staticmethod
    def create_help_summary() -> str:
        """Create comprehensive help summary"""
        return """📚 <b>دليل استخدام FC26 Bot</b>

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
<b>🚀 البدء</b>

/start - بدء أو متابعة التسجيل
/help - عرض هذه المساعدة
/profile - عرض الملف الشخصي

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
<b>🎮 المنصات المدعومة</b>

• PlayStation (PS4/PS5)
• Xbox (One/Series X|S)  
• PC (Origin/Steam/Epic)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
<b>💳 طرق الدفع</b>

• فودافون كاش (010)
• اتصالات كاش (011)
• أورانج كاش (012)
• وي كاش (015)
• محفظة بنكية
• كارت تيلدا
• إنستاباي

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
<b>📱 قواعد الأرقام</b>

✅ يبدأ بـ: 010, 011, 012, 015
✅ طول: 11 رقماً بالضبط
❌ لا تضع: +20 أو مسافات

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
<b>🔗 روابط إنستاباي</b>

✅ يجب أن يحتوي على: instapay.com.eg
✅ مثال: https://instapay.com.eg/abc123

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
<b>📞 الدعم الفني</b>

إذا واجهت أي مشكلة، تواصل مع فريق الدعم وستحصل على المساعدة فوراً."""
    
    @staticmethod
    def create_feature_list() -> str:
        """Create bot features list"""
        return """⭐ <b>مميزات FC26 Bot</b>

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
<b>🔥 المميزات الرئيسية</b>

✨ <b>تسجيل سريع وسهل</b> - 4 خطوات بسيطة
🛡️ <b>أمان عالي</b> - حماية شاملة للبيانات
📱 <b>دعم جميع الشبكات</b> - كل طرق الدفع المصرية
🎮 <b>دعم كل المنصات</b> - PS، Xbox، PC
🔄 <b>متابعة التقدم</b> - إكمال من آخر خطوة
💬 <b>واجهة عربية</b> - بالعربية بالكامل

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
<b>🚀 مميزات متقدمة</b>

📋 <b>نسخ بنقرة</b> - نسخ البيانات بسهولة
🔍 <b>تحقق ذكي</b> - فحص تلقائي للبيانات
⚡ <b>استجابة سريعة</b> - رد فوري على جميع الرسائل
🎯 <b>توجيه ذكي</b> - إرشادات واضحة لكل خطوة
📊 <b>تتبع مفصل</b> - متابعة كاملة للعملية

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎮 <b>FC26 - الخيار الأول للاعبين المحترفين</b>"""

--- FC26_sale_coins_Bot/messages/welcome_messages.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              🎮 FC26 WELCOME MESSAGES - رسائل الترحيب                   ║
# ║                      Welcome & Greeting Messages                         ║
# ╚══════════════════════════════════════════════════════════════════════════╝

from typing import Dict

class WelcomeMessages:
    """Welcome and greeting messages for the bot"""
    
    @staticmethod
    def get_start_message() -> str:
        """Get main start/welcome message"""
        return """🎮 <b>مرحباً بك في FC26</b>
منصة الألعاب الاحترافية

🚀 <b>اختر منصتك المفضلة للبدء:</b>

<b>🎯 خطوات التسجيل:</b>

1️⃣ اختيار المنصة
2️⃣ تأكيد رقم الواتساب
3️⃣ اختيار طريقة الدفع
4️⃣ إدخال تفاصيل الدفع
5️⃣ إتمام التسجيل

🔥 <b>ابدأ رحلتك الآن!</b>"""
    
    @staticmethod
    def get_platform_selected_message(platform_name: str) -> str:
        """Get platform selection success message"""
        return f"""✅ <b>تم اختيار المنصة بنجاح!</b>

🎮 <b>المنصة المختارة:</b> {platform_name}

<b>📱 تأكيد رقم الواتساب</b>

🔹 أرسل رقم الواتساب الخاص بك
🔹 <b>مثال:</b> 01012345678
🔹 <b>يجب أن يبدأ بـ:</b> 010, 011, 012, أو 015

⚠️ <b>تأكد من صحة الرقم لأنه سيتم التواصل معك عليه</b>"""
    
    @staticmethod
    def get_whatsapp_confirmed_message(phone_display: str) -> str:
        """Get WhatsApp confirmation message"""
        return f"""✅ <b>تم تأكيد رقم الواتساب بنجاح!</b>

📱 <b>الواتساب:</b> <code>{phone_display}</code>

<b>💳 اختيار طريقة الدفع</b>

🔹 <b>اختر الطريقة المناسبة لك:</b>

<b>📋 قائمة طرق الدفع الكاملة:</b>

⭕️ <b>فودافون كاش</b> - رقم 11 خانة يبدأ بـ 010/011/012/015
🟢 <b>اتصالات كاش</b> - رقم 11 خانة يبدأ بـ 010/011/012/015
🍊 <b>أورانج كاش</b> - رقم 11 خانة يبدأ بـ 010/011/012/015
🟣 <b>وي كاش</b> - رقم 11 خانة يبدأ بـ 010/011/012/015
🏦 <b>محفظة بنكية</b> - رقم 11 خانة لأي شبكة مصرية
💳 <b>تيلدا</b> - رقم كارت 16 رقماً بالضبط
🔗 <b>إنستا باي</b> - رابط كامل يحتوي على instapay.com.eg أو ipn.eg"""
    
    @staticmethod
    def get_payment_method_selected_message(payment_name: str, instruction: str) -> str:
        """Get payment method selection message"""
        return f"""✅ <b>تم اختيار طريقة الدفع بنجاح!</b>

💳 <b>طريقة الدفع:</b> {payment_name}

<b>📝 إدخال التفاصيل</b>

🔹 {instruction}

⚠️ <b>تأكد من صحة البيانات قبل الإرسال</b>"""
    
    @staticmethod
    def get_continue_registration_message(step: str, context: Dict = None) -> str:
        """Get continue registration message based on current step"""
        base_message = "🔄 <b>استكمال التسجيل</b>\n\n"
        
        if step == "choosing_platform":
            return base_message + """🎮 <b>اختر منصتك المفضلة:</b>

📍 <b>موضعك الحالي:</b> اختيار المنصة"""
        
        elif step == "entering_whatsapp" and context:
            return base_message + f"""🎮 <b>المنصة:</b> {context.get('platform_name', 'غير محدد')}

<b>📱 أرسل رقم الواتساب الخاص بك:</b>

🔹 <b>مثال:</b> 01012345678
🔹 <b>يجب أن يبدأ بـ:</b> 010, 011, 012, أو 015

📍 <b>موضعك الحالي:</b> تأكيد رقم الواتساب"""
        
        elif step == "choosing_payment" and context:
            return base_message + f"""📱 <b>الواتساب:</b> <code>{context.get('whatsapp', 'غير محدد')}</code>

<b>💳 اختر طريقة الدفع:</b>

📍 <b>موضعك الحالي:</b> اختيار طريقة الدفع"""
        
        elif step == "entering_payment_details" and context:
            return base_message + f"""💳 <b>طريقة الدفع:</b> {context.get('payment_name', 'غير محدد')}

<b>📝 أرسل تفاصيل الدفع:</b>

🔹 {context.get('instruction', 'أدخل التفاصيل')}

📍 <b>موضعك الحالي:</b> إدخال تفاصيل الدفع"""
        
        else:
            return base_message + "📍 <b>موضعك الحالي:</b> غير محدد"
    
    @staticmethod
    def get_help_message() -> str:
        """Get help message"""
        return """📚 <b>مساعدة FC26 Gaming Bot</b>

<b>🤖 الأوامر المتاحة:</b>
• /start - بدء أو متابعة التسجيل
• /profile - عرض الملف الشخصي
• /sell - بيع كوينز FIFA 💰
• /delete - حذف الملف الشخصي
• /help - عرض هذه المساعدة

<b>🎮 المنصات المدعومة:</b>
• PlayStation (PS4/PS5)
• Xbox (One/Series X|S)
• PC (Origin/Steam)

<b>💳 طرق الدفع المدعومة:</b>
• فودافون كاش (010)
• اتصالات كاش (011)
• أورانج كاش (012)
• وي كاش (015)
• محفظة بنكية (أي شبكة)
• كارت تيلدا (16 رقم)
• إنستا باي (رابط كامل)

<b>📱 أرقام الهاتف:</b>
• يجب أن تبدأ بـ 010/011/012/015
• يجب أن تتكون من 11 رقماً بالضبط
• لا تضع كود الدولة (+20)

<b>🔗 روابط إنستاباي:</b>
• يجب أن تحتوي على instapay.com.eg
• أو ipn.eg
• مثال: https://instapay.com.eg/abc123

<b>🗑️ حذف الملف الشخصي:</b>
• استخدم /delete أو الزر في /profile
• تأكيد مزدوج مطلوب للحماية
• العملية لا يمكن التراجع عنها

<b>💰 خدمة بيع الكوينز:</b>
• استخدم /sell لبيع كوينز FIFA
• أفضل الأسعار في السوق المصري
• دفع فوري وآمن 100%
• جميع المنصات مدعومة

<b>📞 للدعم الفني:</b>
تواصل مع فريق الدعم إذا واجهت أي مشكلة"""
    
    @staticmethod
    def get_about_message() -> str:
        """Get about bot message"""
        return """ℹ️ <b>حول FC26 Gaming Bot</b>

🎮 <b>عن المنصة:</b>
FC26 هي منصة احترافية لألعاب FIFA و EA Sports FC، نوفر خدمات متنوعة للاعبين في المنطقة العربية.

🚀 <b>خدماتنا:</b>
• شراء وبيع العملات
• تجارة اللاعبين
• خدمات التطوير
• دعم فني متخصص

🔐 <b>الأمان:</b>
• حماية كاملة للبيانات
• معاملات آمنة ومضمونة
• دعم فني على مدار الساعة

💎 <b>الجودة:</b>
• فريق محترف ومتخصص
• أسعار تنافسية
• خدمة سريعة وموثوقة

📞 <b>التواصل:</b>
نحن هنا لخدمتك في أي وقت"""

--- FC26_sale_coins_Bot/services/__init__.py ---

# FC26 Services Package

--- FC26_sale_coins_Bot/services/admin/__init__.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              👑 FC26 ADMIN SERVICE - خدمة الادارة                       ║
# ║                     Admin Service Package                               ║
# ╚══════════════════════════════════════════════════════════════════════════╝

def _import_admin_components():
    """Import admin components safely"""
    try:
        from .admin_handler import AdminHandler
        from .admin_keyboards import AdminKeyboards
        from .admin_messages import AdminMessages
        from .price_management import PriceManagement
        return AdminHandler, AdminKeyboards, AdminMessages, PriceManagement
    except ImportError:
        return None, None, None, None

# Import components
AdminHandler, AdminKeyboards, AdminMessages, PriceManagement = _import_admin_components()

__all__ = []

# Add components if available
if AdminHandler is not None:
    __all__.extend(['AdminHandler', 'AdminKeyboards', 'AdminMessages', 'PriceManagement'])

--- FC26_sale_coins_Bot/services/admin/admin_conversation_handler.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              👑 ADMIN - CONVERSATION HANDLER                             ║
# ║                   خدمة الأدمن - مع bucket و persistence                 ║
# ╚══════════════════════════════════════════════════════════════════════════╝

"""
خدمة الأدمن باستخدام ConversationHandler
- مع نظام وسم الرسائل (MessageTagger)
- مع نظام عزل البيانات (Session Buckets)
- مع Persistence
"""

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import (
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
    ConversationHandler,
    MessageHandler,
    filters,
)

from database.admin_operations import AdminOperations
from utils.message_tagger import MessageTagger
from utils.session_bucket import bucket, clear_bucket

from .price_management import PriceManagement

# ═══════════════════════════════════════════════════════════════════════════
# STATES
# ═══════════════════════════════════════════════════════════════════════════

ADMIN_MAIN, ADMIN_PRICES, ADMIN_PLATFORM, ADMIN_PRICE_INPUT = range(4)


class AdminConversation:
    """معالج الأدمن - مع bucket"""

    ADMIN_ID = 1124247595

    @staticmethod
    async def start_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """بدء لوحة الأدمن - /admin"""
        MessageTagger.mark_as_handled(context)

        user_id = update.effective_user.id
        username = update.effective_user.username or "Unknown"

        print(f"\n👑 [ADMIN] Admin command from user {user_id} (@{username})")

        if user_id != AdminConversation.ADMIN_ID:
            print(f"❌ [ADMIN] Unauthorized access by {user_id}")
            await update.message.reply_text("❌ غير مصرح لك بالوصول لهذه الخدمة!")
            return ConversationHandler.END

        AdminOperations.log_admin_action(user_id, "ADMIN_LOGIN", "Accessed via /admin")
        print(f"✅ [ADMIN] Admin {user_id} logged in")

        keyboard = [
            [InlineKeyboardButton("💰 إدارة الأسعار", callback_data="admin_prices")],
            [InlineKeyboardButton("📊 الإحصائيات", callback_data="admin_stats")],
            [InlineKeyboardButton("❌ خروج", callback_data="admin_exit")],
        ]

        await update.message.reply_text(
            f"👑 <b>لوحة الأدمن</b>\n\n" f"مرحباً @{username}\n\n" f"اختر الخدمة:",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="HTML",
        )

        return ADMIN_MAIN

    @staticmethod
    async def handle_main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """معالجة القائمة الرئيسية"""
        MessageTagger.mark_as_handled(context)

        query = update.callback_query
        await query.answer()

        user_id = query.from_user.id

        if query.data == "admin_exit":
            await query.edit_message_text("👋 تم الخروج من لوحة الأدمن")
            return ConversationHandler.END

        if query.data == "admin_prices":
            print(f"💰 [ADMIN] {user_id} accessing price management")
            AdminOperations.log_admin_action(user_id, "ACCESSED_PRICE_MANAGEMENT")

            keyboard = [
                [
                    InlineKeyboardButton(
                        "🎮 PlayStation", callback_data="admin_platform_playstation"
                    )
                ],
                [InlineKeyboardButton("🎮 Xbox", callback_data="admin_platform_xbox")],
                [InlineKeyboardButton("🖥️ PC", callback_data="admin_platform_pc")],
                [InlineKeyboardButton("🔙 رجوع", callback_data="admin_back_main")],
            ]

            await query.edit_message_text(
                "💰 <b>إدارة الأسعار</b>\n\n🎮 اختر المنصة:",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="HTML",
            )

            return ADMIN_PLATFORM

        if query.data == "admin_stats":
            await query.edit_message_text(
                "📊 <b>الإحصائيات</b>\n\nقريباً...",
                parse_mode="HTML",
            )
            return ConversationHandler.END

        return ADMIN_MAIN

    @staticmethod
    async def handle_platform_selection(
        update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """معالجة اختيار المنصة"""
        MessageTagger.mark_as_handled(context)

        query = update.callback_query
        await query.answer()

        if query.data == "admin_back_main":
            keyboard = [
                [
                    InlineKeyboardButton(
                        "💰 إدارة الأسعار", callback_data="admin_prices"
                    )
                ],
                [InlineKeyboardButton("📊 الإحصائيات", callback_data="admin_stats")],
                [InlineKeyboardButton("❌ خروج", callback_data="admin_exit")],
            ]

            await query.edit_message_text(
                "👑 <b>لوحة الأدمن</b>\n\nاختر الخدمة:",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="HTML",
            )

            return ADMIN_MAIN

        user_id = query.from_user.id
        platform = query.data.replace("admin_platform_", "")

        print(f"🎮 [ADMIN] {user_id} selected platform: {platform}")

        normal_price = PriceManagement.get_current_price(platform, "normal")
        instant_price = PriceManagement.get_current_price(platform, "instant")

        platform_name = {
            "playstation": "🎮 PlayStation",
            "xbox": "🎮 Xbox",
            "pc": "🖥️ PC",
        }.get(platform, platform)

        keyboard = [
            [
                InlineKeyboardButton(
                    f"📅 عادي - {normal_price:,} ج.م" if normal_price else "📅 عادي",
                    callback_data=f"admin_edit_{platform}_normal",
                )
            ],
            [
                InlineKeyboardButton(
                    f"⚡ فوري - {instant_price:,} ج.م" if instant_price else "⚡ فوري",
                    callback_data=f"admin_edit_{platform}_instant",
                )
            ],
            [InlineKeyboardButton("🔙 رجوع", callback_data="admin_back_platforms")],
        ]

        await query.edit_message_text(
            f"💰 <b>أسعار {platform_name}</b>\n\nاختر نوع التحويل:",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="HTML",
        )

        return ADMIN_PLATFORM

    @staticmethod
    async def handle_transfer_type_selection(
        update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """معالجة اختيار نوع التحويل"""
        MessageTagger.mark_as_handled(context)

        query = update.callback_query
        await query.answer()

        if query.data == "admin_back_platforms":
            keyboard = [
                [
                    InlineKeyboardButton(
                        "🎮 PlayStation", callback_data="admin_platform_playstation"
                    )
                ],
                [InlineKeyboardButton("🎮 Xbox", callback_data="admin_platform_xbox")],
                [InlineKeyboardButton("🖥️ PC", callback_data="admin_platform_pc")],
                [InlineKeyboardButton("🔙 رجوع", callback_data="admin_back_main")],
            ]

            await query.edit_message_text(
                "💰 <b>إدارة الأسعار</b>\n\n🎮 اختر المنصة:",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="HTML",
            )

            return ADMIN_PLATFORM

        user_id = query.from_user.id

        parts = query.data.split("_")
        if len(parts) >= 4:
            platform = parts[2]
            transfer_type = parts[3]

            print(f"⚡ [ADMIN] {user_id} editing {platform} {transfer_type}")

            current_price = PriceManagement.get_current_price(platform, transfer_type)

            if current_price is None:
                await query.edit_message_text(
                    "❌ خطأ في جلب السعر الحالي",
                    parse_mode="HTML",
                )
                return ConversationHandler.END

            # 🔥 استخدام bucket بدلاً من context.user_data
            admin_bucket = bucket(context, "admin")
            admin_bucket["platform"] = platform
            admin_bucket["type"] = transfer_type
            admin_bucket["current_price"] = current_price

            AdminOperations.log_admin_action(
                user_id,
                "STARTED_PRICE_EDIT",
                f"{platform} {transfer_type} - Current: {current_price}",
            )

            platform_name = {
                "playstation": "PlayStation",
                "xbox": "Xbox",
                "pc": "PC",
            }.get(platform, platform)

            transfer_name = "فوري" if transfer_type == "instant" else "عادي"

            await query.edit_message_text(
                f"💰 <b>تعديل سعر {platform_name} - {transfer_name}</b>\n\n"
                f"💵 السعر الحالي: {current_price:,} ج.م\n\n"
                f"📝 أدخل السعر الجديد:\n"
                f"• الحد الأدنى: 1,000 ج.م\n"
                f"• الحد الأقصى: 50,000 ج.م\n\n"
                f"❌ للإلغاء: /cancel",
                parse_mode="HTML",
            )

            return ADMIN_PRICE_INPUT

        return ADMIN_PLATFORM

    @staticmethod
    async def handle_price_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """معالجة إدخال السعر"""
        MessageTagger.mark_as_handled(context)

        user_id = update.effective_user.id
        price_text = update.message.text.strip()

        print(f"💰 [ADMIN] Price input from {user_id}: {price_text}")

        if not price_text.isdigit():
            print(f"   ❌ [ADMIN] Invalid format")
            await update.message.reply_text("❌ صيغة غير صحيحة! أدخل أرقاماً فقط")
            return ADMIN_PRICE_INPUT

        new_price = int(price_text)

        if new_price < 1000:
            print(f"   ❌ [ADMIN] Price too low: {new_price}")
            await update.message.reply_text(
                f"❌ السعر قليل جداً! الحد الأدنى: 1,000 ج.م"
            )
            return ADMIN_PRICE_INPUT

        if new_price > 50000:
            print(f"   ❌ [ADMIN] Price too high: {new_price}")
            await update.message.reply_text(
                f"❌ السعر عالي جداً! الحد الأقصى: 50,000 ج.م"
            )
            return ADMIN_PRICE_INPUT

        # 🔥 استخدام bucket
        admin_bucket = bucket(context, "admin")
        platform = admin_bucket.get("platform")
        transfer_type = admin_bucket.get("type")
        old_price = admin_bucket.get("current_price")

        print(
            f"🔄 [ADMIN] Updating {platform} {transfer_type}: {old_price} → {new_price}"
        )

        success = await PriceManagement.update_price(
            platform, transfer_type, new_price, user_id
        )

        if not success:
            await update.message.reply_text("❌ حدث خطأ في تحديث السعر")
            return ConversationHandler.END

        platform_name = {
            "playstation": "PlayStation",
            "xbox": "Xbox",
            "pc": "PC",
        }.get(platform, platform)

        transfer_name = "فوري" if transfer_type == "instant" else "عادي"

        await update.message.reply_text(
            f"✅ <b>تم تحديث السعر بنجاح!</b>\n\n"
            f"🎮 المنصة: {platform_name}\n"
            f"⚡ النوع: {transfer_name}\n"
            f"💰 السعر القديم: {old_price:,} ج.م\n"
            f"💵 السعر الجديد: {new_price:,} ج.م\n\n"
            f"🔹 /admin للرجوع للوحة التحكم",
            parse_mode="HTML",
        )

        # 🔥 مسح bucket فقط
        clear_bucket(context, "admin")
        print(f"✅ [ADMIN] Price updated successfully")

        return ConversationHandler.END

    @staticmethod
    async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """إلغاء العملية"""
        MessageTagger.mark_as_handled(context)

        user_id = update.effective_user.id
        print(f"❌ [ADMIN] {user_id} cancelled operation")

        await update.message.reply_text(
            "❌ تم إلغاء العملية\n\n🔹 /admin للرجوع للوحة التحكم"
        )

        # 🔥 مسح bucket فقط
        clear_bucket(context, "admin")
        AdminOperations.log_admin_action(user_id, "CANCELLED_OPERATION")

        return ConversationHandler.END

    @staticmethod
    def get_conversation_handler():
        """إنشاء ConversationHandler للخدمة"""
        return ConversationHandler(
            entry_points=[CommandHandler("admin", AdminConversation.start_admin)],
            states={
                ADMIN_MAIN: [
                    CallbackQueryHandler(
                        AdminConversation.handle_main_menu,
                        pattern="^admin_prices$|^admin_stats$|^admin_exit$",
                    )
                ],
                ADMIN_PLATFORM: [
                    CallbackQueryHandler(
                        AdminConversation.handle_platform_selection,
                        pattern="^admin_platform_|^admin_back_main$",
                    ),
                    CallbackQueryHandler(
                        AdminConversation.handle_transfer_type_selection,
                        pattern="^admin_edit_|^admin_back_platforms$",
                    ),
                ],
                ADMIN_PRICE_INPUT: [
                    MessageHandler(
                        filters.TEXT & ~filters.COMMAND,
                        AdminConversation.handle_price_input,
                    )
                ],
            },
            fallbacks=[CommandHandler("cancel", AdminConversation.cancel)],
            name="admin_conversation",
            persistent=True,  # 🔥 تفعيل Persistence
            block=True,
        )


--- FC26_sale_coins_Bot/services/admin/admin_handler.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              👑 FC26 ADMIN HANDLER - معالج الادارة الرئيسي               ║
# ║                     Main Admin Handler                                  ║
# ╚══════════════════════════════════════════════════════════════════════════╝

import logging
import os
import sys
from typing import Dict, List, Optional

from telegram import InlineKeyboardMarkup, Update
from telegram.ext import (
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    filters,
)

# إضافة مسار المشروع للاستيراد
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))

from database.admin_operations import AdminOperations

from .admin_keyboards import AdminKeyboards
from .admin_messages import AdminMessages
from .price_management import PriceManagement

logger = logging.getLogger(__name__)

# ═══════════════════════════════════════════════════════════════════════════
# CUSTOM FILTER - SMART ADMIN DETECTION
# ═══════════════════════════════════════════════════════════════════════════


class AdminPriceEditFilter(filters.MessageFilter):
    """
    فلتر ذكي: يسمح بالرسائل فقط إذا:
    1. المستخدم هو الأدمن
    2. الأدمن عنده session نشط لتعديل السعر

    في أي حالة تانية، الرسالة بتتمرر للـ handler التاني (main handler)
    """

    def __init__(self, admin_id: int, session_storage: dict):
        """
        Args:
            admin_id: معرف الأدمن الوحيد
            session_storage: مرجع لـ self.user_sessions
        """
        self.admin_id = admin_id
        self.session_storage = session_storage
        super().__init__()

    def filter(self, message):
        """
        بترجع True فقط إذا الرسالة تخص الأدمن وعنده session نشط
        """
        # لو مش الأدمن، return False عشان الرسالة تعدي للـ handler التاني
        if message.from_user.id != self.admin_id:
            return False

        # لو الأدمن بس مفيش session نشط، برضه return False
        if self.admin_id not in self.session_storage:
            return False

        # لو الأدمن عنده session نشط، return True
        return True


class AdminHandler:
    """معالج الادارة الرئيسي"""

    # معرف الادمن
    ADMIN_ID = 1124247595

    def __init__(self):
        """تهيئة معالج الادارة"""
        self.user_sessions = {}  # جلسات تعديل الأسعار

        # تهيئة قاعدة البيانات
        AdminOperations.init_admin_db()

        # 🔥 إنشاء الفلتر الذكي
        self.smart_filter = AdminPriceEditFilter(
            admin_id=self.ADMIN_ID, session_storage=self.user_sessions
        )

        print(f"\n👑 [ADMIN] AdminHandler initialized for admin ID: {self.ADMIN_ID}")
        print(f"🔐 [ADMIN] Session storage ready for price editing workflows")
        print(f"🔍 [ADMIN] Smart filter created for admin text handler")

        # طباعة الـ callback patterns للتصحيح
        self.debug_callback_patterns()

        logger.info("✅ Admin handler initialized")

    def get_handlers(self) -> List:
        """جلب جميع معالجات الادارة"""
        print(f"\n🔧 [ADMIN] Registering admin handlers...")

        handlers = [
            # أوامر الادمن
            CommandHandler("admin", self.handle_admin_command),
            CommandHandler("prices", self.handle_prices_command),
            # معالجات الأزرار
            CallbackQueryHandler(self.handle_admin_main, pattern="^admin_main$"),
            CallbackQueryHandler(
                self.handle_price_management, pattern="^admin_prices$"
            ),
            CallbackQueryHandler(
                self.handle_platform_edit, pattern="^admin_edit_(playstation|xbox|pc)$"
            ),
            CallbackQueryHandler(
                self.handle_transfer_type_edit,
                pattern="^admin_edit_(playstation|xbox|pc)_(normal|instant)$",
            ),
            # معالج عام للـ callbacks غير المعروفة (آخر واحد عشان ميتداخلش)
            CallbackQueryHandler(self.handle_unknown_callback, pattern="^admin_.*$"),
        ]

        print(f"✅ [ADMIN] {len(handlers)} admin handlers prepared for registration")
        print(f"🎯 [ADMIN] Handlers include: commands and callbacks")
        print(
            f"📝 [ADMIN] Note: Admin text message handler will be registered separately with group=1"
        )
        return handlers

    def get_admin_text_filter(self):
        """جلب الفلتر الذكي لمعالج الرسائل النصية"""
        return self.smart_filter

    def is_admin(self, user_id: int) -> bool:
        """التحقق من صلاحية الادمن"""
        is_authorized = user_id == self.ADMIN_ID
        if not is_authorized:
            print(
                f"⚠️ [ADMIN] Unauthorized access attempt from user {user_id} (Expected: {self.ADMIN_ID})"
            )
        return is_authorized

    def debug_callback_patterns(self):
        """طباعة جميع الـ callback patterns المتاحة للتصحيح"""
        patterns = [
            "admin_main",
            "admin_prices",
            "admin_edit_playstation",
            "admin_edit_xbox",
            "admin_edit_pc",
            "admin_edit_playstation_normal",
            "admin_edit_playstation_instant",
            "admin_edit_xbox_normal",
            "admin_edit_xbox_instant",
            "admin_edit_pc_normal",
            "admin_edit_pc_instant",
        ]

        print(f"\n🎯 [ADMIN] Available callback patterns:")
        for i, pattern in enumerate(patterns, 1):
            print(f"   {i:2d}. {pattern}")
        print(f"📊 [ADMIN] Total patterns: {len(patterns)}")

        return patterns

    # ═══════════════════════════════════════════════════════════════════════════
    # COMMAND HANDLERS
    # ═══════════════════════════════════════════════════════════════════════════

    async def handle_admin_command(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """معالج أمر /admin"""
        user_id = update.effective_user.id
        username = update.effective_user.username or "Unknown"

        print(f"\n🔑 [ADMIN] Admin command received from user {user_id} (@{username})")

        if not self.is_admin(user_id):
            print(f"❌ [ADMIN] Unauthorized access attempt by user {user_id}")
            await update.message.reply_text(
                AdminMessages.get_unauthorized_message(),
                reply_markup=AdminKeyboards.get_unauthorized_keyboard(),
                parse_mode="HTML",
            )
            return

        print(f"✅ [ADMIN] Admin {user_id} successfully logged in")

        # تسجيل دخول الادمن
        AdminOperations.log_admin_action(
            user_id, "ADMIN_LOGIN", f"Accessed via /admin command"
        )

        # عرض لوحة الادارة
        message = AdminMessages.get_main_admin_message(user_id)
        keyboard = AdminKeyboards.get_main_admin_keyboard()

        await update.message.reply_text(
            message, reply_markup=keyboard, parse_mode="HTML"
        )

        print(f"📊 [ADMIN] Admin dashboard sent to user {user_id}")

    async def handle_prices_command(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """معالج أمر /prices - عرض الأسعار مباشرة"""
        user_id = update.effective_user.id

        if not self.is_admin(user_id):
            await update.message.reply_text(
                AdminMessages.get_unauthorized_message(),
                reply_markup=AdminKeyboards.get_unauthorized_keyboard(),
                parse_mode="HTML",
            )
            return

        # عرض الأسعار مباشرة
        await self._show_current_prices(update, user_id)

    # ═══════════════════════════════════════════════════════════════════════════
    # CALLBACK HANDLERS
    # ═══════════════════════════════════════════════════════════════════════════

    async def handle_admin_main(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """معالج العودة للقائمة الرئيسية"""
        query = update.callback_query
        user_id = query.from_user.id
        username = query.from_user.username or "Unknown"

        print(
            f"\n🏠 [ADMIN] Main menu callback received from user {user_id} (@{username})"
        )
        print(f"📞 [ADMIN] Callback data: {query.data}")

        await query.answer()
        print(f"✅ [ADMIN] Callback answered for user {user_id}")

        if not self.is_admin(user_id):
            await query.edit_message_text(
                AdminMessages.get_unauthorized_message(),
                reply_markup=AdminKeyboards.get_unauthorized_keyboard(),
                parse_mode="HTML",
            )
            return

        message = AdminMessages.get_main_admin_message(user_id)
        keyboard = AdminKeyboards.get_main_admin_keyboard()

        await query.edit_message_text(message, reply_markup=keyboard, parse_mode="HTML")

    async def handle_price_management(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """معالج إدارة الأسعار"""
        query = update.callback_query
        user_id = query.from_user.id
        username = query.from_user.username or "Unknown"

        print(
            f"\n💰 [ADMIN] Price management callback received from user {user_id} (@{username})"
        )
        print(f"📞 [ADMIN] Callback data: {query.data}")

        await query.answer()
        print(f"✅ [ADMIN] Callback answered for user {user_id}")

        if not self.is_admin(user_id):
            await query.edit_message_text(AdminMessages.get_unauthorized_message())
            return

        AdminOperations.log_admin_action(user_id, "ACCESSED_PRICE_MANAGEMENT")

        message = AdminMessages.get_price_management_message()
        keyboard = AdminKeyboards.get_price_management_keyboard()

        await query.edit_message_text(message, reply_markup=keyboard, parse_mode="HTML")

    async def handle_view_prices(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """معالج عرض الأسعار الحالية"""
        query = update.callback_query
        user_id = query.from_user.id
        username = query.from_user.username or "Unknown"

        await query.answer()

        print(f"\n📊 [ADMIN] View prices requested by {user_id} (@{username})")

        if not self.is_admin(user_id):
            print(f"❌ [ADMIN] Unauthorized view prices request from user {user_id}")
            return

        await self._show_current_prices_callback(query, user_id)
        print(f"✅ [ADMIN] Prices displayed to admin {user_id}")

    async def handle_platform_edit(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """معالج اختيار منصة للتعديل"""
        query = update.callback_query
        user_id = query.from_user.id
        username = query.from_user.username or "Unknown"

        print(
            f"\n🎮 [ADMIN] Platform edit callback received from user {user_id} (@{username})"
        )
        print(f"📞 [ADMIN] Callback data: {query.data}")

        await query.answer()
        print(f"✅ [ADMIN] Callback answered for user {user_id}")

        if not self.is_admin(user_id):
            return

        # استخراج اسم المنصة
        platform = query.data.split("_")[-1]  # admin_edit_playstation -> playstation
        print(f"🔧 [ADMIN] Extracted platform: {platform}")

        AdminOperations.log_admin_action(
            user_id, "SELECTED_PLATFORM_EDIT", f"Platform: {platform}"
        )
        print(f"📝 [ADMIN] Action logged for platform selection: {platform}")

        message = AdminMessages.get_platform_edit_message(platform)
        keyboard = AdminKeyboards.get_platform_edit_keyboard(platform)
        print(f"📋 [ADMIN] Message and keyboard prepared for platform: {platform}")

        try:
            await query.edit_message_text(
                message, reply_markup=keyboard, parse_mode="HTML"
            )
            print(
                f"✅ [ADMIN] Platform edit interface sent successfully for {platform}"
            )
        except Exception as e:
            print(f"❌ [ADMIN] Failed to send platform edit interface: {e}")

    async def handle_transfer_type_edit(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """معالج اختيار نوع التحويل للتعديل"""
        query = update.callback_query
        user_id = query.from_user.id
        username = query.from_user.username or "Unknown"

        await query.answer()

        print(f"\n⚡ [ADMIN] Transfer type edit requested by {user_id} (@{username})")

        if not self.is_admin(user_id):
            print(f"❌ [ADMIN] Unauthorized callback from user {user_id}")
            return

        # استخراج البيانات من callback_data
        # تنسيق: admin_edit_playstation_normal
        print(f"🔍 [ADMIN] Parsing callback data: '{query.data}'")

        try:
            parts = query.data.split("_")
            print(f"📋 [ADMIN] Split parts: {parts}")

            if len(parts) < 4:
                print(
                    f"❌ [ADMIN] Invalid callback data format: expected 4 parts, got {len(parts)}"
                )
                return

            platform = parts[2]  # playstation
            transfer_type = parts[3]  # normal

            print(
                f"🎮 [ADMIN] Successfully extracted - Platform: {platform}, Type: {transfer_type}"
            )

        except Exception as e:
            print(f"❌ [ADMIN] Error parsing callback data: {e}")
            return

        # جلب السعر الحالي
        current_price = PriceManagement.get_current_price(platform, transfer_type)

        if current_price is None:
            print(
                f"❌ [ADMIN] Failed to get current price for {platform} {transfer_type}"
            )
            await query.edit_message_text(
                AdminMessages.get_error_message("database_error"), parse_mode="HTML"
            )
            return

        print(
            f"💰 [ADMIN] Current price for {platform} {transfer_type}: {current_price}"
        )

        # حفظ بيانات الجلسة
        self.user_sessions[user_id] = {
            "step": "waiting_price",
            "platform": platform,
            "transfer_type": transfer_type,
            "current_price": current_price,
        }

        print(
            f"📝 [ADMIN] Session created for admin {user_id}: waiting for price input"
        )
        print(f"🔑 [ADMIN] Active sessions now: {list(self.user_sessions.keys())}")

        AdminOperations.log_admin_action(
            user_id,
            "STARTED_PRICE_EDIT",
            f"Platform: {platform}, Type: {transfer_type}, Current: {current_price}",
        )

        message = AdminMessages.get_price_edit_prompt(
            platform, transfer_type, current_price
        )
        keyboard = AdminKeyboards.get_price_edit_keyboard(platform, transfer_type)

        try:
            await query.edit_message_text(
                message, reply_markup=keyboard, parse_mode="HTML"
            )
            print(f"✅ [ADMIN] Price edit prompt sent to admin {user_id}")
        except Exception as e:
            print(f"❌ [ADMIN] Failed to send price edit prompt: {e}")

    async def handle_admin_logs(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """معالج عرض سجل الأعمال"""
        query = update.callback_query
        user_id = query.from_user.id
        username = query.from_user.username or "Unknown"

        print(f"\n📊 [ADMIN] Logs callback received from user {user_id} (@{username})")
        print(f"📞 [ADMIN] Callback data: {query.data}")

        await query.answer()
        print(f"✅ [ADMIN] Callback answered for user {user_id}")

        if not self.is_admin(user_id):
            return

        logs = AdminOperations.get_admin_logs(50)
        message = AdminMessages.get_admin_logs_message(logs)
        keyboard = AdminKeyboards.get_admin_logs_keyboard()

        await query.edit_message_text(message, reply_markup=keyboard, parse_mode="HTML")

    async def handle_admin_stats(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """معالج الإحصائيات"""
        query = update.callback_query
        user_id = query.from_user.id
        username = query.from_user.username or "Unknown"

        print(f"\n📈 [ADMIN] Stats callback received from user {user_id} (@{username})")
        print(f"📞 [ADMIN] Callback data: {query.data}")

        await query.answer()
        print(f"✅ [ADMIN] Callback answered for user {user_id}")

        if not self.is_admin(user_id):
            return

        # رسالة مؤقتة - يمكن تطويرها لاحقاً
        await query.edit_message_text(
            "📊 <b>الإحصائيات</b>\n\n🚧 هذه الميزة قيد التطوير...\n\nستكون متاحة قريباً!",
            reply_markup=AdminKeyboards.get_main_admin_keyboard(),
            parse_mode="HTML",
        )

    async def handle_unknown_callback(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """معالج الـ callbacks غير المعروفة للتصحيح"""
        query = update.callback_query
        user_id = query.from_user.id
        username = query.from_user.username or "Unknown"

        print(
            f"\n❓ [ADMIN] UNKNOWN callback received from user {user_id} (@{username})"
        )
        print(f"🔍 [ADMIN] Callback data: '{query.data}'")
        print(f"⚠️ [ADMIN] This callback was not handled by any specific pattern!")

        await query.answer()

        # إذا كان admin، أرسل رسالة توضيحية
        if self.is_admin(user_id):
            print(f"🛠️ [ADMIN] Sending debug message to admin about unknown callback")
            await query.edit_message_text(
                f"🐛 <b>Debug Info</b>\n\n"
                f"❓ Unknown callback received: <code>{query.data}</code>\n\n"
                f"This helps debug admin system issues!",
                reply_markup=AdminKeyboards.get_main_admin_keyboard(),
                parse_mode="HTML",
            )

    # ═══════════════════════════════════════════════════════════════════════════
    # MESSAGE HANDLERS
    # ═══════════════════════════════════════════════════════════════════════════

    async def handle_price_input(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """معالج إدخال السعر الجديد"""
        user_id = update.effective_user.id
        username = update.effective_user.username or "Unknown"

        print(f"\n💰 [ADMIN] ========== PRICE INPUT HANDLER CALLED ==========")
        print(f"💰 [ADMIN] Price input received from ADMIN {user_id} (@{username})")

        # ✅ الفلتر ضمن إننا هنا فقط لو في session، بس للتأكيد:
        if user_id not in self.user_sessions:
            print(f"⚠️ [ADMIN] No active session (filter should have caught this)")
            return

        session = self.user_sessions[user_id]
        print(f"📋 [ADMIN] Session data: {session}")

        if session.get("step") != "waiting_price":
            print(
                f"⚠️ [ADMIN] Admin {user_id} not in price waiting step: {session.get('step', 'unknown')}"
            )
            return

        print(f"✅ [ADMIN] Admin {user_id} is in correct step: waiting_price")

        price_text = update.message.text.strip()
        print(f"📝 [ADMIN] Admin {user_id} entered price: '{price_text}'")

        # التحقق من صحة السعر
        is_valid, new_price, error_message = PriceManagement.validate_price_input(
            price_text
        )

        if not is_valid:
            print(
                f"❌ [ADMIN] Invalid price input from admin {user_id}: {error_message}"
            )
            await update.message.reply_text(
                f"❌ {error_message}\n\nيرجى المحاولة مرة أخرى:", parse_mode="HTML"
            )
            return

        # بيانات التحديث
        platform = session["platform"]
        transfer_type = session["transfer_type"]
        old_price = session["current_price"]

        print(
            f"🔄 [ADMIN] Updating price: {platform} {transfer_type} from {old_price} to {new_price}"
        )

        # تحديث السعر في قاعدة البيانات
        success = await PriceManagement.update_price(
            platform, transfer_type, new_price, user_id
        )

        if not success:
            print(f"❌ [ADMIN] Failed to update price in database")
            await update.message.reply_text(
                AdminMessages.get_error_message("database_error"), parse_mode="HTML"
            )
            return

        print(f"✅ [ADMIN] Price successfully updated in database")

        # رسالة النجاح
        success_message = AdminMessages.get_price_update_success(
            platform, transfer_type, old_price, new_price
        )
        keyboard = AdminKeyboards.get_price_update_success_keyboard()

        try:
            await update.message.reply_text(
                success_message, reply_markup=keyboard, parse_mode="HTML"
            )
            print(f"✅ [ADMIN] Success message sent to admin {user_id}")
        except Exception as e:
            print(f"❌ [ADMIN] Failed to send success message: {e}")

        # مسح الجلسة
        del self.user_sessions[user_id]
        print(f"🧹 [ADMIN] Session cleared for admin {user_id}")
        print(f"🔑 [ADMIN] Active sessions now: {list(self.user_sessions.keys())}")

        logger.info(
            f"✅ Price updated by admin {user_id}: {platform} {transfer_type} {old_price} -> {new_price}"
        )
        print(
            f"💾 [ADMIN] Price update logged: {platform} {transfer_type} {old_price} -> {new_price}"
        )

    # ═══════════════════════════════════════════════════════════════════════════
    # HELPER METHODS
    # ═══════════════════════════════════════════════════════════════════════════

    async def _show_current_prices(self, update: Update, user_id: int):
        """عرض الأسعار الحالية (للأوامر)"""
        prices = PriceManagement.get_all_current_prices()
        message = AdminMessages.get_current_prices_message(prices)
        keyboard = AdminKeyboards.get_view_prices_keyboard()

        AdminOperations.log_admin_action(user_id, "VIEWED_PRICES")

        await update.message.reply_text(
            message, reply_markup=keyboard, parse_mode="HTML"
        )

    async def _show_current_prices_callback(self, query, user_id: int):
        """عرض الأسعار الحالية (للأزرار)"""
        print(f"📋 [ADMIN] Fetching current prices for admin {user_id}")

        try:
            prices = PriceManagement.get_all_current_prices()
            print(f"💰 [ADMIN] Retrieved {len(prices)} price entries from database")

            message = AdminMessages.get_current_prices_message(prices)
            keyboard = AdminKeyboards.get_view_prices_keyboard()

            AdminOperations.log_admin_action(user_id, "VIEWED_PRICES")

            await query.edit_message_text(
                message, reply_markup=keyboard, parse_mode="HTML"
            )
            print(f"✅ [ADMIN] Prices successfully displayed to admin {user_id}")

        except Exception as e:
            print(f"❌ [ADMIN] Error displaying prices to admin {user_id}: {e}")
            await query.edit_message_text(
                "❌ حدث خطأ في عرض الأسعار. يرجى المحاولة مرة أخرى.", parse_mode="HTML"
            )


--- FC26_sale_coins_Bot/services/admin/admin_keyboards.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              👑 FC26 ADMIN KEYBOARDS - أزرار الادارة                     ║
# ║                     Admin Keyboards Handler                             ║
# ╚══════════════════════════════════════════════════════════════════════════╝

from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from typing import List

class AdminKeyboards:
    """أزرار لوحة الادارة"""
    
    @staticmethod
    def get_main_admin_keyboard() -> InlineKeyboardMarkup:
        """لوحة المفاتيح الرئيسية للإدارة"""
        keyboard = [
            [InlineKeyboardButton("💰 إدارة الأسعار", callback_data="admin_prices")]
            # الأزرار التالية تم حذفها (غير مطلوبة حالياً):
            # [InlineKeyboardButton("📊 الإحصائيات", callback_data="admin_stats")],
            # [InlineKeyboardButton("📝 سجل الأعمال", callback_data="admin_logs")],
            # [InlineKeyboardButton("⚙️ إعدادات النظام", callback_data="admin_settings")],
            # [InlineKeyboardButton("🔄 تحديث البوت", callback_data="admin_refresh")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_price_management_keyboard() -> InlineKeyboardMarkup:
        """لوحة إدارة الأسعار"""
        keyboard = [
            # [InlineKeyboardButton("📋 عرض الأسعار الحالية", callback_data="admin_view_prices")],  # تم الحذف
            [InlineKeyboardButton("✏️ تعديل أسعار PlayStation", callback_data="admin_edit_playstation")],
            [InlineKeyboardButton("✏️ تعديل أسعار Xbox", callback_data="admin_edit_xbox")],
            [InlineKeyboardButton("✏️ تعديل أسعار PC", callback_data="admin_edit_pc")],
            # [InlineKeyboardButton("📊 مقارنة الأسعار", callback_data="admin_compare_prices")],  # تم الحذف
            [InlineKeyboardButton("🔙 العودة للقائمة الرئيسية", callback_data="admin_main")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_platform_edit_keyboard(platform: str) -> InlineKeyboardMarkup:
        """لوحة تعديل أسعار منصة معينة"""
        keyboard = [
            [InlineKeyboardButton("📅 تعديل التحويل العادي", callback_data=f"admin_edit_{platform}_normal")],
            [InlineKeyboardButton("⚡️ تعديل التحويل الفوري", callback_data=f"admin_edit_{platform}_instant")],
            [InlineKeyboardButton("🔙 العودة لإدارة الأسعار", callback_data="admin_prices")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_price_edit_keyboard(platform: str, transfer_type: str) -> InlineKeyboardMarkup:
        """لوحة تعديل سعر معين"""
        keyboard = [
            [InlineKeyboardButton("❌ إلغاء التعديل", callback_data=f"admin_edit_{platform}")],
            [InlineKeyboardButton("🔙 العودة", callback_data="admin_prices")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_price_update_success_keyboard() -> InlineKeyboardMarkup:
        """لوحة بعد نجاح التحديث"""
        keyboard = [
            [InlineKeyboardButton("💰 تعديل سعر آخر", callback_data="admin_prices")],
            [InlineKeyboardButton("🏠 القائمة الرئيسية", callback_data="admin_main")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_view_prices_keyboard() -> InlineKeyboardMarkup:
        """لوحة عرض الأسعار"""
        keyboard = [
            [InlineKeyboardButton("✏️ تعديل الأسعار", callback_data="admin_prices")],
            [InlineKeyboardButton("🔄 تحديث العرض", callback_data="admin_view_prices")],
            # [InlineKeyboardButton("📊 مقارنة المنصات", callback_data="admin_compare_prices")],  # تم الحذف
            [InlineKeyboardButton("🔙 العودة للقائمة الرئيسية", callback_data="admin_main")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_admin_logs_keyboard() -> InlineKeyboardMarkup:
        """لوحة سجل الأعمال"""
        keyboard = [
            # الأزرار التالية تم حذفها (غير مطلوبة حالياً):
            # [InlineKeyboardButton("🔄 تحديث السجل", callback_data="admin_logs")],
            # [InlineKeyboardButton("🗑️ مسح السجل القديم", callback_data="admin_clear_logs")],
            # [InlineKeyboardButton("📊 إحصائيات السجل", callback_data="admin_log_stats")],
            [InlineKeyboardButton("🔙 العودة للقائمة الرئيسية", callback_data="admin_main")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_stats_keyboard() -> InlineKeyboardMarkup:
        """لوحة الإحصائيات"""
        keyboard = [
            [InlineKeyboardButton("👥 إحصائيات المستخدمين", callback_data="admin_user_stats")],
            [InlineKeyboardButton("💰 إحصائيات المبيعات", callback_data="admin_sales_stats")],
            [InlineKeyboardButton("📈 تقرير يومي", callback_data="admin_daily_report")],
            [InlineKeyboardButton("📊 تقرير شهري", callback_data="admin_monthly_report")],
            [InlineKeyboardButton("🔙 العودة للقائمة الرئيسية", callback_data="admin_main")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_unauthorized_keyboard() -> InlineKeyboardMarkup:
        """لوحة عدم وجود صلاحية"""
        keyboard = [
            [InlineKeyboardButton("🏠 العودة للقائمة الرئيسية", callback_data="main_menu")],
            [InlineKeyboardButton("📞 التواصل مع الدعم", callback_data="contact_support")]
        ]
        return InlineKeyboardMarkup(keyboard)

--- FC26_sale_coins_Bot/services/admin/admin_messages.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              👑 FC26 ADMIN MESSAGES - رسائل الادارة                     ║
# ║                     Admin Messages Handler                              ║
# ╚══════════════════════════════════════════════════════════════════════════╝

from typing import List, Dict
from datetime import datetime

class AdminMessages:
    """رسائل لوحة الادارة"""
    
    @staticmethod
    def get_main_admin_message(admin_id: int) -> str:
        """رسالة لوحة الادارة الرئيسية"""
        return f"""👑 <b>لوحة الادارة - FC26</b>

🆔 <b>الادمن:</b> <code>{admin_id}</code>
⏰ <b>الوقت:</b> {datetime.now().strftime('%Y-%m-%d %H:%M')}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 <b>الخدمات المتاحة:</b>

💰 <b>إدارة الأسعار:</b>
• عرض جميع الأسعار الحالية
• تعديل أسعار بيع الكوينز
• مراجعة تاريخ التعديلات

📊 <b>الإحصائيات:</b>
• مراجعة أداء البوت
• عرض سجل العمليات
• تقارير المبيعات

⚙️ <b>إعدادات النظام:</b>
• إدارة المستخدمين
• تحديث إعدادات البوت
• النسخ الاحتياطي

اختر الخدمة المطلوبة من الأزرار أدناه 👇"""

    @staticmethod
    def get_price_management_message() -> str:
        """رسالة إدارة الأسعار"""
        return """💰 <b>إدارة أسعار بيع الكوينز</b>

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 <b>الخيارات المتاحة:</b>

📋 <b>عرض الأسعار:</b>
• عرض جميع الأسعار الحالية
• مقارنة الأسعار بين المنصات
• تاريخ آخر تحديث

✏️ <b>تعديل الأسعار:</b>
• تعديل أسعار PlayStation
• تعديل أسعار Xbox  
• تعديل أسعار PC

📊 <b>السجلات:</b>
• مراجعة تاريخ التعديلات
• إحصائيات التغييرات
• تقرير الأسعار

⚠️ <b>تنبيه:</b> جميع التعديلات يتم حفظها في السجل

اختر العملية المطلوبة:"""

    @staticmethod
    def get_current_prices_message(prices: List[Dict]) -> str:
        """رسالة عرض الأسعار الحالية"""
        if not prices:
            return "❌ لا توجد أسعار محفوظة في قاعدة البيانات"
        
        message = "📊 <b>الأسعار الحالية - جميع المنصات</b>\n\n"
        
        # تجميع الأسعار حسب المنصة
        platforms = {}
        for price in prices:
            platform = price['platform']
            if platform not in platforms:
                platforms[platform] = {}
            
            platforms[platform][price['transfer_type']] = {
                'price': price['price'],
                'amount': price['amount'],
                'updated': price['updated_at']
            }
        
        # عرض الأسعار
        platform_names = {
            'playstation': '🎮 PlayStation',
            'xbox': '🎮 Xbox', 
            'pc': '🖥️ PC'
        }
        
        for platform, platform_prices in platforms.items():
            platform_name = platform_names.get(platform, platform)
            message += f"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
            message += f"<b>{platform_name}</b>\n\n"
            
            if 'normal' in platform_prices:
                normal = platform_prices['normal']
                message += f"📅 <b>عادي:</b> {normal['price']:,} ج.م\n"
                message += f"   💰 الكمية: {normal['amount']:,} كوين\n"
                message += f"   📅 آخر تحديث: {normal['updated'][:16]}\n\n"
            
            if 'instant' in platform_prices:
                instant = platform_prices['instant']
                message += f"⚡️ <b>فوري:</b> {instant['price']:,} ج.م\n"
                message += f"   💰 الكمية: {instant['amount']:,} كوين\n"
                message += f"   📅 آخر تحديث: {instant['updated'][:16]}\n\n"
        
        message += "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
        message += "💡 <b>ملاحظة:</b> الأسعار بالجنيه المصري"
        
        return message

    @staticmethod
    def get_platform_edit_message(platform: str) -> str:
        """رسالة تعديل أسعار منصة معينة"""
        platform_names = {
            'playstation': '🎮 PlayStation',
            'xbox': '🎮 Xbox',
            'pc': '🖥️ PC'
        }
        
        platform_name = platform_names.get(platform, platform)
        
        return f"""✏️ <b>تعديل أسعار {platform_name}</b>

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 <b>اختر نوع التحويل للتعديل:</b>

📅 <b>التحويل العادي:</b>
• المدة: خلال 24 ساعة
• السعر الحالي سيتم عرضه

⚡️ <b>التحويل الفوري:</b>
• المدة: خلال ساعة واحدة
• السعر الحالي سيتم عرضه

⚠️ <b>تحذير:</b>
• تأكد من السعر قبل الحفظ
• التعديل يؤثر فوراً على المستخدمين
• سيتم تسجيل التعديل في السجل

اختر نوع التحويل:"""

    @staticmethod
    def get_price_edit_prompt(platform: str, transfer_type: str, current_price: int) -> str:
        """رسالة طلب السعر الجديد"""
        platform_names = {
            'playstation': '🎮 PlayStation',
            'xbox': '🎮 Xbox',
            'pc': '🖥️ PC'
        }
        
        transfer_names = {
            'normal': '📅 عادي',
            'instant': '⚡️ فوري'
        }
        
        platform_name = platform_names.get(platform, platform)
        transfer_name = transfer_names.get(transfer_type, transfer_type)
        
        return f"""💰 <b>تعديل السعر</b>

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎮 <b>المنصة:</b> {platform_name}
⏰ <b>نوع التحويل:</b> {transfer_name}
💎 <b>الكمية:</b> 1,000,000 كوين

💰 <b>السعر الحالي:</b> <code>{current_price:,} ج.م</code>

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✏️ <b>أدخل السعر الجديد:</b>

📝 <b>قواعد الإدخال:</b>
• أرقام فقط (بدون فواصل أو رموز)
• السعر بالجنيه المصري
• الحد الأدنى: 1000 ج.م
• الحد الأقصى: 50000 ج.م

💡 <b>مثال:</b> 5500

اكتب السعر الجديد:"""

    @staticmethod
    def get_price_update_success(platform: str, transfer_type: str, old_price: int, new_price: int) -> str:
        """رسالة نجاح تحديث السعر"""
        platform_names = {
            'playstation': '🎮 PlayStation',
            'xbox': '🎮 Xbox',
            'pc': '🖥️ PC'
        }
        
        transfer_names = {
            'normal': '📅 عادي',
            'instant': '⚡️ فوري'
        }
        
        platform_name = platform_names.get(platform, platform)
        transfer_name = transfer_names.get(transfer_type, transfer_type)
        
        return f"""✅ <b>تم تحديث السعر بنجاح!</b>

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 <b>تفاصيل التحديث:</b>

🎮 <b>المنصة:</b> {platform_name}
⏰ <b>نوع التحويل:</b> {transfer_name}
💎 <b>الكمية:</b> 1,000,000 كوين

💰 <b>السعر القديم:</b> <s>{old_price:,} ج.م</s>
💰 <b>السعر الجديد:</b> <code>{new_price:,} ج.م</code>

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⏰ <b>وقت التحديث:</b> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

✨ <b>التحديث مفعل الآن:</b>
• جميع المستخدمين سيرون السعر الجديد
• تم حفظ التعديل في السجل
• يمكن تعديل السعر مرة أخرى في أي وقت

🔙 استخدم الأزرار للعودة أو التعديل مرة أخرى"""

    @staticmethod
    def get_admin_logs_message(logs: List[Dict]) -> str:
        """رسالة عرض سجل أعمال الادمن"""
        if not logs:
            return "📝 <b>سجل الأعمال فارغ</b>\n\nلا توجد عمليات مسجلة حتى الآن."
        
        message = "📝 <b>سجل أعمال الادارة</b>\n\n"
        
        for i, log in enumerate(logs[:10], 1):  # أول 10 عمليات
            action_icons = {
                'UPDATE_PRICE': '💰',
                'ADMIN_LOGIN': '🔐', 
                'VIEWED_PRICES': '👁️',
                'ACCESSED_PRICE_MANAGEMENT': '⚙️'
            }
            
            icon = action_icons.get(log['action'], '📋')
            timestamp = log['timestamp'][:16]  # فقط التاريخ والوقت
            
            message += f"{i}. {icon} <b>{log['action']}</b>\n"
            message += f"   ⏰ {timestamp}\n"
            
            if log['details']:
                message += f"   📝 {log['details'][:50]}...\n"
            
            message += "\n"
        
        if len(logs) > 10:
            message += f"... و {len(logs) - 10} عملية أخرى"
        
        return message

    @staticmethod
    def get_unauthorized_message() -> str:
        """رسالة عدم وجود صلاحية"""
        return """🚫 <b>غير مصرح لك!</b>

❌ <b>عذراً، ليس لديك صلاحية للوصول لهذه الخدمة</b>

🔐 <b>هذه الخدمة مخصصة للإدارة فقط</b>

💬 إذا كنت تعتقد أن هذا خطأ، تواصل مع الدعم الفني"""

    @staticmethod
    def get_error_message(error_type: str = "general") -> str:
        """رسائل الأخطاء المختلفة"""
        errors = {
            "invalid_price": "❌ <b>سعر غير صحيح!</b>\n\nيرجى إدخال رقم صحيح بين 1000 و 50000",
            "database_error": "❌ <b>خطأ في قاعدة البيانات!</b>\n\nحدث خطأ أثناء الحفظ، يرجى المحاولة مرة أخرى",
            "general": "❌ <b>حدث خطأ!</b>\n\nيرجى المحاولة مرة أخرى أو التواصل مع الدعم الفني"
        }
        
        return errors.get(error_type, errors["general"])

--- FC26_sale_coins_Bot/services/admin/price_management.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              💰 FC26 PRICE MANAGEMENT - إدارة الأسعار                    ║
# ║                     Price Management Handler                            ║
# ╚══════════════════════════════════════════════════════════════════════════╝

import re
from typing import Optional, Tuple
import sys
import os

# إضافة مسار المشروع لاستيراد قاعدة البيانات
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))

from database.admin_operations import AdminOperations

class PriceManagement:
    """معالج إدارة الأسعار"""
    
    # الحدود المسموحة للأسعار
    MIN_PRICE = 1000  # 1000 ج.م
    MAX_PRICE = 50000  # 50000 ج.م
    
    # الكمية الافتراضية
    DEFAULT_AMOUNT = 1000000  # 1M كوين
    
    @classmethod
    def validate_price_input(cls, price_text: str) -> Tuple[bool, Optional[int], str]:
        """التحقق من صحة السعر المدخل"""
        if not price_text or not isinstance(price_text, str):
            return False, None, "يرجى إدخال سعر صحيح"
        
        # تنظيف النص من الفواصل والمسافات
        cleaned = re.sub(r'[^\d]', '', price_text.strip())
        
        if not cleaned:
            return False, None, "يرجى إدخال أرقام فقط"
        
        try:
            price = int(cleaned)
        except ValueError:
            return False, None, "يرجى إدخال رقم صحيح"
        
        # التحقق من الحدود
        if price < cls.MIN_PRICE:
            return False, None, f"السعر قليل جداً! الحد الأدنى: {cls.MIN_PRICE:,} ج.م"
        
        if price > cls.MAX_PRICE:
            return False, None, f"السعر عالي جداً! الحد الأقصى: {cls.MAX_PRICE:,} ج.م"
        
        return True, price, "سعر صحيح"
    
    @classmethod
    def get_current_price(cls, platform: str, transfer_type: str) -> Optional[int]:
        """جلب السعر الحالي"""
        return AdminOperations.get_price(platform, transfer_type, cls.DEFAULT_AMOUNT)
    
    @classmethod
    async def update_price(cls, platform: str, transfer_type: str, new_price: int, admin_id: int) -> bool:
        """تحديث السعر - Thread-safe async version"""
        return await AdminOperations.update_price(
            platform, transfer_type, cls.DEFAULT_AMOUNT, new_price, admin_id
        )
    
    @classmethod
    def get_all_current_prices(cls):
        """جلب جميع الأسعار الحالية"""
        return AdminOperations.get_all_prices()
    
    @classmethod
    def calculate_price_difference(cls, old_price: int, new_price: int) -> dict:
        """حساب الفرق في السعر"""
        difference = new_price - old_price
        percentage = (difference / old_price) * 100 if old_price > 0 else 0
        
        return {
            'absolute_diff': difference,
            'percentage_diff': round(percentage, 2),
            'is_increase': difference > 0,
            'is_decrease': difference < 0
        }
    
    @classmethod
    def format_price_change(cls, old_price: int, new_price: int) -> str:
        """تنسيق عرض تغيير السعر"""
        diff = cls.calculate_price_difference(old_price, new_price)
        
        if diff['is_increase']:
            return f"📈 زيادة: +{diff['absolute_diff']:,} ج.م ({diff['percentage_diff']:+.1f}%)"
        elif diff['is_decrease']:
            return f"📉 نقص: {diff['absolute_diff']:,} ج.م ({diff['percentage_diff']:+.1f}%)"
        else:
            return "➡️ لا يوجد تغيير"
    
    @classmethod
    def validate_platform(cls, platform: str) -> bool:
        """التحقق من صحة المنصة"""
        valid_platforms = ['playstation', 'xbox', 'pc']
        return platform.lower() in valid_platforms
    
    @classmethod
    def validate_transfer_type(cls, transfer_type: str) -> bool:
        """التحقق من صحة نوع التحويل"""
        valid_types = ['normal', 'instant']
        return transfer_type.lower() in valid_types
    
    @classmethod
    def get_price_history_summary(cls, platform: str, transfer_type: str, limit: int = 5):
        """جلب ملخص تاريخ تغيير السعر (يحتاج تطوير إضافي في قاعدة البيانات)"""
        # هذه الدالة للتطوير المستقبلي
        pass
    
    @classmethod
    def export_prices_data(cls) -> dict:
        """تصدير بيانات الأسعار"""
        prices = cls.get_all_current_prices()
        
        export_data = {
            'export_time': AdminOperations.get_current_timestamp(),
            'total_prices': len(prices),
            'platforms': {},
            'raw_data': prices
        }
        
        # تجميع البيانات حسب المنصة
        for price in prices:
            platform = price['platform']
            if platform not in export_data['platforms']:
                export_data['platforms'][platform] = {
                    'normal': None,
                    'instant': None
                }
            
            export_data['platforms'][platform][price['transfer_type']] = price['price']
        
        return export_data

--- FC26_sale_coins_Bot/services/sell_coins/__init__.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              💰 FC26 COIN SELLING SERVICE - خدمة بيع الكوينز             ║
# ║                     Coin Selling Service Package                        ║
# ╚══════════════════════════════════════════════════════════════════════════╝

# Import only when telegram is available
def _import_telegram_components():
    """Import telegram-dependent components"""
    try:
        from .sell_handler import SellCoinsHandler
        from .sell_keyboards import SellKeyboards
        from .sell_conversation_handler import SellConversationHandler
        from .sell_conversation_functions import get_sell_conversation_handler, sell_command
        from .sell_callbacks import handle_sell_callbacks
        return SellCoinsHandler, SellKeyboards, SellConversationHandler, get_sell_conversation_handler, sell_command, handle_sell_callbacks
    except ImportError:
        return None, None, None, None, None, None

# Always available imports (no telegram dependency)
from .sell_pricing import CoinSellPricing, Platform
from .sell_messages import SellMessages

# Conditional imports
SellCoinsHandler, SellKeyboards, SellConversationHandler, get_sell_conversation_handler, sell_command, handle_sell_callbacks = _import_telegram_components()

__all__ = [
    'CoinSellPricing',
    'Platform', 
    'SellMessages'
]

# Add telegram-dependent components if available
if SellCoinsHandler is not None:
    __all__.extend([
        'SellCoinsHandler', 
        'SellKeyboards', 
        'SellConversationHandler', 
        'get_sell_conversation_handler', 
        'sell_command', 
        'handle_sell_callbacks'
    ])

--- FC26_sale_coins_Bot/services/sell_coins/sell_callbacks.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║            🎯 FC26 SELL CALLBACKS - معالجات أزرار البيع                ║
# ║                      Sell Callback Handlers                             ║
# ╚══════════════════════════════════════════════════════════════════════════╝

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes


async def handle_sell_callbacks(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """معالج أزرار البيع"""
    query = update.callback_query
    await query.answer()

    if query.data == "contact_support":
        await query.edit_message_text(
            "📞 **التواصل مع الدعم**\n\n"
            "🔥 **للمعاملات السريعة:**\n"
            "واتساب الدعم: `01094591331`\n\n"
            "⚡ **أوقات العمل:**\n"
            "• 24 ساعة يومياً\n"
            "• 7 أيام في الأسبوع\n"
            "• رد سريع خلال دقائق\n\n"
            "💬 **اكتب رسالتك وسنرد عليك فوراً**",
            parse_mode="Markdown"
        )
    
    elif query.data == "main_menu":
        keyboard = [
            [InlineKeyboardButton("💰 بيع الكوينز", callback_data="sell_coins_menu")],
            [InlineKeyboardButton("📞 الدعم", callback_data="contact_support")],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            "🏠 **القائمة الرئيسية - FC 26**\n\n"
            "مرحباً بك في بوت FC 26\n"
            "اختر الخدمة المطلوبة:",
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )

    elif query.data == "sell_coins_menu":
        keyboard = [
            [InlineKeyboardButton("🎮 بيع كوينز FC 26", callback_data="sell_fc26")],
            [InlineKeyboardButton("📞 التحدث مع الدعم", callback_data="contact_support")],
            [InlineKeyboardButton("🏠 القائمة الرئيسية", callback_data="main_menu")],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            "💰 **بيع الكوينز - FC 26**\n\n"
            "🔥 **خدماتنا:**\n"
            "• بيع كوينز FC 26 بأفضل الأسعار\n"
            "• دفع فوري وآمن\n"
            "• دعم فني 24/7\n"
            "• ضمان المعاملة\n\n"
            "اختر الخدمة المطلوبة:",
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )

--- FC26_sale_coins_Bot/services/sell_coins/sell_conversation_functions.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║      🎯 FC26 SELL CONVERSATION FUNCTIONS - دوال محادثة البيع            ║
# ║                    Sell Conversation Handler Functions                  ║
# ╚══════════════════════════════════════════════════════════════════════════╝

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import (
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
    ConversationHandler,
    MessageHandler,
    filters,
)

from states.sell_states import SellStates

from .sell_conversation_handler import SellConversationHandler
from .sell_pricing import CoinSellPricing


# ================================ أوامر البيع ================================
async def sell_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """أمر بيع الكوينز /sell"""
    user_id = update.effective_user.id

    keyboard = [
        [InlineKeyboardButton("🎮 بيع كوينز FC 26", callback_data="sell_fc26")],
        [InlineKeyboardButton("📞 التحدث مع الدعم", callback_data="contact_support")],
        [InlineKeyboardButton("🏠 القائمة الرئيسية", callback_data="main_menu")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(
        "💰 **بيع الكوينز - FC 26**\n\n"
        "🔥 **خدماتنا:**\n"
        "• بيع كوينز FC 26 بأفضل الأسعار\n"
        "• دفع فوري وآمن\n"
        "• دعم فني 24/7\n"
        "• ضمان المعاملة\n\n"
        "اختر الخدمة المطلوبة:",
        reply_markup=reply_markup,
        parse_mode="Markdown",
    )


async def sell_coins_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """بداية محادثة البيع"""
    user_id = update.callback_query.from_user.id

    # عرض خيارات المنصة
    keyboard = [
        [InlineKeyboardButton("🎮 PlayStation", callback_data="platform_playstation")],
        [InlineKeyboardButton("🎮 Xbox", callback_data="platform_xbox")],
        [InlineKeyboardButton("🖥️ PC", callback_data="platform_pc")],
        [InlineKeyboardButton("❌ إلغاء", callback_data="cancel_sell")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.callback_query.edit_message_text(
        "🎮 **اختر منصة اللعب:**\n\n" "اختر المنصة اللي عندك عليها الكوينز:",
        reply_markup=reply_markup,
        parse_mode="Markdown",
    )

    return SellStates.CHOOSE_PLATFORM


async def platform_chosen(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """معالج اختيار المنصة"""
    query = update.callback_query
    await query.answer()

    if query.data == "cancel_sell":
        await query.edit_message_text(
            "✅ **تم إلغاء عملية البيع**\n\nيمكنك العودة في أي وقت باستخدام /sell",
            parse_mode="Markdown",
        )
        return ConversationHandler.END

    # حفظ المنصة
    platform = query.data.replace("platform_", "")
    context.user_data["platform"] = platform
    platform_name = SellConversationHandler.get_platform_name(platform)

    # عرض خيارات نوع التحويل
    keyboard = [
        [
            InlineKeyboardButton(
                "⚡ تحويل فوري (خلال ساعة)", callback_data="type_instant"
            )
        ],
        [
            InlineKeyboardButton(
                "📅 تحويل عادي (خلال 24 ساعة)", callback_data="type_normal"
            )
        ],
        [InlineKeyboardButton("❌ إلغاء", callback_data="cancel_sell")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(
        f"✅ **تم اختيار {platform_name}**\n\n"
        "💰 **اختر نوع التحويل:**\n\n"
        "⚡ **تحويل فوري:** خلال ساعة واحدة (سعر أعلى)\n"
        "📅 **تحويل عادي:** خلال 24 ساعة (سعر عادي)\n\n"
        "💡 **الأسعار تختلف حسب الكمية ونوع التحويل**",
        reply_markup=reply_markup,
        parse_mode="Markdown",
    )

    return SellStates.CHOOSE_TYPE


async def sell_type_chosen(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """معالج اختيار نوع التحويل"""
    query = update.callback_query
    await query.answer()

    if query.data == "cancel_sell":
        await query.edit_message_text(
            "✅ **تم إلغاء عملية البيع**\n\nيمكنك العودة في أي وقت باستخدام /sell",
            parse_mode="Markdown",
        )
        return ConversationHandler.END

    # حفظ نوع التحويل
    transfer_type = "instant" if query.data == "type_instant" else "normal"
    context.user_data["transfer_type"] = transfer_type

    type_name = SellConversationHandler.get_transfer_type_name(transfer_type)
    platform_name = SellConversationHandler.get_platform_name(
        context.user_data.get("platform", "")
    )

    await query.edit_message_text(
        f"✅ **تم اختيار {platform_name} - {type_name}**\n\n"
        "💰 **أدخل كمية الكوينز للبيع:**\n\n"
        "📝 **قواعد الإدخال:**\n"
        "• أرقام فقط (بدون حروف أو رموز)\n"
        "• الحد الأدنى: 2 أرقام (مثال: 50)\n"
        "• الحد الأقصى: 5 أرقام (مثال: 20000)\n"
        "• ممنوع استخدام k أو m\n\n"
        "💡 **أمثلة صحيحة:** 500، 1500، 20000\n\n"
        "اكتب الكمية بالأرقام العادية:",
        parse_mode="Markdown",
    )

    return SellStates.ENTER_AMOUNT


async def sell_amount_entered(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """معالج إدخال كمية الكوينز"""
    user_id = update.effective_user.id
    amount_text = update.message.text

    # تحليل الكمية المدخلة
    amount = SellConversationHandler.parse_amount(amount_text)

    # التحقق من أنواع الأخطاء المختلفة
    error_responses = {
        "invalid_format": "❌ **صيغة غير صحيحة!**\n\n🚫 **ممنوع استخدام k أو m**\n\n✅ **المطلوب:** أرقام فقط (2-5 أرقام)\n📝 **مثال صحيح:** 500 أو 1500 أو 20000\n\nيرجى إدخال الكمية بالأرقام العادية فقط:",
        "invalid_length": f"❌ **عدد الأرقام غير صحيح!**\n\n📍 **المطلوب:**\n• الحد الأدنى: 2 أرقام (مثال: 50)\n• الحد الأقصى: 5 أرقام (مثال: 20000)\n\nأنت أدخلت: {len(amount_text)} أرقام\n\n📝 **أمثلة صحيحة:** 500، 1500، 20000\n\nيرجى إدخال رقم بين 2-5 أرقام:",
        None: "❌ **صيغة غير صحيحة!**\n\n✅ **المطلوب:** أرقام فقط (2-5 أرقام)\n🚫 **ممنوع:** حروف، رموز، k، m\n\n📝 **أمثلة صحيحة:**\n• 500 \n• 1500 \n• 20000\n\nيرجى المحاولة مرة أخرى:",
    }

    if amount in error_responses:
        await update.message.reply_text(error_responses[amount], parse_mode="Markdown")
        return SellStates.ENTER_AMOUNT

    # التحقق من الحدود
    is_valid, validation_message = SellConversationHandler.validate_amount(amount)
    if not is_valid:
        await update.message.reply_text(
            f"❌ **{validation_message}**", parse_mode="Markdown"
        )
        return SellStates.ENTER_AMOUNT

    # حفظ الكمية وحساب السعر
    context.user_data["amount"] = amount
    transfer_type = context.user_data.get("transfer_type", "normal")
    platform = context.user_data.get("platform", "playstation")
    price = SellConversationHandler.calculate_price(amount, transfer_type)

    # عرض ملخص البيع
    summary = _create_sale_summary(user_id, amount, transfer_type, platform, price)
    await update.message.reply_text(summary, parse_mode="Markdown")

    # مسح بيانات المحادثة وإنهاء المحادثة
    context.user_data.clear()
    return ConversationHandler.END


def _create_sale_summary(user_id, amount, transfer_type, platform, price):
    """إنشاء ملخص البيع"""
    formatted_amount = SellConversationHandler.format_amount(amount)
    type_name = SellConversationHandler.get_transfer_type_name(transfer_type)
    platform_name = SellConversationHandler.get_platform_name(platform)

    # جلب سعر المليون كمرجع للمستخدم - مع fallback للأسعار الافتراضية
    million_price = CoinSellPricing.get_price(platform, 1000000, transfer_type)

    # إذا لم يتم العثور على السعر، استخدم الأسعار الافتراضية المباشرة
    if million_price is None:
        # أسعار احتياطية ثابتة (نفس الأسعار من sell_pricing.py)
        default_prices = {
            "normal": {"playstation": 5600, "xbox": 5600, "pc": 6100},
            "instant": {"playstation": 5300, "xbox": 5300, "pc": 5800},
        }
        million_price = default_prices.get(transfer_type, {}).get(platform, 5600)

    # تنسيق سعر المليون مع فواصل
    million_price_formatted = f"{million_price:,}"

    return (
        "🎉 **تم تأكيد طلب البيع بنجاح!**\n\n"
        f"📊 **تفاصيل الطلب:**\n"
        f"🎮 المنصة: {platform_name}\n"
        f"💰 الكمية: {formatted_amount} كوين\n"
        f"💵 السعر: {price} جنيه\n"
        f"⭐ (سعر المليون: {million_price_formatted} جنيه)\n"
        f"⏰ نوع التحويل: {type_name}\n\n"
        "📞 **الخطوات التالية:**\n"
        "1️⃣ سيتم التواصل معك خلال دقائق\n"
        "2️⃣ تسليم الكوينز للممثل\n"
        "3️⃣ استلام المبلغ حسب نوع التحويل\n\n"
        "✅ **تم حفظ طلبك في النظام**\n"
        f"🆔 **رقم الطلب:** #{user_id}{amount}\n\n"
        "💬 **للاستفسار:** /sell\n"
        "🏠 **القائمة الرئيسية:** /start"
    )


async def sell_conversation_cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """إلغاء محادثة البيع"""
    await update.message.reply_text(
        "✅ **تم إلغاء عملية البيع**\n\nيمكنك البدء من جديد باستخدام /sell",
        parse_mode="Markdown",
    )
    context.user_data.clear()
    return ConversationHandler.END


# ================================ إعداد محادثة البيع ================================
def get_sell_conversation_handler():
    """إرجاع معالج محادثة البيع"""
    return ConversationHandler(
        entry_points=[CallbackQueryHandler(sell_coins_start, pattern="^sell_fc26$")],
        states={
            SellStates.CHOOSE_PLATFORM: [
                CallbackQueryHandler(
                    platform_chosen,
                    pattern="^(platform_playstation|platform_xbox|platform_pc|cancel_sell)$",
                )
            ],
            SellStates.CHOOSE_TYPE: [
                CallbackQueryHandler(
                    sell_type_chosen,
                    pattern="^(type_instant|type_normal|cancel_sell)$",
                )
            ],
            SellStates.ENTER_AMOUNT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, sell_amount_entered)
            ],
        },
        fallbacks=[CommandHandler("cancel", sell_conversation_cancel)],
    )


--- FC26_sale_coins_Bot/services/sell_coins/sell_conversation_handler.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              💰 SELL COINS - CONVERSATION HANDLER                        ║
# ║                   خدمة بيع الكوينز - مع bucket و persistence            ║
# ╚══════════════════════════════════════════════════════════════════════════╝

"""
خدمة بيع الكوينز باستخدام ConversationHandler
- مع نظام وسم الرسائل (MessageTagger)
- مع نظام عزل البيانات (Session Buckets)
- مع Persistence
"""

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import (
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
    ConversationHandler,
    MessageHandler,
    filters,
)

from database.operations import UserOperations
from utils.logger import log_user_action
from utils.message_tagger import MessageTagger
from utils.session_bucket import bucket, clear_bucket

from .sell_pricing import CoinSellPricing

# ═══════════════════════════════════════════════════════════════════════════
# STATES
# ═══════════════════════════════════════════════════════════════════════════

SELL_PLATFORM, SELL_TYPE, SELL_AMOUNT = range(3)


class SellCoinsConversation:
    """معالج بيع الكوينز - مع bucket"""

    @staticmethod
    async def start_sell(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """بدء عملية البيع - /sell"""
        MessageTagger.mark_as_handled(context)

        user_id = update.effective_user.id
        log_user_action(user_id, "Started coin selling service")

        print(f"\n💰 [SELL] Service started for user {user_id}")

        # التحقق من التسجيل
        user_data = UserOperations.get_user_data(user_id)
        if not user_data or user_data.get("registration_step") != "completed":
            await update.message.reply_text(
                "❌ <b>يجب إكمال التسجيل أولاً!</b>\n\n🚀 /start للتسجيل",
                parse_mode="HTML",
            )
            return ConversationHandler.END

        # عرض اختيار المنصة
        keyboard = [
            [
                InlineKeyboardButton(
                    "🎮 PlayStation", callback_data="sell_platform_playstation"
                )
            ],
            [InlineKeyboardButton("🎮 Xbox", callback_data="sell_platform_xbox")],
            [InlineKeyboardButton("🖥️ PC", callback_data="sell_platform_pc")],
            [InlineKeyboardButton("❌ إلغاء", callback_data="sell_cancel")],
        ]

        await update.message.reply_text(
            "💰 <b>بيع الكوينز</b>\n\n🎮 اختر منصتك:",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="HTML",
        )

        return SELL_PLATFORM

    @staticmethod
    async def choose_platform(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """اختيار المنصة"""
        MessageTagger.mark_as_handled(context)

        query = update.callback_query
        await query.answer()

        if query.data == "sell_cancel":
            await query.edit_message_text("❌ تم إلغاء عملية البيع")
            return ConversationHandler.END

        user_id = query.from_user.id
        platform = query.data.replace("sell_platform_", "")

        print(f"🎮 [SELL] User {user_id} selected platform: {platform}")

        # 🔥 استخدام bucket بدلاً من context.user_data
        bucket(context, "sell")["platform"] = platform
        log_user_action(user_id, f"Selected platform: {platform}")

        # عرض أنواع التحويل مع الأسعار
        transfer_message = CoinSellPricing.get_platform_pricing_message(platform)

        # جلب أسعار 1M
        normal_price = CoinSellPricing.get_price(platform, 1000000, "normal")
        instant_price = CoinSellPricing.get_price(platform, 1000000, "instant")

        normal_formatted = f"{normal_price:,} ج.م" if normal_price else "غير متاح"
        instant_formatted = f"{instant_price:,} ج.م" if instant_price else "غير متاح"

        keyboard = [
            [
                InlineKeyboardButton(
                    f"📅 تحويل عادي - {normal_formatted}",
                    callback_data=f"sell_type_normal",
                )
            ],
            [
                InlineKeyboardButton(
                    f"⚡ تحويل فوري - {instant_formatted}",
                    callback_data=f"sell_type_instant",
                )
            ],
            [InlineKeyboardButton("🔙 رجوع", callback_data="sell_back")],
        ]

        await query.edit_message_text(
            transfer_message,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="Markdown",
        )

        return SELL_TYPE

    @staticmethod
    async def choose_type(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """اختيار نوع التحويل"""
        MessageTagger.mark_as_handled(context)

        query = update.callback_query
        await query.answer()

        if query.data == "sell_back":
            keyboard = [
                [
                    InlineKeyboardButton(
                        "🎮 PlayStation", callback_data="sell_platform_playstation"
                    )
                ],
                [InlineKeyboardButton("🎮 Xbox", callback_data="sell_platform_xbox")],
                [InlineKeyboardButton("🖥️ PC", callback_data="sell_platform_pc")],
                [InlineKeyboardButton("❌ إلغاء", callback_data="sell_cancel")],
            ]

            await query.edit_message_text(
                "💰 <b>بيع الكوينز</b>\n\n🎮 اختر منصتك:",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="HTML",
            )
            return SELL_PLATFORM

        user_id = query.from_user.id
        transfer_type = query.data.replace("sell_type_", "")

        # 🔥 استخدام bucket
        sell_bucket = bucket(context, "sell")
        platform = sell_bucket.get("platform", "unknown")

        print(f"⚡ [SELL] User {user_id} selected type: {transfer_type}")

        # 🔥 حفظ في bucket
        sell_bucket["type"] = transfer_type
        log_user_action(
            user_id, f"Selected transfer type: {transfer_type} for {platform}"
        )

        platform_name = {
            "playstation": "🎮 PlayStation",
            "xbox": "🎮 Xbox",
            "pc": "🖥️ PC",
        }.get(platform, platform)

        transfer_name = "⚡ فوري" if transfer_type == "instant" else "📅 عادي"

        await query.edit_message_text(
            f"✅ **تم اختيار {platform_name} - {transfer_name}**\n\n"
            f"💰 **أدخل كمية الكوينز للبيع:**\n\n"
            f"📝 **قواعد الإدخال:**\n"
            f"• أرقام فقط (بدون حروف أو رموز)\n"
            f"• الحد الأدنى: 50 كوين\n"
            f"• الحد الأقصى: 20,000 كوين\n\n"
            f"💡 **مثال:** 500 أو 1500 أو 5000\n\n"
            f"اكتب الكمية بالأرقام:\n\n"
            f"❌ للإلغاء: /cancel",
            parse_mode="Markdown",
        )

        return SELL_AMOUNT

    @staticmethod
    async def enter_amount(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """إدخال الكمية"""
        MessageTagger.mark_as_handled(context)

        user_id = update.effective_user.id
        text = update.message.text.strip()

        print(f"💰 [SELL] Amount input from user {user_id}: {text}")

        # التحقق من الصيغة
        if not text.isdigit():
            print(f"   ❌ [SELL] Invalid format: {text}")
            await update.message.reply_text(
                "❌ **صيغة غير صحيحة!**\n\n"
                "✅ **المطلوب:** أرقام فقط\n"
                "🚫 **ممنوع:** حروف، رموز، k، m\n\n"
                "يرجى إدخال الكمية بالأرقام:",
                parse_mode="Markdown",
            )
            return SELL_AMOUNT

        amount = int(text)

        # التحقق من الحدود
        if amount < 50:
            print(f"   ❌ [SELL] Amount too low: {amount}")
            await update.message.reply_text(
                f"❌ **الكمية قليلة جداً!**\n\n"
                f"📍 **الحد الأدنى:** 50 كوين\n"
                f"أنت أدخلت: {amount} كوين\n\n"
                f"يرجى إدخال كمية أكبر:",
                parse_mode="Markdown",
            )
            return SELL_AMOUNT

        if amount > 20000:
            print(f"   ❌ [SELL] Amount too high: {amount}")
            await update.message.reply_text(
                f"❌ **الكمية كبيرة جداً!**\n\n"
                f"📍 **الحد الأقصى:** 20,000 كوين\n"
                f"أنت أدخلت: {amount:,} كوين\n\n"
                f"لبيع كميات أكبر، يرجى التواصل مع الدعم.",
                parse_mode="Markdown",
            )
            return SELL_AMOUNT

        # 🔥 استخدام bucket
        sell_bucket = bucket(context, "sell")
        platform = sell_bucket.get("platform", "playstation")
        transfer_type = sell_bucket.get("type", "normal")

        price = SellCoinsConversation.calculate_price(amount, transfer_type)

        print(f"✅ [SELL] Valid amount: {amount}, calculated price: {price}")

        platform_name = {
            "playstation": "🎮 PlayStation",
            "xbox": "🎮 Xbox",
            "pc": "🖥️ PC",
        }.get(platform, platform)

        transfer_name = "⚡ فوري" if transfer_type == "instant" else "📅 عادي"

        million_price = CoinSellPricing.get_price(platform, 1000000, transfer_type)
        if million_price is None:
            default_prices = {
                "normal": {"playstation": 5600, "xbox": 5600, "pc": 6100},
                "instant": {"playstation": 5300, "xbox": 5300, "pc": 5800},
            }
            million_price = default_prices.get(transfer_type, {}).get(platform, 5600)

        await update.message.reply_text(
            f"🎉 **تم تأكيد طلب البيع بنجاح!**\n\n"
            f"📊 **تفاصيل الطلب:**\n"
            f"🎮 المنصة: {platform_name}\n"
            f"💰 الكمية: {amount:,} كوين\n"
            f"💵 السعر: {price} جنيه\n"
            f"⭐ (سعر المليون: {million_price:,} جنيه)\n"
            f"⏰ نوع التحويل: {transfer_name}\n\n"
            f"📞 **الخطوات التالية:**\n"
            f"1️⃣ سيتم التواصل معك خلال دقائق\n"
            f"2️⃣ تسليم الكوينز للممثل\n"
            f"3️⃣ استلام المبلغ حسب نوع التحويل\n\n"
            f"✅ **تم حفظ طلبك في النظام**\n"
            f"🆔 **رقم الطلب:** #{user_id}{amount}\n\n"
            f"💬 **للاستفسار:** /sell\n"
            f"🏠 **القائمة الرئيسية:** /start",
            parse_mode="Markdown",
        )

        log_user_action(
            user_id,
            f"Completed sell order: {amount} coins, {transfer_type}, {price} EGP",
        )

        # 🔥 مسح bucket فقط
        clear_bucket(context, "sell")
        print(f"🧹 [SELL] Session cleared for user {user_id}")

        return ConversationHandler.END

    @staticmethod
    async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """إلغاء العملية"""
        MessageTagger.mark_as_handled(context)

        user_id = update.effective_user.id
        print(f"❌ [SELL] User {user_id} cancelled sell service")

        await update.message.reply_text(
            "❌ تم إلغاء عملية البيع\n\n🔹 /sell للبدء من جديد"
        )

        # 🔥 مسح bucket فقط
        clear_bucket(context, "sell")
        log_user_action(user_id, "Cancelled coin selling")

        return ConversationHandler.END

    @staticmethod
    def calculate_price(amount: int, transfer_type: str = "normal") -> int:
        """حساب السعر حسب الكمية ونوع التحويل"""
        base_price_per_1000 = 5
        base_price = (amount / 1000) * base_price_per_1000

        if transfer_type == "instant":
            base_price *= 1.2

        return int(base_price)

    @staticmethod
    def get_conversation_handler():
        """إنشاء ConversationHandler للخدمة"""
        return ConversationHandler(
            entry_points=[CommandHandler("sell", SellCoinsConversation.start_sell)],
            states={
                SELL_PLATFORM: [
                    CallbackQueryHandler(
                        SellCoinsConversation.choose_platform,
                        pattern="^sell_platform_|^sell_cancel$",
                    )
                ],
                SELL_TYPE: [
                    CallbackQueryHandler(
                        SellCoinsConversation.choose_type,
                        pattern="^sell_type_|^sell_back$",
                    )
                ],
                SELL_AMOUNT: [
                    MessageHandler(
                        filters.TEXT & ~filters.COMMAND,
                        SellCoinsConversation.enter_amount,
                    )
                ],
            },
            fallbacks=[CommandHandler("cancel", SellCoinsConversation.cancel)],
            name="sell_coins_conversation",
            persistent=True,  # 🔥 تفعيل Persistence
            block=True,
        )


--- FC26_sale_coins_Bot/services/sell_coins/sell_handler.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              🎯 FC26 COIN SELLING HANDLER - معالج بيع الكوينز            ║
# ║                    Main Coin Selling Handler                            ║
# ╚══════════════════════════════════════════════════════════════════════════╝

import logging
import re
from typing import Dict, List, Optional

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import (
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    filters,
)

from database.operations import UserOperations

# استيراد الأدوات المساعدة من البوت الرئيسي
from utils.logger import log_user_action

from .sell_keyboards import SellKeyboards
from .sell_messages import SellMessages
from .sell_pricing import CoinSellPricing, Platform

logger = logging.getLogger(__name__)

# ═══════════════════════════════════════════════════════════════════════════
# CUSTOM FILTER - SMART SELL SESSION DETECTION
# ═══════════════════════════════════════════════════════════════════════════


class SellSessionFilter(filters.MessageFilter):
    """
    فلتر ذكي لخدمة البيع: يسمح بالرسائل فقط إذا المستخدم عنده session بيع نشط
    """

    def __init__(self, session_storage: dict):
        """
        Args:
            session_storage: مرجع لـ self.user_sessions
        """
        self.session_storage = session_storage
        super().__init__()

    def filter(self, message):
        """
        بترجع True فقط إذا المستخدم عنده session بيع نشط
        """
        user_id = message.from_user.id

        # لو مفيش session، return False عشان الرسالة تعدي للـ handler التاني
        if user_id not in self.session_storage:
            return False

        session = self.session_storage[user_id]

        # لو المستخدم مش في خطوة إدخال نص، return False
        if session.get("step") not in ["custom_amount_input", "amount_input"]:
            return False

        # لو كل شيء تمام، return True
        return True


class SellCoinsHandler:
    """معالج خدمة بيع الكوينز الرئيسي"""

    def __init__(self):
        """تهيئة معالج البيع"""
        self.user_sessions = {}  # جلسات المستخدمين النشطة
        self.pending_sales = {}  # البيوعات المعلقة

        # 🔥 إنشاء الفلتر الذكي
        self.smart_filter = SellSessionFilter(session_storage=self.user_sessions)

    def get_handlers(self) -> List:
        """جلب جميع معالجات خدمة البيع"""
        return [
            CommandHandler("sell", self.handle_sell_command),
            CallbackQueryHandler(
                self.handle_platform_selection, pattern="^sell_platform_"
            ),
            CallbackQueryHandler(
                self.handle_transfer_type_selection, pattern="^sell_transfer_"
            ),
            CallbackQueryHandler(self.handle_custom_amount, pattern="^sell_custom_"),
            CallbackQueryHandler(
                self.handle_price_confirmation, pattern="^sell_confirm_"
            ),
            CallbackQueryHandler(self.handle_sale_instructions, pattern="^sell_ready_"),
            CallbackQueryHandler(
                self.handle_payment_selection, pattern="^sell_payment_"
            ),
            CallbackQueryHandler(self.handle_navigation, pattern="^sell_back_"),
            CallbackQueryHandler(self.handle_help, pattern="^sell_help"),
            CallbackQueryHandler(self.handle_cancel, pattern="^sell_cancel"),
            CallbackQueryHandler(self.handle_support, pattern="^sell_support"),
            # ❌ تم إزالة MessageHandler من هنا - سيتم تسجيله منفصلاً مع الفلتر الذكي
        ]

    def get_sell_text_filter(self):
        """جلب الفلتر الذكي لمعالج الرسائل النصية"""
        return self.smart_filter

    async def handle_sell_command(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """معالجة أمر /sell"""
        user_id = update.effective_user.id
        log_user_action(user_id, "Started coin selling service")

        # التحقق من تسجيل المستخدم
        user_data = UserOperations.get_user_data(user_id)
        if not user_data:
            await update.message.reply_text(
                "❌ <b>يجب التسجيل أولاً!</b>\n\n🚀 استخدم /start للتسجيل قبل بيع الكوينز",
                parse_mode="HTML",
            )
            return

        # بدء جلسة بيع جديدة
        self.user_sessions[user_id] = {
            "step": "platform_selection",
            "platform": None,
            "coins": None,
            "price": None,
            "started_at": update.message.date,
        }

        # عرض رسالة الترحيب
        welcome_message = SellMessages.get_welcome_sell_message()
        keyboard = SellKeyboards.get_main_sell_keyboard()

        await update.message.reply_text(
            welcome_message, reply_markup=keyboard, parse_mode="HTML"
        )

    async def handle_platform_selection(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """معالجة اختيار المنصة"""
        query = update.callback_query
        user_id = query.from_user.id

        await query.answer()

        # استخراج المنصة من callback_data
        platform = query.data.replace("sell_platform_", "")

        # حفظ المنصة في الجلسة
        if user_id not in self.user_sessions:
            self.user_sessions[user_id] = {}

        self.user_sessions[user_id].update(
            {"step": "transfer_type_selection", "platform": platform}
        )

        log_user_action(user_id, f"Selected platform: {platform}")

        # عرض رسالة الأسعار البسيطة
        transfer_message = CoinSellPricing.get_platform_pricing_message(platform)

        # جلب أسعار 1M للأزرار
        normal_price = CoinSellPricing.get_price(platform, 1000000, "normal")
        instant_price = CoinSellPricing.get_price(platform, 1000000, "instant")

        normal_formatted = f"{normal_price:,} ج.م" if normal_price else "غير متاح"
        instant_formatted = f"{instant_price:,} ج.م" if instant_price else "غير متاح"

        keyboard = [
            [
                InlineKeyboardButton(
                    f"📅 تحويل عادي - {normal_formatted}",
                    callback_data=f"sell_transfer_normal_{platform}",
                )
            ],
            [
                InlineKeyboardButton(
                    f"⚡️ تحويل فوري - {instant_formatted}",
                    callback_data=f"sell_transfer_instant_{platform}",
                )
            ],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            transfer_message, reply_markup=reply_markup, parse_mode="Markdown"
        )

    async def handle_transfer_type_selection(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """معالجة اختيار نوع التحويل"""
        query = update.callback_query
        user_id = query.from_user.id

        await query.answer()

        # استخراج نوع التحويل والمنصة من callback_data
        # تنسيق: sell_transfer_{transfer_type}_{platform}
        parts = query.data.split("_")
        if len(parts) >= 4:
            transfer_type = parts[2]  # instant أو normal
            platform = parts[3]

            # حفظ نوع التحويل في الجلسة
            self.user_sessions[user_id].update(
                {
                    "step": "amount_input",
                    "transfer_type": transfer_type,
                    "platform": platform,
                }
            )

            log_user_action(
                user_id, f"Selected transfer type: {transfer_type} for {platform}"
            )

            # إعداد أسماء العرض
            platform_name = {
                "playstation": "🎮 PlayStation",
                "xbox": "🎮 Xbox",
                "pc": "🖥️ PC",
            }.get(platform, platform)
            transfer_name = "⚡ فوري" if transfer_type == "instant" else "📅 عادي"

            # رسالة طلب إدخال الكمية
            amount_message = f"""✅ **تم اختيار {platform_name} - {transfer_name}**

💰 **أدخل كمية الكوينز للبيع:**

📝 **قواعد الإدخال:**
• أرقام فقط (بدون حروف أو رموز)
• الحد الأدنى: 2 أرقام (مثال: 50)
• الحد الأقصى: 5 أرقام (مثال: 20000)
• ممنوع استخدام k أو m

💡 **أمثلة صحيحة:** 500، 1500، 20000

اكتب الكمية بالأرقام العادية:"""

            reply_markup = None

            await query.edit_message_text(
                amount_message, reply_markup=reply_markup, parse_mode="Markdown"
            )

    async def handle_custom_amount(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """معالجة طلب كمية مخصصة"""
        query = update.callback_query
        user_id = query.from_user.id

        await query.answer()

        # استخراج المنصة
        platform = query.data.replace("sell_custom_", "")

        # تحديث الجلسة
        self.user_sessions[user_id].update(
            {"step": "custom_amount_input", "platform": platform}
        )

        log_user_action(user_id, f"Requested custom amount for {platform}")

        # عرض رسالة طلب الكمية المخصصة
        custom_message = SellMessages.get_custom_amount_message(platform)
        keyboard = SellKeyboards.get_custom_amount_cancel_keyboard(platform)

        await query.edit_message_text(
            custom_message, reply_markup=keyboard, parse_mode="HTML"
        )

    async def handle_text_input(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """معالجة النص المُدخل (للكمية المخصصة)"""
        user_id = update.effective_user.id

        # ✅ الفلتر ضمن إننا هنا فقط لو في session، بس للتأكيد:
        if user_id not in self.user_sessions:
            print(f"⚠️ [SELL] No active session (filter should have caught this)")
            return

        session = self.user_sessions[user_id]

        # التحقق من الخطوة الحالية
        if session.get("step") not in ["custom_amount_input", "amount_input"]:
            return

        text = update.message.text.strip()
        platform = session.get("platform")
        transfer_type = session.get("transfer_type", "normal")

        # تحليل الكمية المدخلة
        amount = self.parse_amount(text)

        # التحقق من الصيغة الخاطئة (k أو m)
        if amount == "invalid_format":
            await update.message.reply_text(
                "❌ **صيغة غير صحيحة!**\n\n"
                "🚫 **ممنوع استخدام k أو m**\n\n"
                "✅ **المطلوب:** أرقام فقط (2-5 أرقام)\n"
                "📝 **مثال صحيح:** 500 أو 1500 أو 20000\n\n"
                "يرجى إدخال الكمية بالأرقام العادية فقط:",
                parse_mode="Markdown",
            )
            return

        # التحقق من طول الرقم
        if amount == "invalid_length":
            await update.message.reply_text(
                "❌ **عدد الأرقام غير صحيح!**\n\n"
                "📍 **المطلوب:**\n"
                "• الحد الأدنى: 2 أرقام (مثال: 50)\n"
                "• الحد الأقصى: 5 أرقام (مثال: 20000)\n\n"
                f"أنت أدخلت: {len(text)} أرقام\n\n"
                "📝 **أمثلة صحيحة:** 500، 1500، 20000\n\n"
                "يرجى إدخال رقم بين 2-5 أرقام:",
                parse_mode="Markdown",
            )
            return

        # التحقق من صحة الصيغة العامة
        if amount is None:
            await update.message.reply_text(
                "❌ **صيغة غير صحيحة!**\n\n"
                "✅ **المطلوب:** أرقام فقط (2-5 أرقام)\n"
                "🚫 **ممنوع:** حروف، رموز، k، m\n\n"
                "📝 **أمثلة صحيحة:**\n"
                "• 500 \n"
                "• 1500 \n"
                "• 20000\n\n"
                "يرجى المحاولة مرة أخرى:",
                parse_mode="Markdown",
            )
            return

        # تعريف الحدود الفعلية
        MIN_SELL_AMOUNT = 50  # 50 كوين
        MAX_SELL_AMOUNT = 20000  # 20000 كوين

        # التحقق من الحدود
        if amount < MIN_SELL_AMOUNT:
            await update.message.reply_text(
                f"❌ **الكمية قليلة جداً!**\n\n"
                f"📍 **الحد الأدنى:** {self.format_amount(MIN_SELL_AMOUNT)} كوين\n"
                f"أنت أدخلت: {self.format_amount(amount)} كوين\n\n"
                "يرجى إدخال كمية أكبر:",
                parse_mode="Markdown",
            )
            return

        if amount > MAX_SELL_AMOUNT:
            await update.message.reply_text(
                f"❌ **الكمية كبيرة جداً!**\n\n"
                f"📍 **الحد الأقصى:** {self.format_amount(MAX_SELL_AMOUNT)} كوين\n"
                f"أنت أدخلت: {self.format_amount(amount)} كوين\n\n"
                "لبيع كميات أكبر، يرجى التواصل مع الدعم.",
                parse_mode="Markdown",
            )
            return

        coins = amount
        # حساب السعر للكمية المدخلة
        price = self.calculate_price(coins, transfer_type)

        # تحديث الجلسة
        session.update({"step": "sale_completed", "coins": coins, "price": price})

        log_user_action(
            user_id,
            f"Entered amount: {coins} coins, {transfer_type} transfer, price: {price} EGP",
        )

        # إعداد أسماء العرض
        platform_name = {
            "playstation": "🎮 PlayStation",
            "xbox": "🎮 Xbox",
            "pc": "🖥️ PC",
        }.get(platform, platform)
        transfer_name = "⚡ فوري" if transfer_type == "instant" else "📅 عادي"

        # جلب سعر المليون كمرجع للمستخدم
        million_price = CoinSellPricing.get_price(platform, 1000000, transfer_type)

        # إذا لم يتم العثور على السعر، استخدم الأسعار الافتراضية المباشرة
        if million_price is None:
            # أسعار احتياطية ثابتة (نفس الأسعار من sell_pricing.py)
            default_prices = {
                "normal": {"playstation": 5600, "xbox": 5600, "pc": 6100},
                "instant": {"playstation": 5300, "xbox": 5300, "pc": 5800},
            }
            million_price = default_prices.get(transfer_type, {}).get(platform, 5600)

        # تنسيق سعر المليون مع فواصل
        million_price_formatted = f"{million_price:,}"

        # رسالة التأكيد النهائية
        await update.message.reply_text(
            "🎉 **تم تأكيد طلب البيع بنجاح!**\n\n"
            f"📊 **تفاصيل الطلب:**\n"
            f"🎮 المنصة: {platform_name}\n"
            f"💰 الكمية: {self.format_amount(coins)} كوين\n"
            f"💵 السعر: {price} جنيه\n"
            f"⭐ (سعر المليون: {million_price_formatted} جنيه)\n"
            f"⏰ نوع التحويل: {transfer_name}\n\n"
            "📞 **الخطوات التالية:**\n"
            "1️⃣ سيتم التواصل معك خلال دقائق\n"
            "2️⃣ تسليم الكوينز للممثل\n"
            "3️⃣ استلام المبلغ حسب نوع التحويل\n\n"
            "✅ **تم حفظ طلبك في النظام**\n"
            f"🆔 **رقم الطلب:** #{user_id}{coins}\n\n"
            "💬 **للاستفسار:** /sell\n"
            "🏠 **القائمة الرئيسية:** /start",
            parse_mode="Markdown",
        )

        # مسح بيانات المحادثة
        self.clear_user_session(user_id)

    async def handle_price_confirmation(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """معالجة تأكيد السعر"""
        query = update.callback_query
        user_id = query.from_user.id

        await query.answer()

        # استخراج البيانات من callback_data
        # تنسيق: sell_confirm_{platform}_{coins}_{price}
        parts = query.data.split("_")
        if len(parts) >= 5:
            platform = parts[2]
            coins = int(parts[3])
            price = int(parts[4])

            # تحديث الجلسة
            self.user_sessions[user_id].update(
                {
                    "step": "sale_instructions",
                    "platform": platform,
                    "coins": coins,
                    "price": price,
                }
            )

            log_user_action(user_id, f"Confirmed sale: {coins} coins for {price} EGP")

            # عرض تعليمات البيع
            instructions_message = SellMessages.get_sale_instructions_message(
                platform, coins
            )
            keyboard = SellKeyboards.get_sale_instructions_keyboard(platform, coins)

            await query.edit_message_text(
                instructions_message, reply_markup=keyboard, parse_mode="HTML"
            )

    async def handle_sale_instructions(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """معالجة الموافقة على تعليمات البيع"""
        query = update.callback_query
        user_id = query.from_user.id

        await query.answer()

        session = self.user_sessions.get(user_id, {})

        # إنشاء طلب بيع
        sale_id = self._create_sale_request(user_id, session)

        log_user_action(user_id, f"Started sale process, sale_id: {sale_id}")

        # عرض اختيار طريقة الدفع
        payment_message = (
            "💳 <b>اختر طريقة الدفع المفضلة:</b>\n\n"
            + "ستستلم أموالك على الطريقة المختارة فور إتمام البيع"
        )
        keyboard = SellKeyboards.get_payment_method_keyboard()

        await query.edit_message_text(
            payment_message, reply_markup=keyboard, parse_mode="HTML"
        )

    async def handle_payment_selection(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """معالجة اختيار طريقة الدفع"""
        query = update.callback_query
        user_id = query.from_user.id

        await query.answer()

        # استخراج طريقة الدفع
        payment_method = query.data.replace("sell_payment_", "")

        # حفظ طريقة الدفع في الجلسة
        if user_id in self.user_sessions:
            self.user_sessions[user_id]["payment_method"] = payment_method

        log_user_action(user_id, f"Selected payment method: {payment_method}")

        # عرض رسالة نجاح البدء
        success_message = """✅ <b>تم بدء عملية البيع بنجاح!</b>

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 <b>الخطوات التالية:</b>

1️⃣ سيتواصل معك فريق الدعم خلال 5 دقائق
2️⃣ سيتم إرشادك لتنفيذ التعليمات
3️⃣ ستستلم أموالك فور التأكد من الكوينز

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⏰ <b>وقت الاستجابة:</b> 5-10 دقائق كحد أقصى
📞 <b>للاستعجال:</b> تواصل مع الدعم الفني

🎉 <b>شكراً لثقتك في FC26!</b>"""

        keyboard = SellKeyboards.get_sale_progress_keyboard()

        await query.edit_message_text(
            success_message, reply_markup=keyboard, parse_mode="HTML"
        )

    async def handle_navigation(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """معالجة التنقل بين الصفحات"""
        query = update.callback_query
        user_id = query.from_user.id

        await query.answer()

        action = query.data.replace("sell_back_", "")

        if action == "main":
            # العودة للقائمة الرئيسية
            welcome_message = SellMessages.get_welcome_sell_message()
            keyboard = SellKeyboards.get_main_sell_keyboard()

            await query.edit_message_text(
                welcome_message, reply_markup=keyboard, parse_mode="HTML"
            )

        elif action == "platforms":
            # العودة لاختيار المنصة
            platform_message = SellMessages.get_platform_selection_message()
            keyboard = SellKeyboards.get_main_sell_keyboard()

            await query.edit_message_text(
                platform_message, reply_markup=keyboard, parse_mode="HTML"
            )

    async def handle_help(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """معالجة طلب المساعدة"""
        query = update.callback_query
        await query.answer()

        help_message = SellMessages.get_help_message()
        keyboard = SellKeyboards.get_help_keyboard()

        await query.edit_message_text(
            help_message, reply_markup=keyboard, parse_mode="HTML"
        )

    async def handle_cancel(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """معالجة إلغاء البيع"""
        query = update.callback_query
        user_id = query.from_user.id

        await query.answer()

        # إزالة الجلسة
        if user_id in self.user_sessions:
            del self.user_sessions[user_id]

        log_user_action(user_id, "Cancelled coin selling")

        cancel_message = SellMessages.get_error_message("sale_cancelled")
        keyboard = SellKeyboards.get_error_keyboard()

        await query.edit_message_text(
            cancel_message, reply_markup=keyboard, parse_mode="HTML"
        )

    async def handle_support(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """معالجة طلب الدعم الفني"""
        query = update.callback_query
        await query.answer()

        support_message = """📞 <b>الدعم الفني FC26</b>

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🕐 <b>متوفر 24/7 لخدمتك</b>

📱 <b>طرق التواصل:</b>
• الدردشة المباشرة في البوت
• واتساب: متوفر في ملفك الشخصي
• رسائل خاصة

⚡ <b>استجابة سريعة:</b> خلال دقائق معدودة

نحن هنا لمساعدتك! 🤝"""

        await query.edit_message_text(support_message, parse_mode="HTML")

    def _create_sale_request(self, user_id: int, session: Dict) -> str:
        """إنشاء طلب بيع جديد"""
        import time

        sale_id = f"SALE_{user_id}_{int(time.time())}"

        # حفظ طلب البيع
        self.pending_sales[sale_id] = {
            "user_id": user_id,
            "platform": session.get("platform"),
            "coins": session.get("coins"),
            "price": session.get("price"),
            "status": "pending",
            "created_at": time.time(),
        }

        return sale_id

    def get_user_session(self, user_id: int) -> Optional[Dict]:
        """جلب جلسة المستخدم"""
        return self.user_sessions.get(user_id)

    def clear_user_session(self, user_id: int):
        """مسح جلسة المستخدم"""
        if user_id in self.user_sessions:
            del self.user_sessions[user_id]

    @staticmethod
    def parse_amount(text: str):
        """تحليل كمية الكوينز - أرقام فقط (2-5 أرقام)"""
        if not text or not isinstance(text, str):
            return None

        text = text.strip()

        # التحقق من وجود k أو m - ممنوع
        if "k" in text.lower() or "m" in text.lower():
            return "invalid_format"

        try:
            if not text.isdigit():
                return None

            number = int(text)

            # التحقق من عدد الأرقام (2-5 أرقام)
            if len(text) < 2 or len(text) > 5:
                return "invalid_length"

            return number

        except (ValueError, TypeError):
            return None

    @staticmethod
    def calculate_price(amount, transfer_type="normal"):
        """حساب السعر حسب الكمية ونوع التحويل"""
        base_price_per_1000 = 5  # 5 جنيه لكل 1000 كوين

        # حساب السعر الأساسي
        base_price = (amount / 1000) * base_price_per_1000

        # إضافة رسوم حسب نوع التحويل
        if transfer_type == "instant":
            base_price *= 1.2  # زيادة 20% للتحويل الفوري

        return int(base_price)

    @staticmethod
    def format_amount(amount: int) -> str:
        """
        تحويل الأرقام العادية لـ K/M format
        مثال: 915 -> 915 K | 1500 -> 1٬500 M
        """
        if not isinstance(amount, (int, float)):
            return "0"

        amount = int(amount)

        if 50 <= amount <= 999:
            # من 50 إلى 999: عرض بصيغة K
            return f"{amount} K"
        elif 1000 <= amount <= 20000:
            # من 1,000 إلى 20,000: عرض بصيغة M مع الفاصلة العربية
            formatted = f"{amount:,}".replace(",", "٬")
            return f"{formatted} M"
        else:
            # للقيم خارج النطاق: عرض بالأرقام العادية
            return str(amount)


--- FC26_sale_coins_Bot/services/sell_coins/sell_keyboards.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              ⌨️ FC26 COIN SELLING KEYBOARDS - أزرار بيع الكوينز          ║
# ║                       Coin Selling Keyboards                            ║
# ╚══════════════════════════════════════════════════════════════════════════╝

from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from typing import List, Dict
from .sell_pricing import CoinSellPricing, Platform

class SellKeyboards:
    """أزرار ولوحات مفاتيح خدمة بيع الكوينز"""
    
    @staticmethod
    def get_main_sell_keyboard() -> InlineKeyboardMarkup:
        """لوحة المفاتيح الرئيسية لخدمة البيع"""
        keyboard = [
            [InlineKeyboardButton("🎮 PlayStation", callback_data="sell_platform_playstation")],
            [InlineKeyboardButton("🎮 Xbox", callback_data="sell_platform_xbox")],
            [InlineKeyboardButton("🖥️ PC", callback_data="sell_platform_pc")],
            [InlineKeyboardButton("❓ مساعدة", callback_data="sell_help"),
             InlineKeyboardButton("🔙 العودة", callback_data="sell_back_main")]
        ]
        return InlineKeyboardMarkup(keyboard)
    

    @staticmethod
    def get_price_confirmation_keyboard(platform: str, coins: int, price: int) -> InlineKeyboardMarkup:
        """لوحة تأكيد السعر"""
        keyboard = [
            [InlineKeyboardButton("✅ تأكيد البيع", callback_data=f"sell_confirm_{platform}_{coins}_{price}")],
            [InlineKeyboardButton("📝 إدخال كمية أخرى", callback_data=f"sell_platform_{platform}"),
             InlineKeyboardButton("🎮 تغيير المنصة", callback_data="sell_back_platforms")],
            [InlineKeyboardButton("🚫 إلغاء البيع", callback_data="sell_cancel")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_sale_instructions_keyboard(platform: str, coins: int) -> InlineKeyboardMarkup:
        """لوحة تعليمات البيع"""
        keyboard = [
            [InlineKeyboardButton("✅ فهمت التعليمات، متابعة", callback_data=f"sell_ready_{platform}_{coins}")],
            [InlineKeyboardButton("❓ أحتاج مساعدة", callback_data="sell_help_instructions")],
            [InlineKeyboardButton("🔙 العودة للسعر", callback_data=f"sell_back_price_{platform}_{coins}"),
             InlineKeyboardButton("🚫 إلغاء البيع", callback_data="sell_cancel")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_payment_method_keyboard() -> InlineKeyboardMarkup:
        """لوحة اختيار طريقة الدفع"""
        keyboard = [
            [InlineKeyboardButton("📱 فودافون كاش", callback_data="sell_payment_vodafone")],
            [InlineKeyboardButton("📱 اتصالات كاش", callback_data="sell_payment_etisalat")],
            [InlineKeyboardButton("📱 أورانج كاش", callback_data="sell_payment_orange")], 
            [InlineKeyboardButton("📱 وي كاش", callback_data="sell_payment_we")],
            [InlineKeyboardButton("💰 إنستاباي", callback_data="sell_payment_instapay")],
            [InlineKeyboardButton("🏦 تحويل بنكي", callback_data="sell_payment_bank")],
            [InlineKeyboardButton("🔙 العودة", callback_data="sell_back_instructions")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_sale_progress_keyboard() -> InlineKeyboardMarkup:
        """لوحة متابعة حالة البيع"""
        keyboard = [
            [InlineKeyboardButton("📊 حالة البيع", callback_data="sell_status")],
            [InlineKeyboardButton("📞 تواصل مع الدعم", callback_data="sell_support")],
            [InlineKeyboardButton("🚫 إلغاء البيع", callback_data="sell_cancel_confirm")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_sale_completed_keyboard() -> InlineKeyboardMarkup:
        """لوحة إتمام البيع"""
        keyboard = [
            [InlineKeyboardButton("💰 بيع المزيد من الكوينز", callback_data="sell_more")],
            [InlineKeyboardButton("📊 تقييم الخدمة", callback_data="sell_rate_service")],
            [InlineKeyboardButton("🏠 القائمة الرئيسية", callback_data="sell_main_menu")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_custom_amount_cancel_keyboard(platform: str) -> InlineKeyboardMarkup:
        """لوحة إلغاء الكمية المخصصة"""
        keyboard = [
            [InlineKeyboardButton("🔙 العودة لاختيار المنصة", callback_data="sell_back_platforms")],
            [InlineKeyboardButton("🎮 تغيير المنصة", callback_data="sell_back_platforms")],
            [InlineKeyboardButton("🚫 إلغاء البيع", callback_data="sell_cancel")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_help_keyboard() -> InlineKeyboardMarkup:
        """لوحة المساعدة"""
        keyboard = [
            [InlineKeyboardButton("📞 الدعم الفني", callback_data="sell_support")],
            [InlineKeyboardButton("💡 أسئلة شائعة", callback_data="sell_faq")],
            [InlineKeyboardButton("🔙 العودة للبيع", callback_data="sell_back_main")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_error_keyboard(error_type: str = "general") -> InlineKeyboardMarkup:
        """لوحة مفاتيح الأخطاء"""
        keyboard = [
            [InlineKeyboardButton("🔄 المحاولة مرة أخرى", callback_data="sell_retry")],
            [InlineKeyboardButton("📞 تواصل مع الدعم", callback_data="sell_support")],
            [InlineKeyboardButton("🏠 القائمة الرئيسية", callback_data="sell_main_menu")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @staticmethod
    def get_admin_sell_keyboard() -> InlineKeyboardMarkup:
        """لوحة إدارة البيع (للأدمن)"""
        keyboard = [
            [InlineKeyboardButton("📊 إحصائيات البيع", callback_data="admin_sell_stats")],
            [InlineKeyboardButton("💰 تحديث الأسعار", callback_data="admin_sell_prices")],
            [InlineKeyboardButton("📋 طلبات البيع النشطة", callback_data="admin_sell_active")],
            [InlineKeyboardButton("🔙 لوحة الإدارة", callback_data="admin_main")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @classmethod
    def get_quick_sell_keyboard(cls) -> InlineKeyboardMarkup:
        """لوحة البيع السريع للقائمة الرئيسية"""
        keyboard = [
            [InlineKeyboardButton("💰 بيع كوينز FIFA", callback_data="sell_start")]
        ]
        return InlineKeyboardMarkup(keyboard)
    
    @classmethod 
    def get_platform_comparison_keyboard(cls) -> InlineKeyboardMarkup:
        """لوحة مقارنة أسعار المنصات"""
        keyboard = [
            [InlineKeyboardButton("📊 مقارنة الأسعار", callback_data="sell_compare_prices")],
            [InlineKeyboardButton("🎮 PlayStation", callback_data="sell_platform_playstation"),
             InlineKeyboardButton("🎮 Xbox", callback_data="sell_platform_xbox")],
            [InlineKeyboardButton("🖥️ PC", callback_data="sell_platform_pc")],
            [InlineKeyboardButton("🔙 العودة", callback_data="sell_back_main")]
        ]
        return InlineKeyboardMarkup(keyboard)

    @classmethod
    def build_dynamic_keyboard(cls, buttons_data: List[Dict], rows: int = 2) -> InlineKeyboardMarkup:
        """بناء لوحة مفاتيح ديناميكية"""
        keyboard = []
        current_row = []
        
        for i, button in enumerate(buttons_data):
            current_row.append(InlineKeyboardButton(
                button['text'], 
                callback_data=button['callback_data']
            ))
            
            # إذا وصلنا لآخر عنصر في الصف أو آخر عنصر بشكل عام
            if len(current_row) == rows or i == len(buttons_data) - 1:
                keyboard.append(current_row)
                current_row = []
        
        return InlineKeyboardMarkup(keyboard)

--- FC26_sale_coins_Bot/services/sell_coins/sell_messages.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              💬 FC26 COIN SELLING MESSAGES - رسائل بيع الكوينز           ║
# ║                      Coin Selling Messages                               ║
# ╚══════════════════════════════════════════════════════════════════════════╝

from typing import Dict, List, Optional
from .sell_pricing import CoinSellPricing

class SellMessages:
    """رسائل خدمة بيع الكوينز"""
    
    @staticmethod
    def get_welcome_sell_message() -> str:
        """رسالة الترحيب بخدمة البيع"""
        return """💰 <b>مرحباً بك في خدمة بيع الكوينز FC26</b>

🎮 <b>نشتري كوينز FIFA من جميع المنصات:</b>
• PlayStation (PS4/PS5)
• Xbox (One/Series X|S)  
• PC (Origin/Steam/Epic)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
💡 <b>كيف تتم العملية؟</b>

1️⃣ اختر منصتك
2️⃣ حدد كمية الكوينز
3️⃣ اطلع على السعر
4️⃣ أكد البيع
5️⃣ استلم أموالك

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⭐ <b>مميزات خدمتنا:</b>
• 🚀 دفع فوري خلال دقائق
• 🛡️ ضمان آمن 100%
• 💎 أفضل الأسعار في السوق
• 📞 دعم فني على مدار الساعة

اختر منصتك للبدء 👇"""

    @staticmethod
    def get_platform_selection_message() -> str:
        """رسالة اختيار المنصة"""
        return """🎮 <b>اختر منصة اللعب:</b>

اختر المنصة اللي عندك عليها الكوينز:"""



    @staticmethod
    def get_custom_amount_message(platform: str) -> str:
        """رسالة طلب كمية مخصصة"""
        platform_name = CoinSellPricing.get_platform_display_name(platform)
        
        return f"""🎯 <b>كمية مخصصة - {platform_name}</b>

📝 <b>أدخل كمية الكوينز التي تريد بيعها:</b>

⚠️ <b>الشروط:</b>
• الحد الأدنى: 50,000 كوين  
• الحد الأقصى: 10,000,000 كوين
• يجب أن تكون من مضاعفات 10,000

💡 <b>أمثلة صحيحة:</b>
• 150000 (150K كوين)
• 750000 (750K كوين)  
• 1500000 (1.5M كوين)

❌ <b>أمثلة خاطئة:</b>
• 155000 (ليست من مضاعفات 10K)
• 25000 (أقل من الحد الأدنى)

اكتب الكمية بالأرقام فقط:"""

    @staticmethod
    def get_price_confirmation_message(platform: str, coins: int, price: int) -> str:
        """رسالة تأكيد السعر"""
        platform_name = CoinSellPricing.get_platform_display_name(platform)
        coins_display = CoinSellPricing._format_coins(coins)
        
        # معلومات إضافية
        discount_info = CoinSellPricing.get_discount_info(coins)
        discount_text = f"\n🎉 <b>{discount_info}</b>" if discount_info else ""
        
        return f"""💰 <b>تأكيد السعر</b>

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 <b>تفاصيل البيع:</b>

🎮 <b>المنصة:</b> {platform_name}
💎 <b>الكمية:</b> {coins_display} كوين
💰 <b>السعر:</b> <b>{price} جنيه مصري</b>{discount_text}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚡ <b>خطوات البيع:</b>

1️⃣ أكد البيع بالضغط على "تأكيد البيع"
2️⃣ ستحصل على تعليمات التسليم
3️⃣ سنراجع الكوينز في حسابك
4️⃣ ستستلم أموالك خلال 5-10 دقائق

🛡️ <b>ضمان آمن:</b> لا نأخذ الكوينز إلا بعد التأكد من صحتها

هل تريد المتابعة؟"""

    @staticmethod
    def get_sale_instructions_message(platform: str, coins: int) -> str:
        """رسالة تعليمات البيع"""
        platform_name = CoinSellPricing.get_platform_display_name(platform)
        coins_display = CoinSellPricing._format_coins(coins)
        
        return f"""📋 <b>تعليمات تسليم الكوينز</b>

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎮 <b>المنصة:</b> {platform_name}
💎 <b>الكمية:</b> {coins_display} كوين

🔹 <b>خطوات التسليم:</b>

1️⃣ <b>ادخل على FIFA Ultimate Team</b>
2️⃣ <b>اذهب إلى Transfer Market</b> 
3️⃣ <b>ضع لاعب رخيص للبيع بالسعر التالي:</b>
   💰 السعر: سنرسل لك السعر المحدد
   ⏰ المدة: 1 ساعة

4️⃣ <b>أرسل لنا:</b>
   • اسم اللاعب
   • السعر المطلوب
   • صورة من شاشة البيع

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚠️ <b>تنبيهات مهمة:</b>

• لا تضع اللاعب للبيع قبل موافقتنا
• تأكد من أن الكوينز متوفرة في حسابك
• لا تلعب FIFA أثناء عملية البيع

⏰ <b>وقت التسليم:</b> سنشتري اللاعب خلال 5 دقائق من التأكيد

هل أنت جاهز للبدء؟"""

    @staticmethod 
    def get_payment_info_message(payment_method: str) -> str:
        """رسالة معلومات الدفع"""
        return f"""💳 <b>معلومات الدفع</b>

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📱 <b>طريقة الدفع المختارة:</b> {payment_method}

⚡ <b>سرعة التحويل:</b>
• فودافون كاش: فوري (1-2 دقيقة)
• اتصالات كاش: فوري (1-2 دقيقة)  
• إنستاباي: فوري (1-3 دقائق)
• البنك: 5-15 دقيقة

🛡️ <b>الأمان:</b> جميع المعاملات مضمونة ومؤمنة

📞 <b>للاستفسار:</b> تواصل مع الدعم الفني في أي وقت"""

    @staticmethod
    def get_sale_completed_message(coins: int, price: int) -> str:
        """رسالة إتمام البيع"""
        coins_display = CoinSellPricing._format_coins(coins)
        
        return f"""✅ <b>تم إتمام البيع بنجاح!</b>

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎉 <b>تفاصيل البيع:</b>

💎 <b>الكوينز المباعة:</b> {coins_display} كوين
💰 <b>المبلغ المستلم:</b> {price} جنيه مصري
⏰ <b>وقت البيع:</b> الآن

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🙏 <b>شكراً لثقتك في FC26!</b>

⭐ هل كنت راضي عن الخدمة؟
📞 لأي استفسار تواصل معنا في أي وقت
🔄 نتطلع لخدمتك مرة أخرى!

💰 <b>هل تريد بيع المزيد من الكوينز؟</b>"""

    @staticmethod
    def get_error_message(error_type: str) -> str:
        """رسائل الأخطاء المختلفة"""
        error_messages = {
            'invalid_amount': """❌ <b>كمية غير صحيحة</b>

يرجى إدخال كمية صحيحة من الكوينز:
• الحد الأدنى: 50,000 كوين
• الحد الأقصى: 10,000,000 كوين  
• يجب أن تكون من مضاعفات 10,000

💡 مثال صحيح: 150000""",
            
            'invalid_platform': """❌ <b>منصة غير مدعومة</b>

المنصات المدعومة حالياً:
• PlayStation (PS4/PS5)
• Xbox (One/Series X|S)
• PC (Origin/Steam/Epic)""",
            
            'sale_cancelled': """🚫 <b>تم إلغاء البيع</b>

لا توجد مشكلة! يمكنك البدء مرة أخرى في أي وقت.
استخدم /sell للبدء من جديد.""",
            
            'system_error': """⚠️ <b>خطأ مؤقت</b>

حدث خطأ مؤقت في النظام.
يرجى المحاولة مرة أخرى خلال دقائق.

إذا استمر الخطأ، تواصل مع الدعم الفني."""
        }
        
        return error_messages.get(error_type, error_messages['system_error'])
    
    @staticmethod
    def get_help_message() -> str:
        """رسالة المساعدة لخدمة البيع"""
        return """❓ <b>مساعدة خدمة بيع الكوينز</b>

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🤔 <b>كيف تعمل الخدمة؟</b>

1️⃣ اختر منصتك (PlayStation/Xbox/PC)
2️⃣ حدد كمية الكوينز 
3️⃣ اطلع على السعر المقترح
4️⃣ أكد البيع واتبع التعليمات
5️⃣ استلم أموالك خلال دقائق

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
💡 <b>نصائح مهمة:</b>

• تأكد من وجود الكوينز في حسابك
• لا تلعب FIFA أثناء عملية البيع  
• اتبع التعليمات بدقة لضمان نجاح البيع
• احتفظ بصور لشاشات اللعبة

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📞 <b>الدعم الفني:</b>
متوفر 24/7 لمساعدتك في أي استفسار

استخدم /sell للبدء الآن!"""

--- FC26_sale_coins_Bot/services/sell_coins/sell_pricing.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              💰 FC26 COIN SELLING PRICING - نظام أسعار بيع الكوينز        ║
# ║                     Coin Selling Price Management                        ║
# ╚══════════════════════════════════════════════════════════════════════════╝

from typing import Dict, List, Optional, Tuple
from enum import Enum

# استيراد قاعدة بيانات الادمن للربط مع الأسعار
try:
    from database.admin_operations import AdminOperations
    DATABASE_AVAILABLE = True
except ImportError:
    DATABASE_AVAILABLE = False

class Platform(Enum):
    """منصات اللعب المدعومة"""
    PLAYSTATION = "playstation"
    XBOX = "xbox" 
    PC = "pc"

class CoinSellPricing:
    """إدارة أسعار بيع الكوينز"""
    
    # الأسعار العادية (التحويل خلال 24 ساعة) - أغلى من الفوري
    NORMAL_PRICES = {
        # PlayStation و Xbox نفس السعر
        Platform.PLAYSTATION.value: {
            1000000: 5600,  # 1M = 5600 ج.م (العادي - أغلى)
        },
        Platform.XBOX.value: {
            1000000: 5600,  # 1M = 5600 ج.م (العادي - أغلى)
        },
        # PC سعر منفصل (أغلى شوية)
        Platform.PC.value: {
            1000000: 6100,  # 1M = 6100 ج.م (العادي - أغلى)
        }
    }
    
    # الأسعار الفورية (التحويل خلال ساعة) - أرخص من العادي
    INSTANT_PRICES = {
        # PlayStation و Xbox نفس السعر
        Platform.PLAYSTATION.value: {
            1000000: 5300,  # 1M = 5300 ج.م (الفوري - أقل)
        },
        Platform.XBOX.value: {
            1000000: 5300,  # 1M = 5300 ج.م (الفوري - أقل)
        },
        # PC سعر منفصل (أغلى شوية)
        Platform.PC.value: {
            1000000: 5800,  # 1M = 5800 ج.م (الفوري - أقل)
        }
    }
    
    # للتوافق مع الكود القديم
    CURRENT_PRICES = NORMAL_PRICES
    

    @classmethod
    def get_price(cls, platform: str, coins: int, transfer_type: str = "normal") -> Optional[int]:
        """جلب السعر من قاعدة البيانات أولاً، ثم الكود كاحتياطي"""
        
        # محاولة جلب السعر من قاعدة البيانات الذكية أولاً
        if DATABASE_AVAILABLE:
            try:
                db_price = AdminOperations.get_price(platform, transfer_type, coins)
                if db_price is not None:
                    return db_price
            except Exception:
                pass  # في حالة الخطأ، استخدم الأسعار الافتراضية
        
        # في حالة عدم وجود السعر في قاعدة البيانات، استخدم القيم الافتراضية
        price_table = cls.INSTANT_PRICES if transfer_type == "instant" else cls.NORMAL_PRICES
        
        if platform not in price_table:
            return None
        
        return price_table[platform].get(coins)
    
    @classmethod
    def get_transfer_prices(cls, platform: str, coins: int) -> Dict[str, Optional[int]]:
        """جلب أسعار التحويل العادي والفوري لكمية معينة"""
        return {
            "normal": cls.get_price(platform, coins, "normal"),
            "instant": cls.get_price(platform, coins, "instant")
        }
    
    @classmethod
    def calculate_custom_price(cls, platform: str, coins: int) -> Optional[int]:
        """حساب السعر لكمية مخصصة من الكوينز"""
        if platform not in cls.CURRENT_PRICES:
            return None
        
        platform_prices = cls.CURRENT_PRICES[platform]
        
        # إذا كانت الكمية موجودة في الباقات المحددة
        if coins in platform_prices:
            return platform_prices[coins]
        
        # حساب السعر بناءً على أقرب كمية
        price_per_100k = cls._get_price_per_100k(platform)
        if price_per_100k:
            return int((coins / 100000) * price_per_100k)
        
        return None
    
    @classmethod
    def _get_price_per_100k(cls, platform: str) -> Optional[float]:
        """حساب سعر الـ 100k كوين للمنصة"""
        if platform not in cls.CURRENT_PRICES:
            return None
        
        # استخدام سعر الـ 100k كأساس
        return cls.CURRENT_PRICES[platform].get(100000, 150)
    
    @classmethod
    def _format_coins(cls, coins: int) -> str:
        """تنسيق عرض الكوينز"""
        if coins >= 1000000:
            millions = coins / 1000000
            if millions == int(millions):
                return f"{int(millions)}M"
            else:
                return f"{millions:.1f}M"
        elif coins >= 1000:
            thousands = coins / 1000
            if thousands == int(thousands):
                return f"{int(thousands)}K" 
            else:
                return f"{thousands:.0f}K"
        else:
            return str(coins)
    
    @classmethod
    def format_price(cls, price: int) -> Dict[str, str]:
        """تنسيق السعر بفاصلة عادية"""
        if not isinstance(price, (int, float)) or price <= 0:
            return {"egp": "0 ج.م"}
        
        price = int(price)
        
        # بالجنيه مع الفاصلة العادية
        formatted_egp = f"{price:,} ج.م"  # فاصلة عادية ","
        
        return {"egp": formatted_egp}
    
    @classmethod
    def get_platform_display_name(cls, platform: str) -> str:
        """جلب اسم المنصة للعرض"""
        platform_names = {
            Platform.PLAYSTATION.value: "🎮 PlayStation",
            Platform.XBOX.value: "🎮 Xbox", 
            Platform.PC.value: "🖥️ PC"
        }
        return platform_names.get(platform, platform)
    
    @classmethod
    def validate_coin_amount(cls, coins: int) -> Tuple[bool, str]:
        """التحقق من صحة كمية الكوينز"""
        if coins < 50000:
            return False, "❌ الحد الأدنى للبيع هو 50,000 كوين"
        
        if coins > 10000000:  # 10M max
            return False, "❌ الحد الأقصى للبيع هو 10,000,000 كوين"
        
        if coins % 10000 != 0:
            return False, "❌ يجب أن تكون الكمية من مضاعفات 10,000 كوين"
        
        return True, "✅ كمية صحيحة"
    
    @classmethod
    def get_discount_info(cls, coins: int) -> Optional[str]:
        """جلب معلومات الخصم إن وجد"""
        if coins >= 2000000:  # 2M+
            return "🎉 خصم خاص للكميات الكبيرة!"
        elif coins >= 1000000:  # 1M+
            return "💰 سعر مميز للمليون كوين!"
        elif coins >= 500000:  # 500K+
            return "⭐ عرض خاص للكميات المتوسطة!"
        
        return None
    
    @classmethod
    def get_all_platforms(cls) -> List[str]:
        """جلب جميع المنصات المدعومة"""
        return list(cls.CURRENT_PRICES.keys())
    
    @classmethod 
    def update_price(cls, platform: str, coins: int, new_price: int) -> bool:
        """تحديث سعر كمية معينة (للإدارة)"""
        if platform not in cls.CURRENT_PRICES:
            return False
        
        cls.CURRENT_PRICES[platform][coins] = new_price
        return True
    
    @classmethod
    def get_price_comparison(cls) -> Dict:
        """مقارنة الأسعار بين المنصات"""
        comparison = {}
        for platform in cls.NORMAL_PRICES:
            comparison[platform] = {
                "platform_name": cls.get_platform_display_name(platform),
                "normal_base_price": cls.NORMAL_PRICES[platform].get(100000, 0),
                "instant_base_price": cls.INSTANT_PRICES[platform].get(100000, 0),
                "price_tiers": len(cls.NORMAL_PRICES[platform])
            }
        
        return comparison
    
    @classmethod
    def get_platform_pricing_message(cls, platform: str) -> str:
        """رسالة أسعار مختصرة - 1M فقط - تجلب الأسعار من قاعدة البيانات"""
        if platform not in cls.NORMAL_PRICES:
            return "❌ منصة غير مدعومة"
        
        platform_name = cls.get_platform_display_name(platform)
        
        # جلب الأسعار من قاعدة البيانات (نفس طريقة الأزرار)
        normal_price_1m = cls.get_price(platform, 1000000, "normal")
        instant_price_1m = cls.get_price(platform, 1000000, "instant")
        
        normal_formatted = f"{normal_price_1m:,} ج.م" if normal_price_1m else "غير متاح"
        instant_formatted = f"{instant_price_1m:,} ج.م" if instant_price_1m else "غير متاح"
        
        return f"""✅ تم اختيار المنصة

💰 أسعار {platform_name}:

🔸 1M كوين:
   📅 عادي: {normal_formatted}
   ⚡️ فوري: {instant_formatted}


💡 ملاحظات:
📅 التحويل العادي: خلال 24 ساعة
⚡️ التحويل الفوري: خلال ساعة واحدة

🎯 اختر نوع التحويل:"""

--- FC26_sale_coins_Bot/services/service_template.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║                    🎯 SERVICE TEMPLATE - قالب الخدمات                    ║
# ║              Universal Template for Adding New Services                 ║
# ╚══════════════════════════════════════════════════════════════════════════╝

"""
Template لإضافة خدمة جديدة بدون تضارب نهائياً

📝 كيفية الاستخدام:
1. انسخ هذا الملف → `services/my_service.py`
2. غيّر اسم الـ Class → `MyService`
3. غيّر الـ States → حسب خدمتك
4. اكتب الـ handlers
5. سجّل في main.py

✅ مضمون 100% بدون تضارب!
"""

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import (
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
    ConversationHandler,
    MessageHandler,
    filters,
)

from database.operations import UserOperations
from utils.logger import log_user_action

# ═══════════════════════════════════════════════════════════════════════════
# STATES - حدد حالات خدمتك
# ═══════════════════════════════════════════════════════════════════════════

# مثال: خدمة شراء الكوينز
BUY_PLATFORM, BUY_AMOUNT, BUY_PAYMENT = range(3)


class BuyCoinsService:
    """
    مثال على خدمة جديدة - شراء الكوينز

    📝 لإنشاء خدمة جديدة:
    1. غيّر اسم الـ Class
    2. غيّر الـ States
    3. غيّر entry_points (/buy → /yourcommand)
    4. عدّل الـ handlers حسب احتياجك
    """

    # ═══════════════════════════════════════════════════════════════════════
    # ENTRY POINT - نقطة البداية
    # ═══════════════════════════════════════════════════════════════════════

    @staticmethod
    async def start_buy(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """
        نقطة البداية - /buy

        هنا تبدأ الخدمة عند كتابة الأمر
        """
        user_id = update.effective_user.id

        print(f"💰 [BUY] Service started for user {user_id}")
        log_user_action(user_id, "Started buy coins service")

        # التحقق من التسجيل (اختياري)
        user_data = UserOperations.get_user_data(user_id)
        if not user_data or user_data.get("registration_step") != "completed":
            await update.message.reply_text(
                "❌ <b>يجب إكمال التسجيل أولاً!</b>\n\n🚀 /start للتسجيل",
                parse_mode="HTML",
            )
            return ConversationHandler.END

        # عرض الخيارات الأولى
        keyboard = [
            [InlineKeyboardButton("🎮 PlayStation", callback_data="buy_ps")],
            [InlineKeyboardButton("🎮 Xbox", callback_data="buy_xbox")],
            [InlineKeyboardButton("🖥️ PC", callback_data="buy_pc")],
            [InlineKeyboardButton("❌ إلغاء", callback_data="buy_cancel")],
        ]

        await update.message.reply_text(
            "💰 <b>شراء الكوينز</b>\n\n🎮 اختر منصتك:",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="HTML",
        )

        return BUY_PLATFORM

    # ═══════════════════════════════════════════════════════════════════════
    # STATE HANDLERS - معالجات الحالات
    # ═══════════════════════════════════════════════════════════════════════

    @staticmethod
    async def choose_platform(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """الحالة الأولى - اختيار المنصة"""
        query = update.callback_query
        await query.answer()

        # معالجة الإلغاء
        if query.data == "buy_cancel":
            await query.edit_message_text("❌ تم إلغاء عملية الشراء")
            return ConversationHandler.END

        user_id = query.from_user.id
        platform = query.data.replace("buy_", "")

        # حفظ البيانات في context
        context.user_data["buy_platform"] = platform

        print(f"🎮 [BUY] User {user_id} selected: {platform}")
        log_user_action(user_id, f"Selected platform: {platform}")

        # الانتقال للحالة التالية
        await query.edit_message_text(
            f"✅ اخترت: {platform}\n\n💰 أدخل الكمية (بالأرقام):",
            parse_mode="HTML",
        )

        return BUY_AMOUNT

    @staticmethod
    async def enter_amount(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """الحالة الثانية - إدخال الكمية"""
        user_id = update.effective_user.id
        text = update.message.text.strip()

        # التحقق من المدخلات
        if not text.isdigit():
            await update.message.reply_text("❌ أرقام فقط! أعد المحاولة:")
            return BUY_AMOUNT

        amount = int(text)

        # التحقق من الحدود
        if amount < 100:
            await update.message.reply_text("❌ الحد الأدنى: 100 كوين\nأعد المحاولة:")
            return BUY_AMOUNT

        # حفظ البيانات
        context.user_data["buy_amount"] = amount

        print(f"💰 [BUY] User {user_id} amount: {amount}")

        # الانتقال للحالة التالية
        await update.message.reply_text(
            f"✅ الكمية: {amount:,} كوين\n\n💳 أدخل طريقة الدفع:",
            parse_mode="HTML",
        )

        return BUY_PAYMENT

    @staticmethod
    async def enter_payment(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """الحالة الثالثة (الأخيرة) - إدخال الدفع"""
        user_id = update.effective_user.id
        payment = update.message.text.strip()

        # جلب البيانات المحفوظة
        platform = context.user_data.get("buy_platform", "unknown")
        amount = context.user_data.get("buy_amount", 0)

        # حفظ البيانات (في قاعدة بيانات مثلاً)
        # YourDatabase.save_buy_order(user_id, platform, amount, payment)

        # رسالة النجاح
        await update.message.reply_text(
            f"✅ <b>تم تأكيد طلب الشراء!</b>\n\n"
            f"🎮 المنصة: {platform}\n"
            f"💰 الكمية: {amount:,} كوين\n"
            f"💳 الدفع: {payment}\n\n"
            f"📞 سيتم التواصل معك قريباً!\n\n"
            f"🔹 /buy للشراء مرة أخرى",
            parse_mode="HTML",
        )

        log_user_action(
            user_id,
            f"Completed buy order: {amount} coins, platform: {platform}",
        )

        # مسح البيانات
        context.user_data.clear()
        print(f"✅ [BUY] Order completed for user {user_id}")

        # إنهاء المحادثة
        return ConversationHandler.END

    # ═══════════════════════════════════════════════════════════════════════
    # FALLBACKS - معالجات الإلغاء
    # ═══════════════════════════════════════════════════════════════════════

    @staticmethod
    async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """إلغاء العملية في أي وقت - /cancel"""
        user_id = update.effective_user.id

        print(f"❌ [BUY] User {user_id} cancelled")
        log_user_action(user_id, "Cancelled buy service")

        await update.message.reply_text(
            "❌ تم إلغاء عملية الشراء\n\n🔹 /buy للبدء من جديد"
        )

        context.user_data.clear()
        return ConversationHandler.END

    # ═══════════════════════════════════════════════════════════════════════
    # CONVERSATION HANDLER - التسجيل
    # ═══════════════════════════════════════════════════════════════════════

    @staticmethod
    def get_conversation_handler():
        """
        إنشاء ConversationHandler للخدمة

        📝 هذا هو الجزء الوحيد اللي هتسجله في main.py
        """
        return ConversationHandler(
            # نقطة البداية - الأمر اللي يبدأ الخدمة
            entry_points=[CommandHandler("buy", BuyCoinsService.start_buy)],
            # الحالات - كل حالة ليها handlers خاصة
            states={
                BUY_PLATFORM: [
                    CallbackQueryHandler(
                        BuyCoinsService.choose_platform,
                        pattern="^buy_",  # فقط callbacks تبدأ بـ buy_
                    )
                ],
                BUY_AMOUNT: [
                    MessageHandler(
                        filters.TEXT & ~filters.COMMAND,
                        BuyCoinsService.enter_amount,
                    )
                ],
                BUY_PAYMENT: [
                    MessageHandler(
                        filters.TEXT & ~filters.COMMAND,
                        BuyCoinsService.enter_payment,
                    )
                ],
            },
            # معالجات الإلغاء - تشتغل في أي حالة
            fallbacks=[CommandHandler("cancel", BuyCoinsService.cancel)],
            # اسم فريد للخدمة
            name="buy_coins_conversation",
            # حفظ الحالة (True = يحفظ الحالة حتى لو البوت توقف)
            persistent=False,
        )


# ═══════════════════════════════════════════════════════════════════════════
# كيفية التسجيل في main.py:
# ═══════════════════════════════════════════════════════════════════════════
"""
في ملف main.py، في method start_bot():

# 1. استورد الخدمة
from services.service_template import BuyCoinsService

# 2. سجّل الـ conversation
buy_conv = BuyCoinsService.get_conversation_handler()
self.app.add_handler(buy_conv)
print("✅ [4] Buy coins conversation registered")

✅ خلاص! مافيش تضارب أبداً!
"""


--- FC26_sale_coins_Bot/states/__init__.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║                 🎯 FC26 STATES - حالات البوت المختلفة                    ║
# ║                           Bot States Package                             ║
# ╚══════════════════════════════════════════════════════════════════════════╝

from .sell_states import SellStates

__all__ = ['SellStates']

--- FC26_sale_coins_Bot/states/sell_states.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║                🎯 FC26 SELL STATES - حالات بيع الكوينز                  ║
# ║                       Sell Conversation States                          ║
# ╚══════════════════════════════════════════════════════════════════════════╝

class SellStates:
    """حالات محادثة بيع الكوينز"""
    CHOOSE_PLATFORM = "choose_platform"
    CHOOSE_TYPE = "choose_type"
    ENTER_AMOUNT = "enter_amount"
    CONFIRM_SALE = "confirm_sale"

--- FC26_sale_coins_Bot/utils/__init__.py ---



--- FC26_sale_coins_Bot/utils/backup_job.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║                    💾 BACKUP JOB SYSTEM                                  ║
# ║                  نظام النسخ الاحتياطي التلقائي                          ║
# ║            حماية بيانات الجلسات من الفقدان                             ║
# ╚══════════════════════════════════════════════════════════════════════════╝

"""
💾 نظام النسخ الاحتياطي اليومي

الهدف:
-------
إنشاء نسخ احتياطية دورية من ملف الجلسات كطبقة أمان إضافية.

الميزات:
--------
✅ نسخ احتياطي يومي في وقت محدد (3 صباحاً)
✅ نسخ احتياطي عند بدء التشغيل (بعد ساعة)
✅ حذف تلقائي للنسخ القديمة (أكثر من 7 أيام)
✅ تنظيم في مجلد data/backups/
"""

import shutil
from datetime import datetime, timedelta, time
from pathlib import Path


async def daily_backup_job(context):
    """
    وظيفة النسخ الاحتياطي اليومي

    تقوم بـ:
    1. نسخ ملف الجلسات الرئيسي
    2. حفظه في مجلد backups/ باسم يحتوي على التاريخ
    3. حذف النسخ الأقدم من 7 أيام

    Args:
        context: telegram.ext.ContextTypes.DEFAULT_TYPE
    """
    print(f"\n{'='*80}")
    print(f"💾 [BACKUP-JOB] Starting daily backup...")
    print(f"{'='*80}")

    # التحقق من وجود الملف الأصلي
    source = Path("data/sessions.pkl")
    if not source.exists():
        print(f"   ⚠️ [BACKUP-JOB] Source file not found: {source}")
        print(f"{'='*80}\n")
        return

    # إنشاء مجلد النسخ الاحتياطي
    backup_dir = Path("data/backups")
    backup_dir.mkdir(parents=True, exist_ok=True)
    print(f"   ✅ [BACKUP-JOB] Backup directory ready: {backup_dir}")

    # إنشاء اسم الملف بالتاريخ
    today = datetime.now().strftime("%Y%m%d")
    backup_path = backup_dir / f"sessions_{today}.pkl"

    try:
        # نسخ الملف
        shutil.copy2(source, backup_path)
        size_mb = backup_path.stat().st_size / (1024 * 1024)
        print(
            f"   ✅ [BACKUP-JOB] Backup created: {backup_path.name} ({size_mb:.2f} MB)"
        )
    except Exception as e:
        print(f"   ❌ [BACKUP-JOB] Failed to create backup: {e}")
        print(f"{'='*80}\n")
        return

    # حذف النسخ القديمة
    print(f"   🧹 [BACKUP-JOB] Cleaning old backups...")
    cutoff = datetime.now() - timedelta(days=7)
    deleted_count = 0

    for backup_file in backup_dir.glob("sessions_*.pkl"):
        try:
            # استخراج التاريخ من اسم الملف
            date_str = backup_file.stem.split("_")[1]
            file_date = datetime.strptime(date_str, "%Y%m%d")

            # حذف إذا كان أقدم من 7 أيام
            if file_date < cutoff:
                backup_file.unlink()
                deleted_count += 1
                print(f"      🗑️ Deleted old backup: {backup_file.name}")
        except Exception as e:
            print(f"      ⚠️ Error processing {backup_file.name}: {e}")

    if deleted_count == 0:
        print(f"      ✅ No old backups to delete")
    else:
        print(f"      ✅ Deleted {deleted_count} old backup(s)")

    print(f"{'='*80}")
    print(f"✅ [BACKUP-JOB] Daily backup completed successfully")
    print(f"{'='*80}\n")


def register_backup_job(app):
    """
    تسجيل وظائف النسخ الاحتياطي في الجدول الزمني

    يقوم بتسجيل:
    1. نسخ احتياطي يومي في الساعة 3 صباحاً
    2. نسخ احتياطي عند بدء التشغيل (بعد ساعة)

    Args:
        app: telegram.ext.Application
    """
    print("\n💾 [BACKUP-SYSTEM] Registering backup jobs...")

    # نسخ احتياطي يومي في 3 صباحاً
    app.job_queue.run_daily(
        daily_backup_job,
        time=time(hour=3, minute=0),
        name="daily_backup",
    )
    print("   ✅ Daily backup scheduled: 03:00 AM")

    # نسخ احتياطي بعد ساعة من البدء (احترازي)
    app.job_queue.run_once(
        daily_backup_job,
        when=3600,  # 1 ساعة بالثواني
        name="startup_backup",
    )
    print("   ✅ Startup backup scheduled: 1 hour after start")

    print("💾 [BACKUP-SYSTEM] Backup jobs registered successfully\n")


# ═══════════════════════════════════════════════════════════════════════════
# 🛠️ UTILITY FUNCTIONS (إضافية)
# ═══════════════════════════════════════════════════════════════════════════


def list_backups() -> list:
    """
    عرض قائمة بجميع النسخ الاحتياطية الموجودة

    Returns:
        list: قائمة بأسماء الملفات وأحجامها
    """
    backup_dir = Path("data/backups")
    if not backup_dir.exists():
        return []

    backups = []
    for backup_file in sorted(backup_dir.glob("sessions_*.pkl"), reverse=True):
        size_mb = backup_file.stat().st_size / (1024 * 1024)
        backups.append(
            {
                "name": backup_file.name,
                "date": backup_file.stem.split("_")[1],
                "size_mb": round(size_mb, 2),
            }
        )

    return backups


def restore_from_backup(backup_name: str) -> bool:
    """
    استعادة من نسخة احتياطية

    Args:
        backup_name: اسم ملف النسخة الاحتياطية

    Returns:
        bool: True إذا نجحت العملية

    ⚠️ تحذير: هذه الدالة خطيرة! تُستخدم فقط في حالات الطوارئ
    """
    backup_file = Path("data/backups") / backup_name
    if not backup_file.exists():
        print(f"❌ Backup file not found: {backup_name}")
        return False

    session_file = Path("data/sessions.pkl")

    try:
        # إنشاء نسخة احتياطية من الملف الحالي أولاً
        if session_file.exists():
            emergency_backup = Path("data/sessions_emergency_backup.pkl")
            shutil.copy2(session_file, emergency_backup)
            print(f"   💾 Emergency backup created: {emergency_backup.name}")

        # استعادة من النسخة الاحتياطية
        shutil.copy2(backup_file, session_file)
        print(f"   ✅ Restored from: {backup_name}")
        return True

    except Exception as e:
        print(f"   ❌ Restore failed: {e}")
        return False


--- FC26_sale_coins_Bot/utils/handler_filters.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║                   🎯 SMART FILTERS - منع التضارب الكامل                 ║
# ║              Handler Conflict Prevention - Zero Overlaps                ║
# ╚══════════════════════════════════════════════════════════════════════════╝

"""
فلاتر ذكية لمنع تضارب الـ handlers تماماً

الاستراتيجية:
- كل handler بيشوف رسائله فقط
- الفلاتر بترفض بسرعة لو الرسالة مش ليها
- صفر manual checks داخل الـ handlers
"""

from telegram.ext import filters


class AdminSessionFilter(filters.MessageFilter):
    """
    فلتر الأدمن - يقبل فقط:
    - رسائل من الأدمن
    - الأدمن عنده session نشط
    - الـ session في خطوة "waiting_price"
    """

    def __init__(self, admin_handler):
        """
        Args:
            admin_handler: مرجع لـ AdminHandler instance
        """
        self.admin_handler = admin_handler
        super().__init__()

    def filter(self, message):
        """
        Returns:
            True: رسالة من أدمن مع session نشط
            False: أي حالة تانية (silent rejection)
        """
        # لو مافيش admin handler أصلاً
        if not self.admin_handler:
            return False

        user_id = message.from_user.id

        # 1. هل المستخدم admin؟
        if user_id != self.admin_handler.ADMIN_ID:
            return False

        # 2. هل عنده session نشط؟
        if user_id not in self.admin_handler.user_sessions:
            return False

        # 3. هل الـ session في الخطوة الصحيحة؟
        session = self.admin_handler.user_sessions[user_id]
        if session.get("step") != "waiting_price":
            return False

        # ✅ كل الشروط تمام - قبول!
        print(f"✅ [ADMIN-FILTER] Admin {user_id} session active → ACCEPT")
        return True


class SellSessionFilter(filters.MessageFilter):
    """
    فلتر البيع - يقبل فقط:
    - مستخدمين عندهم sell session نشط
    - الـ session في خطوة إدخال الكمية
    """

    def __init__(self, sell_handler):
        """
        Args:
            sell_handler: مرجع لـ SellCoinsHandler instance
        """
        self.sell_handler = sell_handler
        super().__init__()

    def filter(self, message):
        """
        Returns:
            True: مستخدم مع sell session نشط
            False: أي حالة تانية (silent rejection)
        """
        user_id = message.from_user.id

        # 1. هل عنده sell session؟
        if user_id not in self.sell_handler.user_sessions:
            return False

        # 2. هل الـ session في خطوة إدخال الكمية؟
        session = self.sell_handler.user_sessions[user_id]
        step = session.get("step")

        valid_steps = ["amount_input", "custom_amount_input"]
        if step not in valid_steps:
            return False

        # ✅ عنده session نشط - قبول!
        print(
            f"✅ [SELL-FILTER] User {user_id} sell session active (step: {step}) → ACCEPT"
        )
        return True


class RegistrationFilter(filters.MessageFilter):
    """
    فلتر التسجيل - يقبل فقط:
    - مستخدمين بدون أي sessions أخرى (admin/sell)
    - للتسجيل العادي فقط
    """

    def __init__(self, admin_handler, sell_handler):
        """
        Args:
            admin_handler: مرجع لـ AdminHandler instance
            sell_handler: مرجع لـ SellCoinsHandler instance
        """
        self.admin_handler = admin_handler
        self.sell_handler = sell_handler
        super().__init__()

    def filter(self, message):
        """
        Returns:
            True: مستخدم بدون أي sessions نشطة
            False: عنده session في خدمة تانية
        """
        user_id = message.from_user.id

        # 1. تحقق من admin session
        if self.admin_handler and user_id in self.admin_handler.user_sessions:
            print(f"⏭️ [REG-FILTER] User {user_id} has admin session → REJECT")
            return False

        # 2. تحقق من sell session
        if user_id in self.sell_handler.user_sessions:
            print(f"⏭️ [REG-FILTER] User {user_id} has sell session → REJECT")
            return False

        # ✅ مافيش sessions تانية - قبول!
        print(f"✅ [REG-FILTER] User {user_id} clean (no sessions) → ACCEPT")
        return True


# ═══════════════════════════════════════════════════════════════════════════
# FACTORY FUNCTIONS - لإنشاء الفلاتر بسهولة
# ═══════════════════════════════════════════════════════════════════════════


class HandlerFilters:
    """Factory class لإنشاء الفلاتر الذكية"""

    @staticmethod
    def create_admin_filter(admin_handler):
        """إنشاء فلتر الأدمن"""
        return AdminSessionFilter(admin_handler)

    @staticmethod
    def create_sell_filter(sell_handler):
        """إنشاء فلتر البيع"""
        return SellSessionFilter(sell_handler)

    @staticmethod
    def create_registration_filter(admin_handler, sell_handler):
        """إنشاء فلتر التسجيل"""
        return RegistrationFilter(admin_handler, sell_handler)


--- FC26_sale_coins_Bot/utils/locks.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              🔒 FC26 LOCKS - نظام الأقفال والحماية من التضارب             ║
# ║                      Anti-Conflict Lock System                          ║
# ╚══════════════════════════════════════════════════════════════════════════╝

import asyncio
import time
import logging
from typing import Dict, Any, Optional
from contextlib import asynccontextmanager
from collections import defaultdict

logger = logging.getLogger(__name__)

class UserLockManager:
    """User-specific lock manager to prevent conflicts"""
    
    def __init__(self):
        self.user_locks: Dict[int, asyncio.Lock] = {}
        self.lock_times: Dict[int, float] = {}
        self.lock_counts: Dict[int, int] = defaultdict(int)
        self.active_operations: Dict[int, str] = {}
    
    async def get_user_lock(self, user_id: int) -> asyncio.Lock:
        """Get or create user-specific lock"""
        if user_id not in self.user_locks:
            self.user_locks[user_id] = asyncio.Lock()
            logger.debug(f"🔒 Created new lock for user {user_id}")
        
        return self.user_locks[user_id]
    
    @asynccontextmanager
    async def acquire_user_lock(self, user_id: int, operation: str = "unknown"):
        """Context manager for acquiring user locks"""
        lock = await self.get_user_lock(user_id)
        
        # Check if user is already performing an operation
        if user_id in self.active_operations:
            current_op = self.active_operations[user_id]
            logger.warning(f"⚠️ User {user_id} attempted {operation} while {current_op} is active")
            raise UserBusyException(f"User is currently performing: {current_op}")
        
        start_time = time.time()
        
        try:
            # Acquire lock with timeout
            await asyncio.wait_for(lock.acquire(), timeout=30.0)
            
            # Record operation start
            self.lock_times[user_id] = start_time
            self.lock_counts[user_id] += 1
            self.active_operations[user_id] = operation
            
            logger.debug(f"🔓 Lock acquired for user {user_id} - operation: {operation}")
            
            yield lock
            
        except asyncio.TimeoutError:
            logger.error(f"⏰ Lock acquisition timeout for user {user_id}")
            raise LockTimeoutException(f"Could not acquire lock for user {user_id}")
        
        finally:
            # Release lock and clean up
            if lock.locked():
                lock.release()
            
            # Record operation end
            if user_id in self.active_operations:
                del self.active_operations[user_id]
            
            end_time = time.time()
            duration = end_time - start_time
            
            logger.debug(f"🔒 Lock released for user {user_id} - duration: {duration:.2f}s")
    
    def is_user_busy(self, user_id: int) -> bool:
        """Check if user is currently performing an operation"""
        return user_id in self.active_operations
    
    def get_user_operation(self, user_id: int) -> Optional[str]:
        """Get current operation for user"""
        return self.active_operations.get(user_id)
    
    def cleanup_user_locks(self, inactive_minutes: int = 30):
        """Clean up inactive user locks"""
        current_time = time.time()
        inactive_threshold = inactive_minutes * 60
        
        users_to_cleanup = []
        
        for user_id, lock_time in self.lock_times.items():
            if current_time - lock_time > inactive_threshold:
                if user_id not in self.active_operations:
                    users_to_cleanup.append(user_id)
        
        for user_id in users_to_cleanup:
            if user_id in self.user_locks:
                del self.user_locks[user_id]
            if user_id in self.lock_times:
                del self.lock_times[user_id]
            if user_id in self.lock_counts:
                del self.lock_counts[user_id]
            
            logger.info(f"🧹 Cleaned up inactive lock for user {user_id}")
        
        return len(users_to_cleanup)
    
    def get_lock_statistics(self) -> Dict[str, Any]:
        """Get lock usage statistics"""
        return {
            'active_locks': len(self.active_operations),
            'total_locks_created': len(self.user_locks),
            'lock_usage_counts': dict(self.lock_counts),
            'active_operations': dict(self.active_operations)
        }

class MessageLockManager:
    """Message-specific lock manager for preventing message conflicts"""
    
    def __init__(self):
        self.active_messages: Dict[int, int] = {}  # user_id -> message_id
        self.message_locks: Dict[int, asyncio.Lock] = {}
    
    async def set_active_message(self, user_id: int, message_id: int):
        """Set active message for user"""
        async with await self._get_message_lock(user_id):
            old_message_id = self.active_messages.get(user_id)
            self.active_messages[user_id] = message_id
            
            logger.debug(f"📱 Active message updated for user {user_id}: {old_message_id} -> {message_id}")
            
            return old_message_id
    
    async def get_active_message(self, user_id: int) -> Optional[int]:
        """Get active message ID for user"""
        return self.active_messages.get(user_id)
    
    async def clear_active_message(self, user_id: int) -> Optional[int]:
        """Clear active message for user"""
        async with await self._get_message_lock(user_id):
            old_message_id = self.active_messages.pop(user_id, None)
            logger.debug(f"🗑️ Cleared active message for user {user_id}: {old_message_id}")
            return old_message_id
    
    async def _get_message_lock(self, user_id: int) -> asyncio.Lock:
        """Get message lock for user"""
        if user_id not in self.message_locks:
            self.message_locks[user_id] = asyncio.Lock()
        return self.message_locks[user_id]

class RateLimitManager:
    """Rate limiting manager to prevent spam and abuse"""
    
    def __init__(self, max_requests: int = 10, time_window: int = 60):
        self.max_requests = max_requests
        self.time_window = time_window
        self.user_requests: Dict[int, list] = defaultdict(list)
    
    def is_rate_limited(self, user_id: int) -> bool:
        """Check if user is rate limited"""
        current_time = time.time()
        
        # Clean old requests
        self.user_requests[user_id] = [
            req_time for req_time in self.user_requests[user_id]
            if current_time - req_time < self.time_window
        ]
        
        # Check rate limit
        if len(self.user_requests[user_id]) >= self.max_requests:
            logger.warning(f"🚫 Rate limit exceeded for user {user_id}")
            return True
        
        # Record new request
        self.user_requests[user_id].append(current_time)
        return False
    
    def get_remaining_requests(self, user_id: int) -> int:
        """Get remaining requests for user"""
        current_requests = len(self.user_requests[user_id])
        return max(0, self.max_requests - current_requests)

# Custom Exceptions
class UserBusyException(Exception):
    """Raised when user is busy with another operation"""
    pass

class LockTimeoutException(Exception):
    """Raised when lock acquisition times out"""
    pass

# Global instances
user_lock_manager = UserLockManager()
message_lock_manager = MessageLockManager()
rate_limit_manager = RateLimitManager()

# Convenience functions
async def get_user_lock(user_id: int) -> asyncio.Lock:
    """Get user lock - backwards compatibility"""
    return await user_lock_manager.get_user_lock(user_id)

async def acquire_user_lock(user_id: int, operation: str = "unknown"):
    """Acquire user lock with context manager"""
    return user_lock_manager.acquire_user_lock(user_id, operation)

def is_user_busy(user_id: int) -> bool:
    """Check if user is busy"""
    return user_lock_manager.is_user_busy(user_id)

def is_rate_limited(user_id: int) -> bool:
    """Check rate limit"""
    return rate_limit_manager.is_rate_limited(user_id)

--- FC26_sale_coins_Bot/utils/logger.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              📝 FC26 LOGGER - نظام السجلات                               ║
# ║                         Logging System                                  ║
# ╚══════════════════════════════════════════════════════════════════════════╝

import logging
import os
from logging.handlers import RotatingFileHandler, TimedRotatingFileHandler
from datetime import datetime
from config import LOGGING_CONFIG

class FC26Logger:
    """Enhanced logging system for FC26 Bot"""
    
    def __init__(self):
        self.logger = None
        self.setup_logger()
    
    def setup_logger(self):
        """Setup comprehensive logging system"""
        
        # Create logs directory if it doesn't exist
        log_dir = os.path.dirname(LOGGING_CONFIG['file'])
        os.makedirs(log_dir, exist_ok=True)
        
        # Create logger
        self.logger = logging.getLogger('FC26_Bot')
        self.logger.setLevel(getattr(logging, LOGGING_CONFIG['level']))
        
        # Clear existing handlers
        self.logger.handlers.clear()
        
        # Console handler only (no file logging)
        console_handler = logging.StreamHandler()
        console_handler.setLevel(logging.INFO)
        
        # Formatter
        formatter = logging.Formatter(
            LOGGING_CONFIG['format'],
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        
        # Set formatters
        console_handler.setFormatter(formatter)
        
        # Add handlers
        self.logger.addHandler(console_handler)
        
        # Initial log
        self.logger.info("🚀 FC26 Bot Logger initialized successfully")
    
    def log_user_action(self, user_id: int, action: str, details: str = None):
        """Log user actions"""
        log_message = f"👤 User {user_id}: {action}"
        if details:
            log_message += f" | Details: {details}"
        self.logger.info(log_message)
    
    def log_registration_step(self, user_id: int, step: str, success: bool = True):
        """Log registration steps"""
        status = "✅" if success else "❌"
        self.logger.info(f"{status} User {user_id} registration step: {step}")
    
    def log_validation_error(self, user_id: int, field: str, error: str):
        """Log validation errors"""
        self.logger.warning(f"⚠️ Validation error - User {user_id}, Field: {field}, Error: {error}")
    
    def log_database_operation(self, operation: str, user_id: int = None, success: bool = True):
        """Log database operations"""
        status = "✅" if success else "❌"
        user_info = f"User {user_id}" if user_id else "System"
        self.logger.info(f"{status} DB Operation: {operation} | {user_info}")
    
    def log_security_event(self, user_id: int, event: str, details: str = None):
        """Log security-related events"""
        log_message = f"🛡️ SECURITY: User {user_id} - {event}"
        if details:
            log_message += f" | Details: {details}"
        self.logger.warning(log_message)
    
    def log_performance_metric(self, operation: str, duration: float, user_id: int = None):
        """Log performance metrics"""
        user_info = f"User {user_id}" if user_id else "System"
        self.logger.info(f"📊 Performance: {operation} took {duration:.2f}s | {user_info}")
    
    def log_bot_start(self):
        """Log bot startup"""
        self.logger.info("="*60)
        self.logger.info("🎮 FC26 Gaming Bot Starting...")
        self.logger.info(f"⏰ Start Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        self.logger.info("="*60)
    
    def log_bot_stop(self):
        """Log bot shutdown"""
        self.logger.info("="*60)
        self.logger.info("🔴 FC26 Gaming Bot Shutting Down...")
        self.logger.info(f"⏰ Stop Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        self.logger.info("="*60)
    
    def log_error_with_context(self, error: Exception, context: str, user_id: int = None):
        """Log errors with context"""
        user_info = f" | User {user_id}" if user_id else ""
        self.logger.error(f"❌ Error in {context}: {str(error)}{user_info}", exc_info=True)
    
    def get_logger(self):
        """Get the logger instance"""
        return self.logger

# Global logger instance
fc26_logger = FC26Logger()
logger = fc26_logger.get_logger()

# Convenience functions for easy logging
def log_user_action(user_id: int, action: str, details: str = None):
    fc26_logger.log_user_action(user_id, action, details)

def log_registration_step(user_id: int, step: str, success: bool = True):
    fc26_logger.log_registration_step(user_id, step, success)

def log_validation_error(user_id: int, field: str, error: str):
    fc26_logger.log_validation_error(user_id, field, error)

def log_database_operation(operation: str, user_id: int = None, success: bool = True):
    fc26_logger.log_database_operation(operation, user_id, success)

def log_security_event(user_id: int, event: str, details: str = None):
    fc26_logger.log_security_event(user_id, event, details)

def log_performance_metric(operation: str, duration: float, user_id: int = None):
    fc26_logger.log_performance_metric(operation, duration, user_id)

def log_error_with_context(error: Exception, context: str, user_id: int = None):
    fc26_logger.log_error_with_context(error, context, user_id)

--- FC26_sale_coins_Bot/utils/message_tagger.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║                    🏷️ MESSAGE TAGGING SYSTEM                            ║
# ║                  نظام وسم الرسائل الموحد                                ║
# ║            منع الردود المزدوجة - Zero Duplicate Responses              ║
# ╚══════════════════════════════════════════════════════════════════════════╝

"""
🏷️ نظام وسم الرسائل الموحد
Unified Message Tagging System

الهدف:
-------
منع الردود المزدوجة عن طريق وسم الرسائل التي تمت معالجتها داخل ConversationHandler
حتى لا يتدخل global_recovery_router ويرسل رداً ثانياً.

الاستخدام:
----------
في بداية كل handler:
    MessageTagger.mark_as_handled(context)

في global_recovery_router:
    if MessageTagger.check_and_clear(context):
        return  # الرسالة معالجة مسبقاً - تجاهلها

الميزات:
--------
✅ كود موحد في مكان واحد
✅ سهل الصيانة
✅ تنظيف تلقائي للذاكرة
✅ طباعة تتبع واضحة
"""

from functools import wraps


class MessageTagger:
    """
    نظام وسم الرسائل لمنع الردود المزدوجة

    يستخدم chat_data لتخزين علامة "_update_handled"
    التي تشير إلى أن الرسالة تمت معالجتها من قبل handler معين
    """

    TAG_KEY = "_update_handled"

    @staticmethod
    def mark_as_handled(context) -> None:
        """
        وضع علامة على الرسالة أنها تمت معالجتها

        Args:
            context: telegram.ext.ContextTypes.DEFAULT_TYPE

        Usage:
            @handler
            async def my_handler(update, context):
                MessageTagger.mark_as_handled(context)
                # ... باقي الكود
        """
        context.chat_data[MessageTagger.TAG_KEY] = True
        print(f"   🏷️ [TAGGER] Message marked as handled")

    @staticmethod
    def is_handled(context) -> bool:
        """
        التحقق من وجود علامة المعالجة

        Args:
            context: telegram.ext.ContextTypes.DEFAULT_TYPE

        Returns:
            bool: True إذا تمت معالجة الرسالة مسبقاً

        Usage:
            if MessageTagger.is_handled(context):
                return  # تجاهل الرسالة
        """
        return context.chat_data.get(MessageTagger.TAG_KEY, False)

    @staticmethod
    def clear_tag(context) -> None:
        """
        مسح علامة المعالجة (تنظيف الذاكرة)

        Args:
            context: telegram.ext.ContextTypes.DEFAULT_TYPE

        Usage:
            MessageTagger.clear_tag(context)
        """
        if MessageTagger.TAG_KEY in context.chat_data:
            context.chat_data.pop(MessageTagger.TAG_KEY)
            print(f"   🧹 [TAGGER] Tag cleared")

    @staticmethod
    def check_and_clear(context) -> bool:
        """
        فحص ومسح العلامة في خطوة واحدة (للأداء)

        Args:
            context: telegram.ext.ContextTypes.DEFAULT_TYPE

        Returns:
            bool: True إذا كانت الرسالة معالجة سابقاً

        Usage:
            في global_recovery_router:

            if MessageTagger.check_and_clear(context):
                print("رسالة معالجة - تجاهل")
                return
        """
        is_handled = MessageTagger.is_handled(context)

        if is_handled:
            MessageTagger.clear_tag(context)
            print(f"   🏷️ [TAGGER] Message already handled")
            print(f"   ⏭️ [TAGGER] Skipping to prevent duplicate response")
            print(f"   🧹 [TAGGER] Tag cleared - ready for next message")
            return True

        return False


# ═══════════════════════════════════════════════════════════════════════════
# 🎁 BONUS: AUTO-TAG DECORATOR (اختياري - للمطورين المتقدمين)
# ═══════════════════════════════════════════════════════════════════════════


def auto_tag_handler(func):
    """
    Decorator لوسم الرسائل تلقائياً

    يوفر عليك استدعاء MessageTagger.mark_as_handled() يدوياً

    Usage:
    ------
    @auto_tag_handler
    async def my_handler(update, context):
        # الوسم يحدث تلقائياً!
        user_id = update.effective_user.id
        # ... باقي الكود

    ⚠️ ملاحظة:
    ----------
    استخدام الـ decorator اختياري.
    الطريقة اليدوية (mark_as_handled) أوضح وأسهل للمبتدئين.
    """

    @wraps(func)
    async def wrapper(update, context, *args, **kwargs):
        # وسم تلقائي قبل تنفيذ الـ handler
        MessageTagger.mark_as_handled(context)

        # تنفيذ الـ handler الأصلي
        return await func(update, context, *args, **kwargs)

    return wrapper


# ═══════════════════════════════════════════════════════════════════════════
# 📊 STATISTICS & DEBUGGING (اختياري)
# ═══════════════════════════════════════════════════════════════════════════


class MessageTaggerStats:
    """
    إحصائيات نظام الوسم (للمراقبة والتطوير)

    يمكن استخدامها لتتبع أداء النظام وكشف المشاكل
    """

    _tags_created = 0
    _tags_checked = 0
    _duplicates_prevented = 0

    @classmethod
    def increment_created(cls):
        """عداد الوسوم المنشأة"""
        cls._tags_created += 1

    @classmethod
    def increment_checked(cls):
        """عداد الفحوصات"""
        cls._tags_checked += 1

    @classmethod
    def increment_prevented(cls):
        """عداد الردود المزدوجة المنعة"""
        cls._duplicates_prevented += 1

    @classmethod
    def get_stats(cls) -> dict:
        """الحصول على الإحصائيات"""
        return {
            "tags_created": cls._tags_created,
            "tags_checked": cls._tags_checked,
            "duplicates_prevented": cls._duplicates_prevented,
            "efficiency": (
                f"{(cls._duplicates_prevented / cls._tags_checked * 100):.2f}%"
                if cls._tags_checked > 0
                else "0%"
            ),
        }

    @classmethod
    def print_stats(cls):
        """طباعة الإحصائيات"""
        stats = cls.get_stats()
        print("\n" + "=" * 80)
        print("📊 [MESSAGE TAGGER STATISTICS]")
        print("=" * 80)
        print(f"   🏷️ Tags Created: {stats['tags_created']}")
        print(f"   🔍 Tags Checked: {stats['tags_checked']}")
        print(f"   🛡️ Duplicates Prevented: {stats['duplicates_prevented']}")
        print(f"   📈 Efficiency: {stats['efficiency']}")
        print("=" * 80 + "\n")


# ═══════════════════════════════════════════════════════════════════════════
# نسخة محسّنة مع إحصائيات (اختياري)
# ═══════════════════════════════════════════════════════════════════════════


class MessageTaggerWithStats(MessageTagger):
    """
    نسخة محسّنة من MessageTagger مع تتبع الإحصائيات

    استخدمها بدلاً من MessageTagger إذا أردت مراقبة الأداء:

    from utils.message_tagger import MessageTaggerWithStats as MessageTagger
    """

    @staticmethod
    def mark_as_handled(context) -> None:
        MessageTagger.mark_as_handled(context)
        MessageTaggerStats.increment_created()

    @staticmethod
    def check_and_clear(context) -> bool:
        MessageTaggerStats.increment_checked()
        result = MessageTagger.check_and_clear(context)
        if result:
            MessageTaggerStats.increment_prevented()
        return result


# ═══════════════════════════════════════════════════════════════════════════
# 🧪 TESTING (للتطوير فقط)
# ═══════════════════════════════════════════════════════════════════════════

if __name__ == "__main__":
    print("🧪 Testing MessageTagger...\n")

    # محاكاة context
    class MockContext:
        def __init__(self):
            self.chat_data = {}

    context = MockContext()

    # اختبار 1: وسم الرسالة
    print("Test 1: Marking message...")
    MessageTagger.mark_as_handled(context)
    assert MessageTagger.is_handled(context) == True
    print("✅ Passed\n")

    # اختبار 2: فحص ومسح
    print("Test 2: Check and clear...")
    result = MessageTagger.check_and_clear(context)
    assert result == True
    assert MessageTagger.is_handled(context) == False
    print("✅ Passed\n")

    # اختبار 3: رسالة غير موسومة
    print("Test 3: Untagged message...")
    context2 = MockContext()
    assert MessageTagger.is_handled(context2) == False
    assert MessageTagger.check_and_clear(context2) == False
    print("✅ Passed\n")

    print("🎉 All tests passed!")
    print("\n📝 MessageTagger is ready for production!")


--- FC26_sale_coins_Bot/utils/session_bucket.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║                    🗂️ SESSION BUCKET SYSTEM                             ║
# ║                  نظام عزل بيانات الجلسات                               ║
# ║            منع تداخل البيانات بين الخدمات المختلفة                     ║
# ╚══════════════════════════════════════════════════════════════════════════╝

"""
🗂️ نظام مساحات العمل المعزولة (Session Buckets)

الهدف:
-------
منع تداخل بيانات الخدمات المختلفة داخل context.user_data.
بدلاً من حذف كل البيانات عند إنهاء محادثة، نحذف فقط بيانات المحادثة المحددة.

الاستخدام:
----------
بدلاً من:
    context.user_data['platform'] = 'pc'
    context.user_data.clear()

استخدم:
    bucket(context, 'reg')['platform'] = 'pc'
    clear_bucket(context, 'reg')

الفوائد:
--------
✅ عزل كامل بين الخدمات (reg, sell, admin)
✅ إنهاء محادثة لا يؤثر على محادثة أخرى
✅ أمان أعلى للبيانات
✅ متوافق مع Persistence
"""


def bucket(context, name: str) -> dict:
    """
    الحصول على مساحة عمل معزولة داخل context.user_data

    Args:
        context: telegram.ext.ContextTypes.DEFAULT_TYPE
        name: اسم المساحة (مثل 'reg', 'sell', 'admin')

    Returns:
        dict: قاموس خاص بهذه المساحة فقط

    Example:
        # في handlers التسجيل:
        bucket(context, 'reg')['platform'] = 'playstation'

        # في handlers البيع:
        bucket(context, 'sell')['amount'] = 5000

        # لا يتداخلان!
    """
    # إنشاء المساحة الرئيسية إذا لم تكن موجودة
    if '_buckets' not in context.user_data:
        context.user_data['_buckets'] = {}

    # إنشاء المساحة الفرعية إذا لم تكن موجودة
    if name not in context.user_data['_buckets']:
        context.user_data['_buckets'][name] = {}

    return context.user_data['_buckets'][name]


def clear_bucket(context, name: str) -> None:
    """
    مسح مساحة عمل محددة فقط (بدون التأثير على المساحات الأخرى)

    Args:
        context: telegram.ext.ContextTypes.DEFAULT_TYPE
        name: اسم المساحة المراد مسحها

    Example:
        # مسح بيانات التسجيل فقط
        clear_bucket(context, 'reg')

        # بيانات البيع تبقى كما هي!
        bucket(context, 'sell').get('amount')  # ✅ موجودة
    """
    if '_buckets' in context.user_data:
        if name in context.user_data['_buckets']:
            context.user_data['_buckets'][name].clear()
            print(f"   🧹 [BUCKET] Cleared bucket: {name}")


def get_all_buckets(context) -> dict:
    """
    الحصول على جميع المساحات (للفحص والتطوير)

    Args:
        context: telegram.ext.ContextTypes.DEFAULT_TYPE

    Returns:
        dict: جميع المساحات الموجودة
    """
    return context.user_data.get('_buckets', {})


def has_bucket(context, name: str) -> bool:
    """
    التحقق من وجود مساحة عمل

    Args:
        context: telegram.ext.ContextTypes.DEFAULT_TYPE
        name: اسم المساحة

    Returns:
        bool: True إذا كانت المساحة موجودة وغير فارغة
    """
    if '_buckets' not in context.user_data:
        return False
    return name in context.user_data['_buckets'] and bool(context.user_data['_buckets'][name])


# ═══════════════════════════════════════════════════════════════════════════
# 🧪 TESTING (للتطوير فقط)
# ═══════════════════════════════════════════════════════════════════════════

if __name__ == "__main__":
    print("🧪 Testing Session Bucket System...\n")

    # محاكاة context
    class MockContext:
        def __init__(self):
            self.user_data = {}

    context = MockContext()

    # اختبار 1: إنشاء مساحات منفصلة
    print("Test 1: Creating separate buckets...")
    bucket(context, 'reg')['platform'] = 'playstation'
    bucket(context, 'sell')['amount'] = 5000

    assert bucket(context, 'reg')['platform'] == 'playstation'
    assert bucket(context, 'sell')['amount'] == 5000
    print("✅ Passed\n")

    # اختبار 2: عزل البيانات
    print("Test 2: Data isolation...")
    clear_bucket(context, 'reg')

    assert 'platform' not in bucket(context, 'reg')
    assert bucket(context, 'sell')['amount'] == 5000  # لم تتأثر!
    print("✅ Passed\n")

    # اختبار 3: has_bucket
    print("Test 3: has_bucket check...")
    assert has_bucket(context, 'sell') == True
    assert has_bucket(context, 'reg') == False
    print("✅ Passed\n")

    print("🎉 All tests passed!")
    print("\n📝 Session Bucket System is ready for production!")


--- FC26_sale_coins_Bot/utils/session_monitor.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║                    📊 SESSION MONITOR SYSTEM                             ║
# ║                  نظام مراقبة صحة الجلسات                                ║
# ║            فحص دوري لملف الجلسات والتنبيه بالمشاكل                      ║
# ╚══════════════════════════════════════════════════════════════════════════╝

"""
📊 نظام مراقبة صحة الجلسات

الهدف:
-------
فحص دوري لملف الجلسات لاكتشاف المشاكل مبكراً.

الميزات:
--------
✅ فحص وجود الملف
✅ فحص حجم الملف (تحذير إذا تجاوز 50 MB)
✅ تقدير عدد الجلسات النشطة
✅ تحذيرات في الـ logs
✅ فحص كل 6 ساعات
"""

import pickle
from pathlib import Path


async def session_health_check(context):
    """
    فحص صحة ملف الجلسات

    يقوم بـ:
    1. التحقق من وجود الملف
    2. فحص حجم الملف
    3. تقدير عدد الجلسات النشطة
    4. طباعة تقرير في الـ logs

    Args:
        context: telegram.ext.ContextTypes.DEFAULT_TYPE
    """
    print(f"\n{'='*80}")
    print(f"📊 [SESSION-MONITOR] Health check started...")
    print(f"{'='*80}")

    session_file = Path("data/sessions.pkl")

    # فحص 1: وجود الملف
    if not session_file.exists():
        print(f"   ⚠️ [SESSION-MONITOR] Session file not found!")
        print(f"   📝 This is normal for first run")
        print(f"{'='*80}\n")
        return

    # فحص 2: حجم الملف
    try:
        size_bytes = session_file.stat().st_size
        size_mb = size_bytes / (1024 * 1024)

        print(f"   📁 [SESSION-MONITOR] File size: {size_mb:.2f} MB")

        if size_mb > 50:
            print(f"   ⚠️ [SESSION-MONITOR] WARNING: Large session file!")
            print(f"   💡 Consider clearing old sessions or optimizing")
        elif size_mb > 100:
            print(f"   🚨 [SESSION-MONITOR] CRITICAL: Very large session file!")
            print(f"   🔧 Immediate action required")
    except Exception as e:
        print(f"   ❌ [SESSION-MONITOR] Error checking file size: {e}")

    # فحص 3: محتوى الملف
    try:
        with open(session_file, "rb") as f:
            data = pickle.load(f)

        # تقدير عدد الجلسات
        if isinstance(data, dict):
            user_count = len(data.get("user_data", {}))
            chat_count = len(data.get("chat_data", {}))
            bot_data_exists = "bot_data" in data

            print(f"   👥 [SESSION-MONITOR] Active users: {user_count}")
            print(f"   💬 [SESSION-MONITOR] Active chats: {chat_count}")
            print(
                f"   🤖 [SESSION-MONITOR] Bot data: {'Yes' if bot_data_exists else 'No'}"
            )

            # تحذير إذا كان العدد كبير جداً
            if user_count > 10000:
                print(f"   ⚠️ [SESSION-MONITOR] Very high user count!")
        else:
            print(f"   ⚠️ [SESSION-MONITOR] Unexpected data format")

    except Exception as e:
        print(f"   ❌ [SESSION-MONITOR] Error reading session data: {e}")
        print(f"   💡 File might be corrupted or locked")

    print(f"{'='*80}")
    print(f"✅ [SESSION-MONITOR] Health check completed")
    print(f"{'='*80}\n")


def register_monitoring(app):
    """
    تسجيل وظيفة المراقبة في الجدول الزمني

    يقوم بتسجيل فحص صحة كل 6 ساعات

    Args:
        app: telegram.ext.Application
    """
    print("\n📊 [SESSION-MONITOR] Registering monitoring jobs...")

    # فحص صحة كل 6 ساعات
    app.job_queue.run_repeating(
        session_health_check,
        interval=21600,  # 6 ساعات بالثواني
        first=60,  # أول فحص بعد دقيقة من البدء
        name="session_monitoring",
    )
    print("   ✅ Health check scheduled: Every 6 hours")
    print("   ✅ First check: 1 minute after start")

    print("📊 [SESSION-MONITOR] Monitoring jobs registered successfully\n")


# ═══════════════════════════════════════════════════════════════════════════
# 🛠️ UTILITY FUNCTIONS (إضافية)
# ═══════════════════════════════════════════════════════════════════════════


def get_session_stats() -> dict:
    """
    الحصول على إحصائيات الجلسات

    Returns:
        dict: إحصائيات مفصلة
    """
    session_file = Path("data/sessions.pkl")

    if not session_file.exists():
        return {
            "exists": False,
            "size_mb": 0,
            "user_count": 0,
            "chat_count": 0,
        }

    stats = {
        "exists": True,
        "size_mb": round(session_file.stat().st_size / (1024 * 1024), 2),
    }

    try:
        with open(session_file, "rb") as f:
            data = pickle.load(f)

        if isinstance(data, dict):
            stats["user_count"] = len(data.get("user_data", {}))
            stats["chat_count"] = len(data.get("chat_data", {}))
            stats["has_bot_data"] = "bot_data" in data
        else:
            stats["user_count"] = 0
            stats["chat_count"] = 0
            stats["has_bot_data"] = False

    except:
        stats["user_count"] = 0
        stats["chat_count"] = 0
        stats["error"] = True

    return stats


def print_session_report():
    """
    طباعة تقرير مفصل عن الجلسات (للاستخدام اليدوي)
    """
    stats = get_session_stats()

    print("\n" + "=" * 80)
    print("📊 SESSION REPORT")
    print("=" * 80)

    if not stats["exists"]:
        print("❌ No session file found")
    else:
        print(f"✅ File exists: data/sessions.pkl")
        print(f"📁 Size: {stats['size_mb']} MB")
        print(f"👥 Users: {stats.get('user_count', 'N/A')}")
        print(f"💬 Chats: {stats.get('chat_count', 'N/A')}")
        print(f"🤖 Bot Data: {'Yes' if stats.get('has_bot_data') else 'No'}")

        if stats.get("error"):
            print("⚠️ Warning: Could not read session data")

    print("=" * 80 + "\n")


--- FC26_sale_coins_Bot/validators/__init__.py ---



--- FC26_sale_coins_Bot/validators/payment_validator.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              💳 FC26 PAYMENT VALIDATOR - مدقق بيانات الدفع             ║
# ║                     Payment Details Validation                           ║
# ╚══════════════════════════════════════════════════════════════════════════╝

import logging
import re
from typing import Any, Dict

logger = logging.getLogger(__name__)


class PaymentValidator:
    """Payment methods validation"""

    @classmethod
    def validate_payment_details(
        cls, payment_method: str, details: str
    ) -> Dict[str, Any]:
        """
        Validate payment details based on payment method

        Args:
            payment_method (str): Payment method type
            details (str): Payment details to validate

        Returns:
            Dict[str, Any]: Validation result with formatted data
        """
        try:
            # للمحافظ المحمولة وتيلدا - تحقق من الحروف والرموز أولاً
            if payment_method in [
                "vodafone_cash",
                "etisalat_cash",
                "orange_cash",
                "we_cash",
                "bank_wallet",
                "telda",
            ]:
                # تحقق من وجود حروف أو رموز غير مسموحة
                if re.search(r"[^\d\s\-]", details):  # أي حاجة غير رقم أو مسافة أو شرطة
                    return {
                        "valid": False,
                        "error": "❌ يُسمح بالأرقام فقط! لا تستخدم حروف أو رموز",
                    }

                # تحقق من وجود مسافات أو شرطات كتير
                special_chars_count = details.count(" ") + details.count("-")
                if special_chars_count > 5:
                    return {
                        "valid": False,
                        "error": "❌ مسافات أو شرطات كتيرة! اكتب الرقم بشكل بسيط",
                    }

            # Clean input for mobile wallets and Telda
            cleaned = (
                re.sub(r"[^\d]", "", details)
                if payment_method != "instapay"
                else details.strip()
            )

            # Route to specific validator
            if payment_method in [
                "vodafone_cash",
                "etisalat_cash",
                "orange_cash",
                "we_cash",
                "bank_wallet",
            ]:
                return cls._validate_mobile_wallet(cleaned, payment_method)
            elif payment_method == "telda":
                return cls._validate_telda_card(cleaned)
            elif payment_method == "instapay":
                return cls._validate_instapay(details)
            else:
                return {"valid": False, "error": "❌ طريقة دفع غير معروفة"}

        except Exception as e:
            logger.error(f"Payment validation error: {e}")
            return {"valid": False, "error": "❌ حدث خطأ في التحقق من بيانات الدفع"}

    @classmethod
    def _validate_mobile_wallet(
        cls, cleaned: str, payment_method: str
    ) -> Dict[str, Any]:
        """Validate mobile wallet phone number"""

        # تحقق من وجود أرقام أصلاً
        if not cleaned:
            return {
                "valid": False,
                "error": "❌ لم يتم العثور على أرقام! أدخل رقم صحيح",
            }

        if not re.match(r"^01[0125][0-9]{8}$", cleaned):
            return {
                "valid": False,
                "error": "❌ رقم غير صحيح. يجب أن يبدأ بـ 010/011/012/015 ويتكون من 11 رقماً",
            }

        # Check if number matches payment method (optional validation)
        provider_map = {
            "vodafone_cash": "010",
            "etisalat_cash": "011",
            "orange_cash": "012",
            "we_cash": "015",
        }

        expected_prefix = provider_map.get(payment_method)
        if expected_prefix and not cleaned.startswith(expected_prefix):
            warning = f"⚠️ تحذير: الرقم لا يطابق شبكة {payment_method.replace('_cash', '').title()}"
        else:
            warning = None

        return {
            "valid": True,
            "cleaned": cleaned,
            "formatted": f"+20{cleaned}",
            "display": cleaned,
            "clickable": cleaned,
            "warning": warning,
        }

    @classmethod
    def _validate_telda_card(cls, cleaned: str) -> Dict[str, Any]:
        """Validate Telda card number"""

        # تحقق من وجود أرقام أصلاً
        if not cleaned:
            return {
                "valid": False,
                "error": "❌ لم يتم العثور على أرقام! أدخل رقم كارت صحيح",
            }

        if len(cleaned) != 16 or not cleaned.isdigit():
            return {
                "valid": False,
                "error": "❌ رقم كارت تيلدا غير صحيح. يجب أن يتكون من 16 رقماً بالضبط",
            }

        # Format card number for display (بدون تشفير)
        formatted = f"{cleaned[:4]}-{cleaned[4:8]}-{cleaned[8:12]}-{cleaned[12:16]}"

        return {
            "valid": True,
            "cleaned": cleaned,
            "formatted": formatted,
            "display": cleaned,
            "formatted_display": formatted,
            "clickable": cleaned,
        }

    @classmethod
    def _validate_instapay(cls, details: str) -> Dict[str, Any]:
        """Validate InstaPay URL and extract clean URL from any text"""
        details = details.strip()

        # Extract clean InstaPay URL from text using advanced regex patterns
        url_patterns = [
            # Pattern 1: Full URLs with https/http
            r"https?://[^\s]*(?:instapay\.com\.eg|ipn\.eg)[^\s]*",
            # Pattern 2: URLs without protocol
            r"(?:instapay\.com\.eg|ipn\.eg)[^\s]*",
            # Pattern 3: Find URLs within Arabic/English text
            r"(?:https?://)?(?:www\.)?(?:instapay\.com\.eg|ipn\.eg)[^\s\u0600-\u06FF]*",
            # Pattern 4: Extract from any position in text
            r"(?:https?://)?[^\s]*(?:instapay\.com\.eg|ipn\.eg)[^\s]*",
        ]

        clean_url = None

        # Try each pattern to extract URL
        for pattern in url_patterns:
            matches = re.findall(pattern, details, re.IGNORECASE)
            if matches:
                # Get the first match and clean it
                potential_url = matches[0].strip()

                # Clean URL from any trailing characters
                potential_url = re.sub(r"[^\w\-\.\/\:\?=&%]+$", "", potential_url)

                # Verify it contains the domain
                if any(
                    domain in potential_url.lower()
                    for domain in ["instapay.com.eg", "ipn.eg"]
                ):
                    clean_url = potential_url
                    break

        # If no URL found, check if text contains domain
        if not clean_url:
            if any(
                domain in details.lower() for domain in ["instapay.com.eg", "ipn.eg"]
            ):
                return {
                    "valid": False,
                    "error": "❌ تم العثور على نطاق إنستاباي ولكن لا يمكن استخراج رابط صحيح. أرسل الرابط كاملاً",
                }
            else:
                return {
                    "valid": False,
                    "error": "❌ لم يتم العثور على رابط إنستاباي. يجب أن يحتوي على instapay.com.eg أو ipn.eg",
                }

        # Add https if missing
        if not clean_url.startswith(("http://", "https://")):
            clean_url = "https://" + clean_url

        # Final validation
        if not any(
            domain in clean_url.lower() for domain in ["instapay.com.eg", "ipn.eg"]
        ):
            return {
                "valid": False,
                "error": "❌ رابط إنستاباي غير صحيح. يجب أن يحتوي على instapay.com.eg أو ipn.eg",
            }

        # Additional URL cleanup - remove any duplicate protocols
        clean_url = re.sub(r"https?://(https?://)+", "https://", clean_url)

        return {
            "valid": True,
            "cleaned": clean_url,
            "formatted": clean_url,
            "display": clean_url,
            "clickable": clean_url,
        }

    @classmethod
    def validate_whatsapp(cls, phone: str) -> Dict[str, Any]:
        """Validate WhatsApp phone number - 11 digits only starting with 010/011/012/015"""
        try:
            # تحقق من وجود حروف أو رموز قبل التنظيف
            if re.search(r"[^\d\s]", phone):  # أي حاجة غير رقم أو مسافة
                return {
                    "valid": False,
                    "error": "❌ يُسمح بالأرقام فقط! لا تستخدم حروف أو رموز",
                }

            # تحقق من وجود مسافات كتير
            if phone.count(" ") > 3:  # لو المسافات كتير أوي
                return {
                    "valid": False,
                    "error": "❌ مسافات كتيرة! اكتب الرقم بدون مسافات أو بمسافات قليلة",
                }

            # Clean input - remove all non-digits
            cleaned = re.sub(r"[^\d]", "", phone)

            # تحقق من وجود أرقام أصلاً
            if not cleaned:
                return {
                    "valid": False,
                    "error": "❌ لم يتم العثور على أرقام! أدخل رقم واتساب صحيح",
                }

            # Check exact length
            if len(cleaned) != 11:
                return {
                    "valid": False,
                    "error": "❌ رقم غير صحيح. يجب أن يتكون من 11 رقماً بالضبط",
                }

            # Check if starts with valid Egyptian prefixes
            if not re.match(r"^01[0125][0-9]{8}$", cleaned):
                return {
                    "valid": False,
                    "error": "❌ رقم غير صحيح. يجب أن يبدأ بـ 010/011/012/015 ويتكون من 11 رقماً",
                }

            return {
                "valid": True,
                "cleaned": cleaned,
                "formatted": f"+20{cleaned}",
                "display": cleaned,
                "clickable": cleaned,
            }

        except Exception as e:
            logger.error(f"WhatsApp validation error: {e}")
            return {"valid": False, "error": "❌ حدث خطأ في التحقق من رقم الواتساب"}

    @classmethod
    def get_payment_instructions(cls, payment_method: str) -> str:
        """Get specific instructions for payment method"""
        instructions = {
            "vodafone_cash": "أدخل رقم فودافون كاش (11 رقماً يبدأ بـ 010) - أرقام فقط!",
            "etisalat_cash": "أدخل رقم اتصالات كاش (11 رقماً يبدأ بـ 011) - أرقام فقط!",
            "orange_cash": "أدخل رقم أورانج كاش (11 رقماً يبدأ بـ 012) - أرقام فقط!",
            "we_cash": "أدخل رقم وي كاش (11 رقماً يبدأ بـ 015) - أرقام فقط!",
            "bank_wallet": "أدخل رقم المحفظة البنكية (11 رقماً لأي شبكة مصرية) - أرقام فقط!",
            "telda": "أدخل رقم كارت تيلدا (16 رقماً بدون مسافات) - أرقام فقط!",
            "instapay": "أدخل رابط إنستاباي الكامل\n<b>مثال:</b> https://instapay.com.eg/abc123",
        }

        return instructions.get(payment_method, "أدخل تفاصيل الدفع")

    @classmethod
    def get_payment_examples(cls, payment_method: str) -> str:
        """Get examples for payment method"""
        examples = {
            "vodafone_cash": "<b>مثال:</b> 01012345678 (أرقام فقط)",
            "etisalat_cash": "<b>مثال:</b> 01112345678 (أرقام فقط)",
            "orange_cash": "<b>مثال:</b> 01212345678 (أرقام فقط)",
            "we_cash": "<b>مثال:</b> 01512345678 (أرقام فقط)",
            "bank_wallet": "<b>مثال:</b> 01012345678 (أي شبكة - أرقام فقط)",
            "telda": "<b>مثال:</b> 1234567890123456 (16 رقم - أرقام فقط)",
            "instapay": "<b>مثال:</b> https://instapay.com.eg/abc123",
        }

        return examples.get(payment_method, "")


--- FC26_sale_coins_Bot/validators/phone_validator.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              📱 FC26 PHONE VALIDATOR - مدقق أرقام الهاتف              ║
# ║                     Phone Number Validation                              ║
# ╚══════════════════════════════════════════════════════════════════════════╝

import logging
import re
from typing import Any, Dict

logger = logging.getLogger(__name__)


class PhoneValidator:
    """Egyptian phone number validation"""

    # Egyptian mobile patterns
    EGYPTIAN_PATTERNS = {
        "vodafone": r"^010[0-9]{8}$",
        "etisalat": r"^011[0-9]{8}$",
        "orange": r"^012[0-9]{8}$",
        "we": r"^015[0-9]{8}$",
        "general": r"^01[0125][0-9]{8}$",
    }

    @classmethod
    def validate_whatsapp(cls, phone: str) -> Dict[str, Any]:
        """
        Validate Egyptian WhatsApp phone number - أرقام فقط

        Args:
            phone (str): Phone number to validate

        Returns:
            Dict[str, Any]: Validation result with formatted data
        """
        try:
            # تحقق من وجود حروف أو رموز قبل التنظيف
            if re.search(r"[^\d\s]", phone):  # أي حاجة غير رقم أو مسافة
                return {
                    "valid": False,
                    "error": "❌ يُسمح بالأرقام فقط! لا تستخدم حروف أو رموز",
                }

            # تحقق من وجود مسافات كتير
            if phone.count(" ") > 3:  # لو المسافات كتير أوي
                return {
                    "valid": False,
                    "error": "❌ مسافات كتيرة! اكتب الرقم بدون مسافات أو بمسافات قليلة",
                }

            # Clean input - remove all non-digits
            cleaned = re.sub(r"[^\d]", "", phone)

            # تحقق من وجود أرقام أصلاً
            if not cleaned:
                return {
                    "valid": False,
                    "error": "❌ لم يتم العثور على أرقام! أدخل رقم واتساب صحيح",
                }

            # Validate Egyptian mobile pattern
            if not re.match(cls.EGYPTIAN_PATTERNS["general"], cleaned):
                return {
                    "valid": False,
                    "error": "❌ رقم غير صحيح. يجب أن يبدأ بـ 010/011/012/015 ويتكون من 11 رقماً",
                }

            # Determine network provider
            provider = cls._get_network_provider(cleaned)

            return {
                "valid": True,
                "cleaned": cleaned,
                "formatted": f"+20{cleaned}",
                "display": cleaned,  # Enhanced UX: Display without country code
                "provider": provider,
                "clickable": f"<code>{cleaned}</code>",  # For Telegram click-to-copy
            }

        except Exception as e:
            logger.error(f"Phone validation error: {e}")
            return {"valid": False, "error": "❌ حدث خطأ في التحقق من الرقم"}

    @classmethod
    def _get_network_provider(cls, phone: str) -> str:
        """Get network provider from phone number"""
        if phone.startswith("010"):
            return "vodafone"
        elif phone.startswith("011"):
            return "etisalat"
        elif phone.startswith("012"):
            return "orange"
        elif phone.startswith("015"):
            return "we"
        else:
            return "unknown"

    @classmethod
    def format_for_display(cls, phone: str, include_country_code: bool = False) -> str:
        """Format phone number for display"""
        cleaned = re.sub(r"[^\d]", "", phone)

        if include_country_code:
            return f"+20 {cleaned[:3]} {cleaned[3:6]} {cleaned[6:]}"
        else:
            return f"{cleaned[:3]} {cleaned[3:6]} {cleaned[6:]}"

    @classmethod
    def is_valid_egyptian_mobile(cls, phone: str) -> bool:
        """Quick check if phone is valid Egyptian mobile"""
        cleaned = re.sub(r"[^\d]", "", phone)
        return bool(re.match(cls.EGYPTIAN_PATTERNS["general"], cleaned))

    @classmethod
    def get_validation_tips(cls) -> str:
        """Get validation tips message"""
        return """💡 <b>قواعد إدخال رقم الواتساب:</b>

✅ <b>المسموح:</b>
   • أرقام فقط: 01012345678
   • مسافات قليلة: 010 123 456 78

❌ <b>غير مسموح:</b>
   • حروف: 010abc45678
   • رموز: 010-123-4567
   • أقواس: (010) 1234567

🔢 <b>الشكل الصحيح:</b>
   • يبدأ بـ: 010, 011, 012, 015
   • العدد: 11 رقم بالضبط

🔹 <b>أمثلة صحيحة:</b>
   • 01012345678
   • 01112345678
   • 01212345678
   • 01512345678

❌ <b>أمثلة خاطئة:</b>
   • +201012345678 (لا تضع كود الدولة)
   • 1012345678 (ناقص صفر في البداية)
   • 010123456 (أقل من 11 رقم)"""


--- FC26_sale_coins_Bot/validators/url_validator.py ---

# ╔══════════════════════════════════════════════════════════════════════════╗
# ║              🔗 FC26 URL VALIDATOR - مدقق الروابط                       ║
# ║                        URL Validation                                    ║
# ╚══════════════════════════════════════════════════════════════════════════╝

import re
import logging
from typing import Dict, Any, List
from urllib.parse import urlparse

logger = logging.getLogger(__name__)

class URLValidator:
    """URL validation for InstaPay and other links"""
    
    INSTAPAY_DOMAINS = [
        'instapay.com.eg',
        'ipn.eg',
        'instapay.eg'
    ]
    
    @classmethod
    def validate_instapay_url(cls, url: str) -> Dict[str, Any]:
        """
        Validate InstaPay URL
        
        Args:
            url (str): URL to validate
            
        Returns:
            Dict[str, Any]: Validation result
        """
        try:
            # Clean and normalize URL
            cleaned_url = url.strip()
            
            # Add protocol if missing
            if not cleaned_url.startswith(('http://', 'https://')):
                cleaned_url = 'https://' + cleaned_url
            
            # Parse URL
            parsed = urlparse(cleaned_url)
            
            # Check if it's a valid URL structure
            if not parsed.netloc:
                return {
                    "valid": False,
                    "error": "❌ رابط غير صحيح. تأكد من إدخال رابط كامل",
                }
            
            # Check InstaPay domains
            domain_valid = any(domain in parsed.netloc.lower() for domain in cls.INSTAPAY_DOMAINS)
            
            if not domain_valid:
                return {
                    "valid": False,
                    "error": f"❌ رابط إنستاباي غير صحيح. يجب أن يحتوي على أحد النطاقات التالية:\n" +
                            "\n".join([f"• {domain}" for domain in cls.INSTAPAY_DOMAINS]),
                }
            
            # Additional security checks
            security_check = cls._security_validate_url(cleaned_url)
            if not security_check["valid"]:
                return security_check
            
            return {
                "valid": True,
                "cleaned": cleaned_url,
                "formatted": cleaned_url,
                "display": cleaned_url,
                "clickable": f"<code>{cleaned_url}</code>",
                "domain": parsed.netloc,
                "path": parsed.path
            }
            
        except Exception as e:
            logger.error(f"URL validation error: {e}")
            return {
                "valid": False,
                "error": "❌ حدث خطأ في التحقق من الرابط"
            }
    
    @classmethod
    def _security_validate_url(cls, url: str) -> Dict[str, Any]:
        """Security validation for URLs"""
        
        # Check for suspicious patterns
        suspicious_patterns = [
            r'javascript:',
            r'data:',
            r'file:',
            r'ftp:',
            r'<script',
            r'onclick',
            r'onload'
        ]
        
        url_lower = url.lower()
        for pattern in suspicious_patterns:
            if re.search(pattern, url_lower):
                return {
                    "valid": False,
                    "error": "❌ الرابط يحتوي على محتوى مشبوه"
                }
        
        # Check URL length (reasonable limit)
        if len(url) > 500:
            return {
                "valid": False,
                "error": "❌ الرابط طويل جداً"
            }
        
        return {"valid": True}
    
    @classmethod
    def extract_instapay_from_text(cls, text: str) -> List[str]:
        """Extract InstaPay URLs from text"""
        try:
            # Pattern to match URLs containing InstaPay domains
            patterns = []
            for domain in cls.INSTAPAY_DOMAINS:
                patterns.append(rf'https?://[^\s]*{re.escape(domain)}[^\s]*')
            
            found_urls = []
            for pattern in patterns:
                matches = re.findall(pattern, text, re.IGNORECASE)
                found_urls.extend(matches)
            
            return list(set(found_urls))  # Remove duplicates
            
        except Exception as e:
            logger.error(f"Error extracting URLs: {e}")
            return []
    
    @classmethod
    def is_valid_url_format(cls, url: str) -> bool:
        """Quick check if URL has valid format"""
        try:
            parsed = urlparse(url)
            return bool(parsed.netloc and parsed.scheme in ['http', 'https'])
        except:
            return False
    
    @classmethod
    def get_instapay_help_message(cls) -> str:
        """Get help message for InstaPay URL format"""
        return f"""💡 <b>كيفية إدخال رابط إنستاباي:</b>

🔹 <b>النطاقات المقبولة:</b>
{chr(10).join([f"   • {domain}" for domain in cls.INSTAPAY_DOMAINS])}

🔹 <b>أمثلة صحيحة:</b>
   • https://instapay.com.eg/abc123
   • https://ipn.eg/xyz789
   • instapay.com.eg/payment/456 (سيتم إضافة https تلقائياً)

🔹 <b>نصائح:</b>
   • انسخ الرابط كاملاً من إنستاباي
   • تأكد من صحة الرابط قبل الإرسال
   • لا تحتاج لإضافة https:// (سيتم إضافتها تلقائياً)

❌ <b>أمثلة خاطئة:</b>
   • روابط من مواقع أخرى
   • روابط غير مكتملة
   • نصوص بدون رابط"""
